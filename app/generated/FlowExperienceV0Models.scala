/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.7.73
 * apibuilder 0.14.75 app.apibuilder.io/flow/experience/0.7.73/play_2_x_json
 */
package io.flow.experience.v0.models {

  sealed trait AllocationComponent extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type AllocationComponent
   */
  sealed trait AllocationComponentDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AllocationComponentDiscriminator {

    case object AllocationDetailComponent extends AllocationComponentDiscriminator { override def toString = "allocation_detail_component" }
    case object AllocationLevyComponent extends AllocationComponentDiscriminator { override def toString = "allocation_levy_component" }

    final case class UNDEFINED(override val toString: String) extends AllocationComponentDiscriminator

    val all: scala.List[AllocationComponentDiscriminator] = scala.List(AllocationDetailComponent, AllocationLevyComponent)

    private[this] val byName: Map[String, AllocationComponentDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AllocationComponentDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AllocationComponentDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait AllocationDetail extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type AllocationDetail
   */
  sealed trait AllocationDetailDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AllocationDetailDiscriminator {

    case object AllocationLineDetail extends AllocationDetailDiscriminator { override def toString = "allocation_line_detail" }
    case object AllocationOrderDetail extends AllocationDetailDiscriminator { override def toString = "allocation_order_detail" }

    final case class UNDEFINED(override val toString: String) extends AllocationDetailDiscriminator

    val all: scala.List[AllocationDetailDiscriminator] = scala.List(AllocationLineDetail, AllocationOrderDetail)

    private[this] val byName: Map[String, AllocationDetailDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AllocationDetailDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AllocationDetailDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait ExpandableExperience extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type ExpandableExperience
   */
  sealed trait ExpandableExperienceDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ExpandableExperienceDiscriminator {

    case object Experience extends ExpandableExperienceDiscriminator { override def toString = "experience" }
    case object ExperienceReference extends ExpandableExperienceDiscriminator { override def toString = "experience_reference" }

    final case class UNDEFINED(override val toString: String) extends ExpandableExperienceDiscriminator

    val all: scala.List[ExpandableExperienceDiscriminator] = scala.List(Experience, ExperienceReference)

    private[this] val byName: Map[String, ExpandableExperienceDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExpandableExperienceDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExpandableExperienceDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait ExpandableOrder extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type ExpandableOrder
   */
  sealed trait ExpandableOrderDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ExpandableOrderDiscriminator {

    case object Order extends ExpandableOrderDiscriminator { override def toString = "order" }
    case object OrderReference extends ExpandableOrderDiscriminator { override def toString = "order_reference" }

    final case class UNDEFINED(override val toString: String) extends ExpandableOrderDiscriminator

    val all: scala.List[ExpandableOrderDiscriminator] = scala.List(Order, OrderReference)

    private[this] val byName: Map[String, ExpandableOrderDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExpandableOrderDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExpandableOrderDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait OrderNumberGenerator extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type OrderNumberGenerator
   */
  sealed trait OrderNumberGeneratorDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object OrderNumberGeneratorDiscriminator {

    case object OrderNumberGeneratorUuid extends OrderNumberGeneratorDiscriminator { override def toString = "uuid" }
    case object OrderNumberGeneratorHexadecimal extends OrderNumberGeneratorDiscriminator { override def toString = "hexadecimal" }
    case object OrderNumberGeneratorPrefixSuffix extends OrderNumberGeneratorDiscriminator { override def toString = "prefix_suffix" }

    final case class UNDEFINED(override val toString: String) extends OrderNumberGeneratorDiscriminator

    val all: scala.List[OrderNumberGeneratorDiscriminator] = scala.List(OrderNumberGeneratorUuid, OrderNumberGeneratorHexadecimal, OrderNumberGeneratorPrefixSuffix)

    private[this] val byName: Map[String, OrderNumberGeneratorDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderNumberGeneratorDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderNumberGeneratorDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait OrderPromotion extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type OrderPromotion
   */
  sealed trait OrderPromotionDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object OrderPromotionDiscriminator {

    case object FreeShippingOrderPromotion extends OrderPromotionDiscriminator { override def toString = "free_shipping_order_promotion" }

    final case class UNDEFINED(override val toString: String) extends OrderPromotionDiscriminator

    val all: scala.List[OrderPromotionDiscriminator] = scala.List(FreeShippingOrderPromotion)

    private[this] val byName: Map[String, OrderPromotionDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderPromotionDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderPromotionDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait OrderPromotionForm extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type OrderPromotionForm
   */
  sealed trait OrderPromotionFormDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object OrderPromotionFormDiscriminator {

    case object FreeShippingOrderPromotionForm extends OrderPromotionFormDiscriminator { override def toString = "free_shipping_order_promotion_form" }

    final case class UNDEFINED(override val toString: String) extends OrderPromotionFormDiscriminator

    val all: scala.List[OrderPromotionFormDiscriminator] = scala.List(FreeShippingOrderPromotionForm)

    private[this] val byName: Map[String, OrderPromotionFormDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderPromotionFormDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderPromotionFormDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait PaymentMethodTag extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type PaymentMethodTag
   */
  sealed trait PaymentMethodTagDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object PaymentMethodTagDiscriminator {

    case object OrganizationPaymentMethodTag extends PaymentMethodTagDiscriminator { override def toString = "organization_payment_method_tag" }
    case object ExperiencePaymentMethodTag extends PaymentMethodTagDiscriminator { override def toString = "experience_payment_method_tag" }

    final case class UNDEFINED(override val toString: String) extends PaymentMethodTagDiscriminator

    val all: scala.List[PaymentMethodTagDiscriminator] = scala.List(OrganizationPaymentMethodTag, ExperiencePaymentMethodTag)

    private[this] val byName: Map[String, PaymentMethodTagDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PaymentMethodTagDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PaymentMethodTagDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait Promotion extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type Promotion
   */
  sealed trait PromotionDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object PromotionDiscriminator {

    case object FreeShipping extends PromotionDiscriminator { override def toString = "free_shipping" }
    case object Discount extends PromotionDiscriminator { override def toString = "discount" }

    final case class UNDEFINED(override val toString: String) extends PromotionDiscriminator

    val all: scala.List[PromotionDiscriminator] = scala.List(FreeShipping, Discount)

    private[this] val byName: Map[String, PromotionDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PromotionDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PromotionDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * @param country The ISO 3166-3 country code. Case insensitive. See
   *        https://api.flow.io/reference/countries
   */
  final case class AddressConfiguration(
    country: String,
    fieldValidation: io.flow.experience.v0.models.AddressFieldValidation,
    provinces: Seq[io.flow.reference.v0.models.Province] = Nil
  )

  final case class AddressFieldValidation(
    firstName: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil,
    lastName: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil,
    street1: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil,
    street2: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil,
    city: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil,
    province: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil,
    postal: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil,
    phone: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil
  )

  @deprecated("Use 'allocation_v2'")
  final case class Allocation(
    order: io.flow.experience.v0.models.AllocationOrderSummary,
    details: Seq[io.flow.experience.v0.models.AllocationDetail]
  )

  /**
   * Represents any component that is not VAT or duty, such as item price, rounding,
   * shipping, etc.
   * 
   * @param total Represents the total price of this line item, which equals the price times the
   *        quantity.
   * @param price Represents the price of all included detail components for one unit of this line
   *        item.
   */
  final case class AllocationDetailComponent(
    key: io.flow.experience.v0.models.OrderPriceDetailComponentKey,
    total: io.flow.common.v0.models.PriceWithBase,
    price: _root_.scala.Option[io.flow.common.v0.models.PriceWithBase] = None
  ) extends AllocationComponent

  /**
   * Represents either a VAT or duty component.
   * 
   * @param total Represents the total price of this line item, which equals the price times the
   *        quantity.
   * @param rate The rate of the levy.
   * @param name The name of the levy, for display purposes.
   * @param price Represents the price of all included detail components for one unit of this line
   *        item.
   * @param accuracy Used to flag prices that are estimated and why. Missing values will be
   *        considered calculated. An order may only be submitted if all price components
   *        are calculated.
   * @param basis The taxable/dutiable basis from which this levy component was produced. Should
   *        be equal to total / rate.
   */
  final case class AllocationLevyComponent(
    key: io.flow.experience.v0.models.OrderPriceDetailComponentKey,
    total: io.flow.common.v0.models.PriceWithBase,
    rate: BigDecimal,
    name: String,
    price: _root_.scala.Option[io.flow.common.v0.models.PriceWithBase] = None,
    accuracy: io.flow.price.v0.models.PriceAccuracy = io.flow.price.v0.models.PriceAccuracy.Calculated,
    basis: _root_.scala.Option[io.flow.common.v0.models.MoneyWithBase] = None
  ) extends AllocationComponent

  /**
   * @param price Represents the price of all included detail components for one unit of this line
   *        item.
   * @param total Represents the total price of this line item, which equals the price times the
   *        quantity.
   * @param included Contains all components that are included in this detail's total.
   * @param notIncluded Contains all components that are not included in this detail's total. For
   *        example, this may contain VAT components when the VAT pricing setting is
   *        displayed or ignored.
   */
  final case class AllocationLineDetail(
    number: String,
    quantity: Long,
    key: io.flow.experience.v0.models.OrderPriceDetailKey,
    price: io.flow.common.v0.models.PriceWithBase,
    total: io.flow.common.v0.models.PriceWithBase,
    included: Seq[io.flow.experience.v0.models.AllocationComponent],
    notIncluded: Seq[io.flow.experience.v0.models.AllocationComponent]
  ) extends AllocationDetail

  /**
   * Represents an order-specific detail such as shipping, insurance, or an
   * order-level discount.
   * 
   * @param included Contains all components that are included in this detail's total.
   * @param notIncluded Contains all components that are not included in this detail's total. For
   *        example, this may contain VAT components when the VAT pricing setting is
   *        displayed or ignored.
   */
  final case class AllocationOrderDetail(
    key: io.flow.experience.v0.models.OrderPriceDetailKey,
    total: io.flow.common.v0.models.PriceWithBase,
    included: Seq[io.flow.experience.v0.models.AllocationComponent],
    notIncluded: Seq[io.flow.experience.v0.models.AllocationComponent]
  ) extends AllocationDetail

  /**
   * @param submittedAt The timestamp on which the order is submitted
   */
  final case class AllocationOrderSummary(
    id: String,
    number: String,
    submittedAt: _root_.scala.Option[_root_.org.joda.time.DateTime] = None
  )

  final case class AllocationV2(
    id: String,
    order: io.flow.experience.v0.models.AllocationOrderSummary,
    details: Seq[io.flow.experience.v0.models.AllocationDetail],
    total: io.flow.catalog.v0.models.LocalizedTotal
  )

  final case class AvailablePromotion(
    id: String,
    shippingConfiguration: io.flow.fulfillment.v0.models.ShippingConfigurationReference,
    region: io.flow.experience.v0.models.RegionReference,
    promotions: Seq[io.flow.experience.v0.models.Promotion]
  )

  /**
   * A Checkout Attribute defines an attribute that will be made available via the
   * checkout item content. This is useful if you would like to surface a specific
   * attribute (like 'size' or 'color') in checkout.
   * 
   * @param attributeKeys The attribute keys containing the desired value. The first key that is defined
   *        will be selected. For example, specify ['size', 'sizeName'] to select the 'size'
   *        attribute if present, and if not the 'sizeName' attribute.
   */
  final case class CheckoutAttribute(
    id: String,
    experience: io.flow.experience.v0.models.ExperienceReference,
    key: String,
    attributeKeys: Seq[String],
    position: Long
  )

  /**
   * @param attributeKeys The attribute keys containing the desired value. The first key that is defined
   *        will be selected. For example, specify ['size', 'sizeName'] to select the 'size'
   *        attribute if present, and if not the 'sizeName' attribute.
   */
  final case class CheckoutAttributeForm(
    key: String,
    experienceKey: String,
    attributeKeys: Seq[String],
    position: _root_.scala.Option[Long] = None
  )

  /**
   * A Checkout Item Content provides information about an item to support rendering
   * of that item in the context of checkout
   * 
   * @param attributes Returns a list of item attributes w/ intent 'checkout_content'
   * @param image Provides the primary image to use in checkout. This image will be selected by
   *        finding the item image with tag 'checkout', defaulting to another available
   *        image if there is one.
   */
  final case class CheckoutItemContent(
    item: io.flow.catalog.v0.models.Item,
    name: String,
    description: _root_.scala.Option[String] = None,
    attributes: Seq[io.flow.experience.v0.models.CheckoutItemContentAttribute],
    image: _root_.scala.Option[io.flow.catalog.v0.models.Image] = None
  )

  final case class CheckoutItemContentAttribute(
    key: String,
    value: String
  )

  final case class CheckoutSettings(
    configuration: io.flow.experience.v0.models.ExperienceConfigurationReference
  )

  /**
   * A Credit Payment records a 'non cash' payment against an order (e.g. a store
   * credit, gift card, etc.), recording the amount of that credit and additional
   * details to reconcile payments. The primary purpose of the credit payment is to
   * record that a payment has been made against an order so the remaining balance
   * can be correctly computed.
   * 
   * @param description Description to show to the user describing the source of this credit payment
   * @param value The value of the credit in the local and base currencies of the associated
   *        order. This value will match the original credit payment if the currency is the
   *        same as the order or otherwise will match the currency of the order
   * @param original The provided value and maximum value amounts and currencies applicable fot the
   *        store credit
   */
  final case class CreditPayment(
    id: String,
    order: io.flow.experience.v0.models.ExpandableOrder,
    key: String,
    description: String,
    value: io.flow.common.v0.models.PriceWithBase,
    original: io.flow.experience.v0.models.OriginalPrices,
    attributes: Map[String, String]
  )

  final case class CreditPaymentError(
    code: io.flow.experience.v0.models.CreditPaymentErrorCode,
    messages: Seq[String],
    codes: Seq[io.flow.experience.v0.models.CreditPaymentErrorCode]
  )

  /**
   * @param description Description to show to the user describing the source of this credit payment
   * @param max Indicates the maximum amount applicable for this credit payment.
   * @param currency The ISO-4217 3 character currency code in which the amount is calculated.
   */
  final case class CreditPaymentForm(
    orderNumber: String,
    description: String,
    amount: BigDecimal,
    max: BigDecimal,
    currency: String,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  final case class CreditPaymentVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    creditPayment: io.flow.experience.v0.models.CreditPayment
  )

  /**
   * @param default Default delivered duty setting based on experience default settings and
   *        reference data.
   * @param available Available delivered duty options to pick.
   */
  final case class DeliveredDutySetting(
    default: io.flow.common.v0.models.DeliveredDuty,
    available: Seq[io.flow.common.v0.models.DeliveredDuty],
    display: _root_.scala.Option[io.flow.experience.v0.models.DeliveredDutyDisplayType] = None
  )

  /**
   * @param code Indicates what discount code this discount is associated with
   */
  final case class Discount(
    id: String,
    code: _root_.scala.Option[String] = None,
    label: String,
    price: io.flow.common.v0.models.PriceWithBase,
    attributes: _root_.scala.Option[Map[String, String]] = None
  ) extends Promotion

  /**
   * Experiences define a local experience for a given geographic region
   * 
   * @param deliveredDuty Determines if a given experience should be DDP, DDU, or customer choice. If DDP,
   *        note that in some cases if a customer is shipping to a country where DDP is not
   *        available, information may still come back as DDU
   * @param region Reference to region as defined in https://api.flow.io/reference/regions
   * @param country When otherwise not known, the default country to use for this experience. One
   *        example would be an experience setup for Europe - when you request landed cost,
   *        if there is no geolocation information available, we will use this country as
   *        the basis for landed cost. ISO 3166 3 currency code as defined in
   *        https://api.flow.io/reference/countries
   * @param currency This currency defines the base currency for all pricing related features - e.g.
   *        pricing functions. ISO 4217 3 currency code as defined in
   *        https://api.flow.io/reference/currencies
   * @param language The default language to use for when displaying products, e.g. to display
   *        product information in this language by default. ISO 639 2 language code as
   *        defined in https://api.flow.io/reference/languages
   * @param position Position of this experience relative to other experiences. Lower position
   *        indicates experience should be considered first. Main use is to resolve incoming
   *        geolocation data (e.g. ip, country) to pick an experience. We do this by walking
   *        through the list of experiences to find the first one that matches the user's
   *        geography.
   * @param status Will always be present (optional for backwards compatibility).
   */
  final case class Experience(
    id: String,
    key: String,
    name: String,
    deliveredDuty: io.flow.common.v0.models.DeliveredDuty,
    region: io.flow.experience.v0.models.RegionReference,
    country: String,
    currency: String,
    language: String,
    measurementSystem: io.flow.common.v0.models.MeasurementSystem,
    subcatalog: io.flow.catalog.v0.models.SubcatalogReference,
    position: Long,
    settings: io.flow.experience.v0.models.ExperienceSettings,
    status: _root_.scala.Option[io.flow.experience.v0.models.ExperienceStatus] = None
  ) extends ExpandableExperience

  final case class ExperienceCheckoutSettings(
    id: String,
    experience: io.flow.experience.v0.models.ExperienceOverview,
    checkoutConfiguration: io.flow.experience.v0.models.ExperienceConfigurationReference
  )

  final case class ExperienceCheckoutSettingsForm(
    checkoutConfigurationId: String
  )

  /**
   * Represents a request to clone an experience.
   * 
   * @param clonedExperience This is the newly created (cloned) experience
   */
  final case class ExperienceClone(
    id: String,
    sourceExperience: io.flow.experience.v0.models.ExperienceReference,
    clonedExperience: _root_.scala.Option[io.flow.experience.v0.models.ExperienceReference] = None,
    status: io.flow.experience.v0.models.ExperienceCloneStatus
  )

  /**
   * Form for cloning an experience
   * 
   * @param name Name for the new cloned experience. Will be auto generated if not provided
   */
  final case class ExperienceCloneForm(
    name: _root_.scala.Option[String] = None
  )

  final case class ExperienceConfigurationReference(
    id: String
  )

  final case class ExperienceCurrencyFormat(
    symbol: io.flow.common.v0.models.CurrencySymbolFormat,
    labelFormatters: Seq[io.flow.common.v0.models.CurrencyLabelFormatter]
  )

  final case class ExperienceCurrencyFormatForm(
    symbol: io.flow.common.v0.models.CurrencySymbolFormat,
    labelFormatters: Seq[io.flow.common.v0.models.CurrencyLabelFormatter]
  )

  /**
   * Defines a set of defaults for a given organization and region
   * 
   * @param key Default key - guaranteed to be unique
   * @param name Default name for the experience - guaranteed to be unique
   */
  final case class ExperienceDefaults(
    key: String,
    name: String,
    deliveredDuty: io.flow.common.v0.models.DeliveredDuty,
    country: String,
    currency: String,
    language: String,
    measurementSystem: io.flow.common.v0.models.MeasurementSystem
  )

  /**
   * Experiences define a local experience for a given geographic region
   * 
   * @param regionId The actual geographic area to which this experience is targeted. Value is the
   *        region Id as defined in https://api.flow.io/reference/regions - To create a
   *        'default' experience, set region_id to 'world'
   * @param name Name for the experience
   * @param deliveredDuty Determines if a given experience should be DDP, DDU, or customer choice. If DDP,
   *        note that in some cases if a customer is shipping to a country where DDP is not
   *        available, information may still come back as DDU. If not provided, Flow will
   *        set a base default based on the country
   * @param country When otherwise not known, the default country to use for this experience. One
   *        example would be an experience setup for Europe - when you request landed cost,
   *        if there is no geolocation information available, we will use this country as
   *        the basis for landed cost. ISO 3166 3 currency code as defined in
   *        https://api.flow.io/reference/countries
   * @param currency The default currency for this experience which will define the currency of the
   *        pricing for this experience as well as the default currency displayed when no
   *        other information is available. Value is an ISO 4217 3 currency code as defined
   *        in https://api.flow.io/reference/currencies
   * @param language The default language in which to display information for this experience, when
   *        no other information is present. Value is an ISO 639 2 language code as defined
   *        in https://api.flow.io/reference/languages
   * @param key The key to use for this experience. If not provided, we will generate a unique
   *        key based on the experience name.
   * @param subcatalogId The Id of the subcatalog that will define the specific list of products to offer
   *        in this experience. If not specified, a new subcatalog will be created.
   */
  final case class ExperienceForm(
    regionId: String,
    name: String,
    deliveredDuty: _root_.scala.Option[io.flow.common.v0.models.DeliveredDuty] = None,
    country: _root_.scala.Option[String] = None,
    currency: _root_.scala.Option[String] = None,
    language: _root_.scala.Option[String] = None,
    key: _root_.scala.Option[String] = None,
    measurementSystem: _root_.scala.Option[io.flow.common.v0.models.MeasurementSystem] = None,
    subcatalogId: _root_.scala.Option[String] = None
  )

  /**
   * Experience Geo summarizes an experience along with geographic info
   * 
   * @param region Reference to region as defined in https://api.flow.io/reference/regions
   * @param country ISO 3166 3 currency code as defined in https://api.flow.io/reference/countries
   * @param currency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   * @param language ISO 639 2 language code as defined in https://api.flow.io/reference/languages
   */
  final case class ExperienceGeo(
    key: String,
    name: String,
    region: io.flow.experience.v0.models.RegionReference,
    country: String,
    currency: String,
    language: String,
    measurementSystem: io.flow.common.v0.models.MeasurementSystem
  )

  final case class ExperienceLogisticsSettings(
    id: String,
    experience: io.flow.experience.v0.models.ExperienceOverview,
    shippingConfiguration: io.flow.fulfillment.v0.models.ShippingConfigurationReference
  )

  /**
   * Assigns logistics related settings to an experience
   */
  final case class ExperienceLogisticsSettingsPutForm(
    shippingConfigurationKey: String
  )

  final case class ExperienceLogisticsSummary(
    outbound: _root_.scala.Option[io.flow.experience.v0.models.ExperienceLogisticsTierSummary] = None,
    `return`: _root_.scala.Option[io.flow.experience.v0.models.ExperienceLogisticsTierSummary] = None
  )

  final case class ExperienceLogisticsTierSummary(
    prices: io.flow.experience.v0.models.ExperienceLogisticsTierSummaryPrices
  )

  /**
   * @param minimum Across all the tiers for this experience, returns the minimum tier shipping
   *        price.
   */
  final case class ExperienceLogisticsTierSummaryPrices(
    minimum: io.flow.common.v0.models.Price
  )

  final case class ExperienceOverview(
    id: String,
    key: String
  )

  /**
   * @param paymentMethodId The id of a payment method.
   * @param tags A collection of active tags for this payment such as whether it is to be
   *        displayed at checkout.
   */
  final case class ExperiencePaymentMethodRuleForm(
    paymentMethodId: String,
    tags: Seq[io.flow.experience.v0.models.ExperiencePaymentMethodTag]
  )

  /**
   * @param position Position of this experience price book mapping. Lower position indicates
   *        experience price book mapping should be considered first.
   */
  final case class ExperiencePriceBookMapping(
    id: String,
    experience: io.flow.experience.v0.models.ExperienceReference,
    priceBook: io.flow.price.v0.models.PriceBookReference,
    position: Long
  )

  /**
   * @param position Position of this experience price book mapping. Lower position indicates
   *        experience price book mapping should be considered first.
   */
  final case class ExperiencePriceBookMappingForm(
    priceBookKey: String,
    position: _root_.scala.Option[Long] = None
  )

  final case class ExperiencePriceBookMappingPutForm(
    priceBooks: Seq[io.flow.experience.v0.models.ExperiencePriceBookMappingForm]
  )

  final case class ExperienceReference(
    key: String
  ) extends ExpandableExperience

  /**
   * @param deliveredDuty Wrapper for settings for delivered duties. This includes the default for the
   *        experience and the choices available for a customer to pick.
   * @param pricingSettings Wrapper for settings for pricing. This includes the defaults for the experience
   *        and whether they are editable.
   * @param logisticsSettings Wrapper for settings for logistics. This includes the shipping configuration key
   *        used by the experience.
   * @param checkoutSettings Wrapper for settings for Checkout UI.
   */
  final case class ExperienceSettings(
    deliveredDuty: io.flow.experience.v0.models.DeliveredDutySetting,
    pricingSettings: _root_.scala.Option[io.flow.experience.v0.models.PricingSettings] = None,
    logisticsSettings: _root_.scala.Option[io.flow.experience.v0.models.LogisticsSettings] = None,
    checkoutSettings: _root_.scala.Option[io.flow.experience.v0.models.CheckoutSettings] = None
  )

  /**
   * The experience status form is used to update the status of a particular
   * experience.
   */
  final case class ExperienceStatusForm(
    status: io.flow.experience.v0.models.ExperienceStatus
  )

  final case class ExperienceVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    experience: io.flow.experience.v0.models.Experience
  )

  /**
   * @param trigger Trigger used to calculate eligibility for free shipping, showing information
   *        necessary.
   * @param max Maximum value for this promotion. For example, a free shipping promo may be
   *        setup with a max of 10 CAD meaning we will apply free shipping up to a maximum
   *        value of 10 CAD
   */
  final case class FreeShipping(
    trigger: io.flow.experience.v0.models.PromotionTrigger,
    max: _root_.scala.Option[io.flow.common.v0.models.Price] = None
  ) extends Promotion

  /**
   * @param trigger Trigger used to calculate eligibility for free shipping, showing information
   *        necessary.
   * @param max Maximum value for this promotion. For example, a free shipping promo may be
   *        setup with a max of 10 CAD meaning we will apply free shipping up to a maximum
   *        value of 10 CAD
   * @param attributes A set of key/value pairs
   */
  final case class FreeShippingOrderPromotion(
    id: String,
    order: io.flow.experience.v0.models.ExpandableOrder,
    key: String,
    trigger: io.flow.experience.v0.models.OrderPromotionTrigger,
    max: _root_.scala.Option[io.flow.common.v0.models.Price] = None,
    attributes: Map[String, String]
  ) extends OrderPromotion

  /**
   * @param trigger Trigger used to calculate eligibility for free shipping, showing information
   *        necessary.
   * @param max Maximum value for this promotion. For example, a free shipping promo may be
   *        setup with a max of 10 CAD meaning we will apply free shipping up to a maximum
   *        value of 10 CAD.
   * @param attributes A set of key/value pairs
   */
  final case class FreeShippingOrderPromotionForm(
    trigger: io.flow.experience.v0.models.PromotionTriggerForm,
    max: _root_.scala.Option[io.flow.common.v0.models.PriceForm] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  ) extends OrderPromotionForm

  final case class InstallmentPlanPaymentError(
    code: io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode,
    messages: Seq[String],
    codes: Seq[io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode]
  )

  /**
   * The installment payment form is used to create an installment plan for an order,
   * associating the plan immediately with this order.
   * 
   * @param authorizationKey The key of the initial payment authorization for this plan
   */
  final case class InstallmentPlanPaymentForm(
    installmentProgramId: String,
    authorizationKey: String
  )

  /**
   * @param initial The initial authorization amount for this program
   */
  final case class InstallmentProgramSummary(
    id: String,
    name: String,
    initial: io.flow.common.v0.models.Price
  )

  /**
   * Defines a fixed and percent margin to apply to items matching a query.
   * 
   * @param q The query used to select items to which the margins are applied.
   * @param fixed A fixed amount to add to an item in the base currency, e.g 1.25.
   * @param percent A percent of the base cost to add, e.g. 2.25 would indicate 2.25%.
   */
  final case class ItemMargin(
    id: String,
    key: String,
    name: String,
    q: String,
    fixed: BigDecimal,
    percent: BigDecimal,
    position: Long
  )

  /**
   * A percent and/or fixed margin to apply to items based on query.
   * 
   * @param fixed A fixed amount to add to an item in the base currency, e.g 1.25.
   * @param percent A percent of the base cost to add, e.g. 2.25 would indicate 2.25%.
   * @param position Defaults to end of list
   */
  final case class ItemMarginPostForm(
    name: String,
    q: String,
    key: _root_.scala.Option[String] = None,
    fixed: _root_.scala.Option[BigDecimal] = None,
    percent: _root_.scala.Option[BigDecimal] = None,
    position: _root_.scala.Option[Long] = None
  )

  /**
   * A percent and/or fixed margin to apply to items based on query.
   * 
   * @param fixed A fixed amount to add to an item in the base currency, e.g 1.25.
   * @param percent A percent of the base cost to add, e.g. 2.25 would indicate 2.25%.
   * @param position Defaults to end of list
   */
  final case class ItemMarginPutForm(
    name: String,
    q: String,
    fixed: _root_.scala.Option[BigDecimal] = None,
    percent: _root_.scala.Option[BigDecimal] = None,
    position: _root_.scala.Option[Long] = None
  )

  final case class ItemMarginVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    itemMargin: io.flow.experience.v0.models.ItemMargin
  )

  /**
   * Provides display data for a line item.
   */
  final case class Line(
    itemNumber: String,
    quantity: Long,
    price: io.flow.common.v0.models.PriceWithBase,
    total: io.flow.common.v0.models.PriceWithBase,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * Line items on the order, with localized pricing information
   * 
   * @param name The item name associated to the number (e.g. Long Sleeve Dress).
   * @param center Optional center key associated with this item. Used for orders and quotes to
   *        specify where to ship an item from. If not specified, Flow will infer based on
   *        inventory setup.
   * @param price The price of this item for this order. If not specified, we will use the item
   *        price from the experience
   * @param discount The total discount, if any, to apply to this line item. Note that the discount
   *        is the total discount to apply regardless of the quantity.
   * @param discounts Discounts, if any, to apply to this line item. Note that the discounts apply to
   *        the total, regardless of the quantity.
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   * @param shipmentEstimate For items that may not immediately ship out from the origin because of different
   *        models of inventory (e.g. drop-ship, sell-first), this is a way for a client to
   *        communicate when the items can ship out. This will be used to calculate delivery
   *        option windows.
   * @param priceSource Indicates the source of the item price.
   */
  final case class LocalizedLineItem(
    number: String,
    name: String,
    quantity: Long,
    center: _root_.scala.Option[String] = None,
    price: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    discount: _root_.scala.Option[io.flow.experience.v0.models.LocalizedLineItemDiscount] = None,
    discounts: _root_.scala.Option[Seq[io.flow.experience.v0.models.LocalizedLineItemDiscount]] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    local: io.flow.catalog.v0.models.Local,
    shipmentEstimate: _root_.scala.Option[io.flow.common.v0.models.DatetimeRange] = None,
    priceSource: _root_.scala.Option[io.flow.common.v0.models.PriceSource] = None
  )

  /**
   * Represents the requested, base, and localized amounts for a discount on a given
   * line item. It applies to the entire line regardless of quantity.
   * 
   * @param amount The amount of the discount after being converted to the local currency.
   * @param currency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   * @param label The formatted label of the localized discount.
   * @param base The discount converted to the base currency in which your organization operates.
   * @param requested The requested discount amount.
   * @param discountLabel The discount pretty label (e.g. SPRING10) that is displayed to the customer.
   */
  final case class LocalizedLineItemDiscount(
    amount: Double,
    currency: String,
    label: _root_.scala.Option[String] = None,
    base: _root_.scala.Option[io.flow.common.v0.models.Price] = None,
    requested: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    discountLabel: _root_.scala.Option[String] = None
  )

  final case class LogisticsSettings(
    shippingConfiguration: io.flow.fulfillment.v0.models.ShippingConfigurationReference
  )

  /**
   * An order represents all of the information about a particular set of line items,
   * including pricing, currency rates, delivery options, etc. All information in an
   * order is guaranteed by Flow - if an order is submitted before its expiration.
   * The intended use case is to create an order as a consumer enters checkout, then
   * to submit that order as part of the user submitting their order. Note that Flow
   * will automatically mark an order submitted if we see payment authorization(s)
   * covering the full balance of an order.
   * 
   * @param merchantOfRecord Once an order is fully paid, we record who the merchant of record for this order
   *        is.
   * @param experience Contains information on the experience on which this order was submitted.
   * @param customer The customer who is actually making the purchase
   * @param deliveredDuty Options returned will only use tiers with the matching delivered duty. This
   *        would also affect whether duties are included in the total or not. If not
   *        specified, defaults based on the experience default setting.
   * @param expiresAt The date and time on which this order will expire unless submitted. Used only
   *        when the order status is 'open'. New orders will expire 1 hour after creation.
   * @param selections The currently selected delivery option ids. These IDs represent the shipping
   *        tiers that the customer has chosen (e.g. standard or express) for each delivery.
   *        The shipping price is then based on these selections (and included in the prices
   *        array). You can update an order before it has been submitted to change the
   *        delivery options, getting back accurate pricing for the order.
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   * @param submittedAt The timestamp on which the order is submitted. Once submitted, production orders
   *        can no longer be deleted as they represent transactions in the real world
   * @param lines Provides display data for each of the line items belonging to this order.
   * @param identifiers Other identifiers which are used to identify this order, if available.
   * @param promotions The current available and applied promotions for this order
   * @param payments Represents the list of payments on an order. Each payment will be typed -
   *        supporting options like a $25 account credit applied to an order plus a balance
   *        paid by a card, paypal, cash on delivery, etc. The list of payments here is
   *        summary information only for display back to the user; each individual payment
   *        will have varying levels of detail based on the actual type of the payment
   * @param balance The remaining balance on this order. Will be marked required in a future version
   *        of the Flow API
   * @param rules Represents a summary of the rules related to this order.
   * @param taxRegistration Represents the tax registration on an order, if applicable.
   * @param geo If present, provides the geo ip related information for this order
   */
  final case class Order(
    id: String,
    number: String,
    merchantOfRecord: _root_.scala.Option[io.flow.common.v0.models.OrderMerchantOfRecord] = None,
    experience: _root_.scala.Option[io.flow.experience.v0.models.ExpandableExperience] = None,
    customer: io.flow.common.v0.models.OrderCustomer,
    deliveredDuty: io.flow.common.v0.models.DeliveredDuty,
    destination: io.flow.experience.v0.models.OrderAddress,
    expiresAt: _root_.org.joda.time.DateTime,
    items: Seq[io.flow.experience.v0.models.LocalizedLineItem],
    deliveries: Seq[io.flow.fulfillment.v0.models.Delivery],
    selections: Seq[String],
    prices: Seq[io.flow.experience.v0.models.OrderPriceDetail],
    total: io.flow.catalog.v0.models.LocalizedTotal,
    attributes: Map[String, String],
    submittedAt: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    lines: _root_.scala.Option[Seq[io.flow.experience.v0.models.Line]] = None,
    identifiers: _root_.scala.Option[Seq[String]] = None,
    promotions: _root_.scala.Option[io.flow.experience.v0.models.Promotions] = None,
    payments: _root_.scala.Option[Seq[io.flow.experience.v0.models.OrderPayment]] = None,
    balance: _root_.scala.Option[io.flow.catalog.v0.models.LocalizedTotal] = None,
    rules: _root_.scala.Option[io.flow.experience.v0.models.OrderRulesSummary] = None,
    taxRegistration: _root_.scala.Option[io.flow.harmonization.v0.models.TaxRegistration] = None,
    geo: _root_.scala.Option[io.flow.experience.v0.models.OrderGeo] = None
  ) extends ExpandableOrder

  /**
   * @param text Full text version of address
   * @param streets Array for street line 1, street line 2, etc., in order
   * @param country The ISO 3166-3 country code. Case insensitive. See
   *        https://api.flow.io/reference/countries
   * @param contact Contact information of entity at the address
   */
  final case class OrderAddress(
    text: _root_.scala.Option[String] = None,
    streets: _root_.scala.Option[Seq[String]] = None,
    city: _root_.scala.Option[String] = None,
    province: _root_.scala.Option[String] = None,
    postal: _root_.scala.Option[String] = None,
    country: _root_.scala.Option[String] = None,
    latitude: _root_.scala.Option[String] = None,
    longitude: _root_.scala.Option[String] = None,
    contact: _root_.scala.Option[io.flow.common.v0.models.Contact] = None
  )

  /**
   * The Order Builder model is used to incrementally build up an order until it is
   * complete and can be submitted.
   * 
   * @param order The order in its current state. Will always be present unless there is a global
   *        error (e.g. no experience defined) that makes it impossible to create an order
   * @param errors A list of order errors that must be resolved prior to submitted the order. If
   *        there are no errors in the model, than the order can be submitted.
   */
  final case class OrderBuilder(
    order: _root_.scala.Option[io.flow.experience.v0.models.Order] = None,
    errors: _root_.scala.Option[Seq[io.flow.experience.v0.models.OrderError]] = None
  )

  final case class OrderBuilderAttributesForm(
    attributes: Map[String, String]
  )

  final case class OrderBuilderCustomerInvoiceAddressForm(
    address: io.flow.common.v0.models.BillingAddress
  )

  final case class OrderBuilderDeliveredDutyForm(
    deliveredDuty: io.flow.common.v0.models.DeliveredDuty
  )

  /**
   * @param country The ISO 3166-3 country code. Case insensitive. See
   *        https://api.flow.io/reference/countries
   */
  final case class OrderBuilderDestinationCountryForm(
    country: String
  )

  final case class OrderBuilderDestinationForm(
    destination: io.flow.experience.v0.models.OrderAddress
  )

  /**
   * Purpose-built form specifically for only address-related changes to destination
   * on an order
   */
  final case class OrderDestinationPutForm(
    destination: io.flow.experience.v0.models.OrderAddress
  )

  /**
   * @param messages A summary of the errors
   * @param numbers A list of all of the item numbers that are not available
   * @param destinationCountry Destination country of the order, if available.
   * @param threshold When the order error is value_threshold_exceeded, we include the details on the
   *        threshold itself.
   */
  final case class OrderError(
    code: io.flow.experience.v0.models.OrderErrorCode,
    messages: Seq[String],
    numbers: _root_.scala.Option[Seq[String]] = None,
    destinationCountry: _root_.scala.Option[io.flow.reference.v0.models.Country] = None,
    threshold: _root_.scala.Option[io.flow.experience.v0.models.ValueThresholdExceededDetails] = None
  )

  /**
   * Lightweight estimate for a group of items without any customer-related
   * information. This will contain available estimates on shipping, taxes, and
   * duties.
   * 
   * @param selections The currently selected delivery option ids. These IDs represent the shipping
   *        tiers that the customer has chosen (e.g. standard or express) for each delivery.
   *        The shipping price is then based on these selections (and included in the prices
   *        array). You can update an order before it has been submitted to change the
   *        delivery options, getting back accurate pricing for the order.
   * @param lines Provides display data for each of the line items belonging to this order
   *        estimate.
   * @param promotions The current available and applied promotions for this order
   */
  @deprecated("Estimates are deprecated. Please use orders with optional destination")
  final case class OrderEstimate(
    id: String,
    items: Seq[io.flow.experience.v0.models.LocalizedLineItem],
    destination: io.flow.experience.v0.models.OrderAddress,
    deliveries: Seq[io.flow.fulfillment.v0.models.Delivery],
    prices: Seq[io.flow.experience.v0.models.OrderPriceDetail],
    selections: Seq[String],
    total: io.flow.catalog.v0.models.LocalizedTotal,
    lines: _root_.scala.Option[Seq[io.flow.experience.v0.models.Line]] = None,
    promotions: _root_.scala.Option[io.flow.experience.v0.models.Promotions] = None
  )

  /**
   * Form to get a lightweight estimate of an order.
   * 
   * @param selections Selected list of delivery options for this quote. The original order will
   *        contain one or more deliveries. Each delivery will contain one or more shipping
   *        options (e.g. standard or express). We need to know which shipping options the
   *        user selected in order to provide accurate, local shipping pricing. You should
   *        only specify if you are explicitly changing the delivery options
   */
  @deprecated("Estimates are deprecated. Please use orders with optional destination")
  final case class OrderEstimateForm(
    items: Seq[io.flow.common.v0.models.LineItemForm],
    destination: _root_.scala.Option[io.flow.experience.v0.models.OrderAddress] = None,
    selections: _root_.scala.Option[Seq[String]] = None
  )

  /**
   * The order form is used to create an open order, providing the details on pricing
   * and delivery options for destination and items/quantities specified
   * 
   * @param customer The customer who actually is making the purchase. We recommend providing as much
   *        information as you have, notably email address which can be used to increase
   *        acceptance rates if Flow is processing payment for this order. If you can also
   *        provide your customer number - we can link multiple orders for each customer in
   *        the Flow console.
   * @param deliveredDuty Options returned will only use tiers with the matching delivered duty. This
   *        would also affect whether duties are included in the total or not. If not
   *        specified, defaults based on the experience default setting.
   * @param number If not provided, will default to the generated unique order identifier.
   * @param discount An optional discount to apply to the entire order
   * @param discounts Optional discount(s) to apply to the entire order.
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   * @param authorizationKeys Sets the authorization keys to associate with this order. Each authorization, if
   *        valid, will then be added to the order.payments field.
   */
  final case class OrderForm(
    customer: _root_.scala.Option[io.flow.common.v0.models.OrderCustomerForm] = None,
    items: Seq[io.flow.common.v0.models.LineItemForm],
    deliveredDuty: _root_.scala.Option[io.flow.common.v0.models.DeliveredDuty] = None,
    number: _root_.scala.Option[String] = None,
    destination: _root_.scala.Option[io.flow.experience.v0.models.OrderAddress] = None,
    discount: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    discounts: _root_.scala.Option[io.flow.common.v0.models.DiscountsForm] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    authorizationKeys: _root_.scala.Option[Seq[String]] = None
  )

  /**
   * The geolocated information for an order
   * 
   * @param country ISO 3166 3 currency code as defined in https://api.flow.io/reference/countries
   * @param currency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   * @param language ISO 639 2 language code as defined in https://api.flow.io/reference/languages
   */
  final case class OrderGeo(
    ip: _root_.scala.Option[String] = None,
    country: String,
    currency: _root_.scala.Option[String] = None,
    language: _root_.scala.Option[String] = None
  )

  /**
   * Represents alternate identifiers that can be used to lookup an order. Common use
   * cases are to support attaching a primary identifier (e.g. a nice order number)
   * post order submission or attaching IDs that are used by the warehouse to ship
   * the orders.
   * 
   * @param primary An order can optionally have a single additional primary identifier. Common
   *        pattern here is using a random UUID in checkout sessions, then later assigning a
   *        human readable order number.
   */
  final case class OrderIdentifier(
    id: String,
    order: io.flow.experience.v0.models.OrderReference,
    identifier: String,
    primary: Boolean,
    @deprecated("This field was renamed to 'identifier'") number: _root_.scala.Option[String] = None
  )

  /**
   * @param order The order number for which you are assigning this identifier
   * @param primary If you set this to true, creates the order identifier and marks it as primary.
   *        If there already exists a prior primary identifier, that identifier will be
   *        updated to no longer by the primary
   */
  final case class OrderIdentifierForm(
    order: String,
    identifier: _root_.scala.Option[String] = None,
    @deprecated("This field is deprecated. Please use the 'identifier' field") number: _root_.scala.Option[String] = None,
    primary: _root_.scala.Option[Boolean] = None
  )

  /**
   * @param order The order number for which you are assigning this identifier
   * @param primary If you set this to true, creates the order identifier and marks it as primary.
   *        If there already exists a prior primary identifier, that identifier will be
   *        updated to no longer by the primary
   */
  final case class OrderIdentifierPutForm(
    order: String,
    primary: _root_.scala.Option[Boolean] = None
  )

  final case class OrderIdentifierVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    orderIdentifier: io.flow.experience.v0.models.OrderIdentifier
  )

  final case class OrderNumberGeneratorDefaults(
    startsWith: Long = 1001L,
    minHexLength: Int = 6,
    minStartsWith: Long = 1L
  )

  final case class OrderNumberGeneratorFixedLength(
    length: Int,
    padding: String
  )

  /**
   * Hexadecimal generator generates a random string, starting with a letter, of a
   * given length
   */
  final case class OrderNumberGeneratorHexadecimal(
    length: Int
  ) extends OrderNumberGenerator

  /**
   * Generator with an optional prefix, followed by an integer and an optional suffix
   * 
   * @param fixedLength Optionally force a fixed length with padding. For example, an order number of
   *        F1234 with fixed length '6' and padding '0' would become 'F01234'
   */
  final case class OrderNumberGeneratorPrefixSuffix(
    prefix: _root_.scala.Option[String] = None,
    startsWith: _root_.scala.Option[Long] = None,
    suffix: _root_.scala.Option[String] = None,
    fixedLength: _root_.scala.Option[io.flow.experience.v0.models.OrderNumberGeneratorFixedLength] = None
  ) extends OrderNumberGenerator

  /**
   * Generates an order number based on a UUID (no dashes or other formatting). This
   * is the default for Flow orders (with order number prefixed by ord-)
   * 
   * @param prefix Optional prefix to prepend to the UUID
   */
  final case class OrderNumberGeneratorUuid(
    prefix: String = "ord-"
  ) extends OrderNumberGenerator

  final case class OrderNumberReference(
    number: String
  )

  /**
   * An Order Payment represents an individual payment applied to an order. The type
   * of the payment can be used to further lookup transaction level detail
   * 
   * @param reference The reference identifier for the details behind this order payment. For example,
   *        if this payment was a card payment, the reference will be the unique
   *        authorization key.
   * @param description Human understandable description of this payment method
   * @param address Billing address associated with this payment
   * @param attributes Integration-specific attributes of this payment.
   */
  final case class OrderPayment(
    id: String,
    `type`: io.flow.experience.v0.models.OrderPaymentType,
    merchantOfRecord: io.flow.common.v0.models.MerchantOfRecord = io.flow.common.v0.models.MerchantOfRecord.Flow,
    reference: String,
    description: String,
    total: io.flow.common.v0.models.PriceWithBase,
    address: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None,
    date: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    attributes: Map[String, String] = Map.empty
  )

  /**
   * Represents a top-level order price detail, e.g. 'Subtotal' or 'VAT'.
   * 
   * @param key The key indicating what this price detail represents.
   * @param currency The ISO-4217 3 character currency code in which the amount is calculated.
   * @param amount The total cost of the price detail in the currency of the experience in which
   *        the order is placed.
   * @param label The formatted label for this price detail that should be displayed to the user.
   * @param base The amount of this price detail in the base currency of the organization.
   * @param components Contains the components of this price detail that are used to calculate the
   *        total.
   * @param name The display name for this order price detail.
   * @param rate Optional rate for this order price detail if the key relates to a VAT or Duty.
   * @param accuracy Used to flag prices that are estimated and why. Missing values will be
   *        considered calculated. An order may only be submitted if all price components
   *        are calculated.
   */
  final case class OrderPriceDetail(
    key: io.flow.experience.v0.models.OrderPriceDetailKey,
    currency: String,
    amount: BigDecimal,
    label: String,
    base: io.flow.common.v0.models.Price,
    components: Seq[io.flow.experience.v0.models.OrderPriceDetailComponent],
    name: _root_.scala.Option[String] = None,
    rate: _root_.scala.Option[BigDecimal] = None,
    accuracy: io.flow.price.v0.models.PriceAccuracy = io.flow.price.v0.models.PriceAccuracy.Calculated
  )

  /**
   * @param currency The ISO-4217 3 character currency code in which the amount is calculated.
   * @param amount The total cost of the price detail component in the currency of the experience
   *        in which the order is placed.
   * @param base The amount of this price detail component in the base currency of the
   *        organization.
   * @param name The display name for this order price detail component.
   */
  final case class OrderPriceDetailComponent(
    key: io.flow.experience.v0.models.OrderPriceDetailComponentKey,
    currency: String,
    amount: BigDecimal,
    label: String,
    base: io.flow.common.v0.models.Price,
    name: _root_.scala.Option[String] = None
  )

  /**
   * @param min Minimum amount to be eligible for the trigger
   */
  final case class OrderPromotionTrigger(
    `type`: io.flow.experience.v0.models.PromotionTriggerType,
    min: _root_.scala.Option[io.flow.common.v0.models.Price] = None
  )

  /**
   * The order put form is used to upsert an order, providing the details on pricing
   * and delivery options for destination and items/quantities specified.
   * 
   * @param customer The customer who actually is making the purchase. We recommend providing as much
   *        information as you have, notably email address which can be used to increase
   *        acceptance rates if Flow is processing payment for this order. If you can also
   *        provide your customer number - we can link multiple orders for each customer in
   *        the Flow console.
   * @param deliveredDuty Options returned will only use tiers with the matching delivered duty. This
   *        would also affect whether duties are included in the total or not. If not
   *        specified, defaults based on the experience default setting.
   * @param selections Selected list of delivery options for this quote. The original order will
   *        contain one or more deliveries. Each delivery will contain one or more shipping
   *        options (e.g. standard or express). We need to know which shipping options the
   *        user selected in order to provide accurate, local shipping pricing. You should
   *        only specify if you are explicitly changing the delivery options
   * @param discount An optional discount to apply to the entire order
   * @param discounts Optional discount(s) to apply to the entire order.
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   * @param authorizationKeys Sets the authorization keys to associate with this order. Each authorization, if
   *        valid, will then be added to the order.payments field.
   */
  final case class OrderPutForm(
    items: Seq[io.flow.common.v0.models.LineItemForm],
    customer: _root_.scala.Option[io.flow.common.v0.models.OrderCustomerForm] = None,
    deliveredDuty: _root_.scala.Option[io.flow.common.v0.models.DeliveredDuty] = None,
    selections: _root_.scala.Option[Seq[String]] = None,
    destination: _root_.scala.Option[io.flow.experience.v0.models.OrderAddress] = None,
    discount: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    discounts: _root_.scala.Option[io.flow.common.v0.models.DiscountsForm] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    authorizationKeys: _root_.scala.Option[Seq[String]] = None
  )

  final case class OrderReference(
    id: String,
    number: String
  ) extends ExpandableOrder

  final case class OrderRuleReference(
    id: String,
    key: String
  )

  final case class OrderRulesSummary(
    applied: Seq[io.flow.experience.v0.models.OrderRuleReference]
  )

  final case class OrderVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    order: io.flow.experience.v0.models.Order
  )

  /**
   * Model representing original and max values and currencies.
   */
  final case class OriginalPrices(
    value: io.flow.common.v0.models.Price,
    max: io.flow.common.v0.models.Price
  )

  final case class PaymentMethodIssuer(
    id: String,
    name: String
  )

  /**
   * @param tags A collection of active tags for this payment such as whether it is denied for an
   *        organization or to be displayed at checkout.
   * @param paymentMethod The payment method associated with this rule.
   * @param displayPosition The order in which payment methods will be displayed. Lower numbers will have
   *        priority.
   * @param content Contains content necessary to render the given payment method, such as
   *        instructions that explain how to pay.
   * @param issuers Certain payment methods, such as iDEAL, require the customer to select an
   *        issuing bank before they are redirected to submit payment details. If any
   *        issuers are present in this field, the customer must select one which will then
   *        be included in the call to get the redirect URL.
   * @param programs A list of available installment plans, if any, that can optionally be applied to
   *        this payment method
   */
  final case class PaymentMethodRule(
    tags: Seq[io.flow.experience.v0.models.PaymentMethodTag],
    paymentMethod: io.flow.reference.v0.models.PaymentMethod,
    displayPosition: Int,
    content: _root_.scala.Option[Seq[io.flow.experience.v0.models.PaymentMethodRuleContent]] = None,
    issuers: _root_.scala.Option[Seq[io.flow.experience.v0.models.PaymentMethodIssuer]] = None,
    programs: Seq[io.flow.experience.v0.models.InstallmentProgramSummary]
  )

  /**
   * @param key The key identifying the value of this content.
   * @param value The value of this content.
   */
  final case class PaymentMethodRuleContent(
    key: io.flow.experience.v0.models.PaymentMethodRuleContentKey,
    value: String
  )

  /**
   * @param editable Indicates whether the pricing display settings may be edited.
   * @param defaultTaxDisplay Default tax display setting.
   * @param defaultDutyDisplay Default duty display setting.
   */
  final case class PricingSettings(
    editable: Boolean,
    defaultTaxDisplay: io.flow.price.v0.models.PricingLevySetting,
    defaultDutyDisplay: io.flow.price.v0.models.PricingLevySetting
  )

  /**
   * @param min Minimum amount to be eligible for the trigger
   * @param remaining Remaining value necessary to apply the trigger
   */
  final case class PromotionTrigger(
    `type`: io.flow.experience.v0.models.PromotionTriggerType,
    min: io.flow.common.v0.models.Price,
    remaining: io.flow.common.v0.models.Price
  )

  /**
   * @param min Minimum amount to be eligible for the trigger
   */
  final case class PromotionTriggerForm(
    `type`: io.flow.experience.v0.models.PromotionTriggerType,
    min: _root_.scala.Option[io.flow.common.v0.models.PriceForm] = None
  )

  /**
   * @param applied List of promotions that have been applied to this order. For example, free
   *        shipping promotion is applied to the shipping price.
   * @param available List of available promotions that are applicable for this order. If a promotion
   *        is here, the promo is not yet applied to the order, but the order can become
   *        eligible for it given some criteria.
   */
  final case class Promotions(
    applied: Seq[io.flow.experience.v0.models.Promotion],
    available: Seq[io.flow.experience.v0.models.Promotion]
  )

  final case class RegionReference(
    id: String
  )

  /**
   * @param local The actual limit in the local currency of the order
   * @param original The actual limit in the original currency in which the rule was defined. For
   *        example, Canada may restrict exports over CA$2000 - this value would be set to
   *        2000
   */
  final case class ValueThresholdExceededDetails(
    local: io.flow.common.v0.models.Price,
    original: io.flow.common.v0.models.Price
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AllocationComponent, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class AllocationComponentUndefinedType(
    description: String
  ) extends AllocationComponent

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AllocationDetail, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class AllocationDetailUndefinedType(
    description: String
  ) extends AllocationDetail

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableExperience, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class ExpandableExperienceUndefinedType(
    description: String
  ) extends ExpandableExperience

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableOrder, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class ExpandableOrderUndefinedType(
    description: String
  ) extends ExpandableOrder

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union OrderNumberGenerator, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class OrderNumberGeneratorUndefinedType(
    description: String
  ) extends OrderNumberGenerator

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union OrderPromotion, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class OrderPromotionUndefinedType(
    description: String
  ) extends OrderPromotion

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union OrderPromotionForm, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class OrderPromotionFormUndefinedType(
    description: String
  ) extends OrderPromotionForm

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union PaymentMethodTag, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class PaymentMethodTagUndefinedType(
    description: String
  ) extends PaymentMethodTag

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Promotion, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class PromotionUndefinedType(
    description: String
  ) extends Promotion

  sealed trait CreditPaymentErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object CreditPaymentErrorCode {

    case object GenericError extends CreditPaymentErrorCode { override def toString = "generic_error" }
    /**
     * Indicates the specified order does not exist
     */
    case object InvalidOrderNumber extends CreditPaymentErrorCode { override def toString = "invalid_order_number" }
    /**
     * Indicates that the specified currency code is not valid
     */
    case object InvalidCurrency extends CreditPaymentErrorCode { override def toString = "invalid_currency" }
    /**
     * Indicates that the description is invalid (must be non-empty)
     */
    case object InvalidDescription extends CreditPaymentErrorCode { override def toString = "invalid_description" }
    /**
     * Indicates that a credit payment with the specified key already exists
     */
    case object Duplicate extends CreditPaymentErrorCode { override def toString = "duplicate" }
    /**
     * Indicates the provided credit amount was <= 0
     */
    case object AmountMustBePositive extends CreditPaymentErrorCode { override def toString = "amount_must_be_positive" }
    /**
     * Indicates the provided credit amount exceeds the remaining balance on the order
     */
    case object AmountExceedsBalance extends CreditPaymentErrorCode { override def toString = "amount_exceeds_balance" }
    /**
     * Indicates the provided credit amount exceeds the maximum amount of applicable
     * credit
     */
    case object InsufficientAmount extends CreditPaymentErrorCode { override def toString = "insufficient_amount" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CreditPaymentErrorCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CreditPaymentErrorCode] = scala.List(GenericError, InvalidOrderNumber, InvalidCurrency, InvalidDescription, Duplicate, AmountMustBePositive, AmountExceedsBalance, InsufficientAmount)

    private[this]
    val byName: Map[String, CreditPaymentErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CreditPaymentErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CreditPaymentErrorCode] = byName.get(value.toLowerCase)

  }

  sealed trait DeliveredDutyDisplayType extends _root_.scala.Product with _root_.scala.Serializable

  object DeliveredDutyDisplayType {

    /**
     * Displays all available options to the customer.
     */
    case object All extends DeliveredDutyDisplayType { override def toString = "all" }
    /**
     * Displays a single option (either DDU or DDP), while the other can be displayed
     * by changing duties and tax preferences at checkout.
     */
    case object Single extends DeliveredDutyDisplayType { override def toString = "single" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends DeliveredDutyDisplayType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[DeliveredDutyDisplayType] = scala.List(All, Single)

    private[this]
    val byName: Map[String, DeliveredDutyDisplayType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DeliveredDutyDisplayType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DeliveredDutyDisplayType] = byName.get(value.toLowerCase)

  }

  sealed trait ExperienceCloneStatus extends _root_.scala.Product with _root_.scala.Serializable

  object ExperienceCloneStatus {

    case object Pending extends ExperienceCloneStatus { override def toString = "pending" }
    case object Updating extends ExperienceCloneStatus { override def toString = "updating" }
    case object Completed extends ExperienceCloneStatus { override def toString = "completed" }
    case object Failed extends ExperienceCloneStatus { override def toString = "failed" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ExperienceCloneStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ExperienceCloneStatus] = scala.List(Pending, Updating, Completed, Failed)

    private[this]
    val byName: Map[String, ExperienceCloneStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExperienceCloneStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExperienceCloneStatus] = byName.get(value.toLowerCase)

  }

  sealed trait ExperiencePaymentMethodTag extends PaymentMethodTag

  object ExperiencePaymentMethodTag {

    /**
     * A displayed payment method will be highlighted during the checkout process for
     * an experience.
     */
    case object Display extends ExperiencePaymentMethodTag { override def toString = "display" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ExperiencePaymentMethodTag

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ExperiencePaymentMethodTag] = scala.List(Display)

    private[this]
    val byName: Map[String, ExperiencePaymentMethodTag] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExperiencePaymentMethodTag = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExperiencePaymentMethodTag] = byName.get(value.toLowerCase)

  }

  sealed trait ExperienceStatus extends _root_.scala.Product with _root_.scala.Serializable

  object ExperienceStatus {

    case object Draft extends ExperienceStatus { override def toString = "draft" }
    case object Active extends ExperienceStatus { override def toString = "active" }
    /**
     * Archiving indicates an experience has been archived. We allow some time for
     * sessions to expire before fully marking the experience archived.
     */
    case object Archiving extends ExperienceStatus { override def toString = "archiving" }
    case object Archived extends ExperienceStatus { override def toString = "archived" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ExperienceStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ExperienceStatus] = scala.List(Draft, Active, Archiving, Archived)

    private[this]
    val byName: Map[String, ExperienceStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExperienceStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExperienceStatus] = byName.get(value.toLowerCase)

  }

  sealed trait InstallmentPlanPaymentErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object InstallmentPlanPaymentErrorCode {

    /**
     * Indicates the specified authorization key does not exist
     */
    case object InvalidAuthorization extends InstallmentPlanPaymentErrorCode { override def toString = "invalid_authorization" }
    /**
     * Indicates the specified authorization amount does not match the first
     * installment in the plan
     */
    case object InvalidAuthorizationAmount extends InstallmentPlanPaymentErrorCode { override def toString = "invalid_authorization_amount" }
    /**
     * Indicates the specified installment plan does not exist
     */
    case object InvalidInstallmentPlan extends InstallmentPlanPaymentErrorCode { override def toString = "invalid_installment_plan" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends InstallmentPlanPaymentErrorCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[InstallmentPlanPaymentErrorCode] = scala.List(InvalidAuthorization, InvalidAuthorizationAmount, InvalidInstallmentPlan)

    private[this]
    val byName: Map[String, InstallmentPlanPaymentErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): InstallmentPlanPaymentErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[InstallmentPlanPaymentErrorCode] = byName.get(value.toLowerCase)

  }

  sealed trait OrderErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object OrderErrorCode {

    case object GenericError extends OrderErrorCode { override def toString = "generic_error" }
    /**
     * When creating an order, if a particular item is not available in the country /
     * destination (either because it was restricted or excluded from that country), we
     * return this error code and list the specific item numbers which are not
     * available in the 'numbers' field.
     */
    case object OrderItemNotAvailable extends OrderErrorCode { override def toString = "order_item_not_available" }
    /**
     * Indicates that there is no order with the specified number (nor an order for
     * which an order identifier with that number has been created)
     */
    case object OrderIdentifierError extends OrderErrorCode { override def toString = "order_identifier_error" }
    /**
     * The authorization key specified is invalid - either because it does not exist or
     * is not associated with this order
     */
    case object AuthorizationInvalid extends OrderErrorCode { override def toString = "authorization_invalid" }
    /**
     * Indicates that an order was created for a country for one of your domicile
     * countries and you have asked Flow not to accept orders for this country.
     */
    case object DomesticShippingUnavailable extends OrderErrorCode { override def toString = "domestic_shipping_unavailable" }
    /**
     * Indicates that an order was created for a country to which you have asked Flow
     * not to ship.
     */
    case object ShippingUnavailable extends OrderErrorCode { override def toString = "shipping_unavailable" }
    /**
     * Indicates the order value exceeds the value threshold for destination and cannot
     * be shipped. When specified, the order will also populate the threshold
     * attribute.
     */
    case object ValueThresholdExceeded extends OrderErrorCode { override def toString = "value_threshold_exceeded" }
    /**
     * Indicates that the specified currency code is not valid
     */
    case object InvalidCurrency extends OrderErrorCode { override def toString = "invalid_currency" }
    /**
     * Indicates that the specified country code is not valid
     */
    case object InvalidCountry extends OrderErrorCode { override def toString = "invalid_country" }
    /**
     * Indicates that the specified region code is not valid
     */
    case object InvalidRegion extends OrderErrorCode { override def toString = "invalid_region" }
    /**
     * Indicates that the specified language code is not valid
     */
    case object InvalidLanguage extends OrderErrorCode { override def toString = "invalid_language" }
    /**
     * Indicates that one or more ordered items is marked as out-of-stock or otherwise
     * cannot be reserved. We will list the specific out-of-stock items in the numbers
     * field
     */
    case object ItemOutOfStock extends OrderErrorCode { override def toString = "item_out_of_stock" }
    /**
     * Indicates a failure to charge a gift card. Error message will indicate when
     * retries are possible.
     */
    case object GiftCardNotAccepted extends OrderErrorCode { override def toString = "gift_card_not_accepted" }
    /**
     * Indicates that the order total has changed, likely due to pricebook update or
     * rate change. This is not an error but the consumer should be shown the new price
     * before continuing checkout.
     */
    case object TotalChanged extends OrderErrorCode { override def toString = "total_changed" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrderErrorCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderErrorCode] = scala.List(GenericError, OrderItemNotAvailable, OrderIdentifierError, AuthorizationInvalid, DomesticShippingUnavailable, ShippingUnavailable, ValueThresholdExceeded, InvalidCurrency, InvalidCountry, InvalidRegion, InvalidLanguage, ItemOutOfStock, GiftCardNotAccepted, TotalChanged)

    private[this]
    val byName: Map[String, OrderErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderErrorCode] = byName.get(value.toLowerCase)

  }

  /**
   * The order payment type identified the different ways a consumer may have paid
   * for an order. The primary purpose is in displaying summary level payment
   * information to the user; the type can then be used to know how to request
   * additional details for each payment.
   */
  sealed trait OrderPaymentType extends _root_.scala.Product with _root_.scala.Serializable

  object OrderPaymentType {

    /**
     * Represents a payment in the form of a credit or debit card
     */
    case object Card extends OrderPaymentType { override def toString = "card" }
    /**
     * Represents an online payment (e.g. paypal, alipay, etc)
     */
    case object Online extends OrderPaymentType { override def toString = "online" }
    /**
     * A payment in the form of a credit of some type (e.g. a store credit, gift card)
     * applied to an order
     */
    case object Credit extends OrderPaymentType { override def toString = "credit" }
    /**
     * An installment plan payment represents that the user has elected an installment
     * plan to pay for this order. For the purposes of the order, the balance will
     * reflect fully paid for the total value of the installment plan, even though
     * individual installments may be created in the future.
     */
    case object InstallmentPlan extends OrderPaymentType { override def toString = "installment_plan" }
    /**
     * Request to pay the balance with cash on delivery. Offered only when the final
     * mile carriers support cash on delivery.
     */
    case object CashOnDelivery extends OrderPaymentType { override def toString = "cash_on_delivery" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrderPaymentType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderPaymentType] = scala.List(Card, Online, Credit, InstallmentPlan, CashOnDelivery)

    private[this]
    val byName: Map[String, OrderPaymentType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderPaymentType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderPaymentType] = byName.get(value.toLowerCase)

  }

  sealed trait OrderPriceDetailComponentKey extends _root_.scala.Product with _root_.scala.Serializable

  object OrderPriceDetailComponentKey {

    /**
     * A general purpose adjustment applied to the order.
     */
    case object Adjustment extends OrderPriceDetailComponentKey { override def toString = "adjustment" }
    /**
     * An adjustment based on whether the VAT de minimis applies to the order.
     */
    case object VatDeminimis extends OrderPriceDetailComponentKey { override def toString = "vat_deminimis" }
    /**
     * An adjustment based on whether the duty de minimis applies to the order.
     */
    case object DutyDeminimis extends OrderPriceDetailComponentKey { override def toString = "duty_deminimis" }
    /**
     * The duty owed on the price of the order's items, including any added margins and
     * rounding.
     */
    case object DutiesItemPrice extends OrderPriceDetailComponentKey { override def toString = "duties_item_price" }
    /**
     * The duty owed on the freight cost of the order.
     */
    case object DutiesFreight extends OrderPriceDetailComponentKey { override def toString = "duties_freight" }
    /**
     * The duty owed on the insurance cost of the order.
     */
    case object DutiesInsurance extends OrderPriceDetailComponentKey { override def toString = "duties_insurance" }
    /**
     * The VAT owed on the price of the order's items, including any added margins and
     * rounding.
     */
    case object VatItemPrice extends OrderPriceDetailComponentKey { override def toString = "vat_item_price" }
    /**
     * The VAT owed on the freight cost of the order.
     */
    case object VatFreight extends OrderPriceDetailComponentKey { override def toString = "vat_freight" }
    /**
     * The VAT owed on the insurance cost of the order.
     */
    case object VatInsurance extends OrderPriceDetailComponentKey { override def toString = "vat_insurance" }
    /**
     * The VAT owed on the duties on the price of the order's items, including any
     * added margins and rounding.
     */
    case object VatDutiesItemPrice extends OrderPriceDetailComponentKey { override def toString = "vat_duties_item_price" }
    /**
     * The VAT owed on the duties on the freight cost of the order.
     */
    case object VatDutiesFreight extends OrderPriceDetailComponentKey { override def toString = "vat_duties_freight" }
    /**
     * The VAT owed on the duties on the insurance cost of the order.
     */
    case object VatDutiesInsurance extends OrderPriceDetailComponentKey { override def toString = "vat_duties_insurance" }
    /**
     * The sum of the price of the order's items with their currency margins, percent
     * margins, and fixed margins included.
     */
    case object ItemPrice extends OrderPriceDetailComponentKey { override def toString = "item_price" }
    /**
     * The sum of all discounts applied to the order's items.
     */
    case object ItemDiscount extends OrderPriceDetailComponentKey { override def toString = "item_discount" }
    /**
     * The sum of any rounding applied to the order's items.
     */
    case object Rounding extends OrderPriceDetailComponentKey { override def toString = "rounding" }
    /**
     * The insurance cost for the order.
     */
    case object Insurance extends OrderPriceDetailComponentKey { override def toString = "insurance" }
    /**
     * The shipping cost for the order.
     */
    case object Shipping extends OrderPriceDetailComponentKey { override def toString = "shipping" }
    /**
     * A discount applied to the entire order.
     */
    case object OrderDiscount extends OrderPriceDetailComponentKey { override def toString = "order_discount" }
    /**
     * The sum of adjustments to item price, margin and rounding made due to percentage
     * sales margins.
     */
    case object SubtotalPercentSalesMargin extends OrderPriceDetailComponentKey { override def toString = "subtotal_percent_sales_margin" }
    /**
     * The sum of adjustments to VAT owed made due to percentage sales margins.
     */
    case object SubtotalVatPercentSalesMargin extends OrderPriceDetailComponentKey { override def toString = "subtotal_vat_percent_sales_margin" }
    /**
     * The sum of adjustments to duty owed made due to percentage sales margins.
     */
    case object SubtotalDutyPercentSalesMargin extends OrderPriceDetailComponentKey { override def toString = "subtotal_duty_percent_sales_margin" }
    /**
     * An offset to account for any VAT subsidized by the organization. For example, if
     * VAT is included in an item price and changes at the order level (due to passing
     * de minimis threshold, or the destination having a more specific VAT rate), the
     * difference will be represented here.
     */
    case object VatSubsidy extends OrderPriceDetailComponentKey { override def toString = "vat_subsidy" }
    /**
     * An offset to account for any duty subsidized by the organization. For example,
     * if duty is included in an item price and changes at the order level (due to
     * passing de minimis threshold, or the destination having a more specific duty
     * rate), the difference will be represented here.
     */
    case object DutySubsidy extends OrderPriceDetailComponentKey { override def toString = "duty_subsidy" }
    /**
     * Surcharge applied to a shipment for delivery to a remote area determined by the
     * carrier.
     */
    case object RemoteAreaSurcharge extends OrderPriceDetailComponentKey { override def toString = "remote_area_surcharge" }
    /**
     * Surcharge applied to a shipment for fuel consumption by the carrier.
     */
    case object FuelSurcharge extends OrderPriceDetailComponentKey { override def toString = "fuel_surcharge" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrderPriceDetailComponentKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderPriceDetailComponentKey] = scala.List(Adjustment, VatDeminimis, DutyDeminimis, DutiesItemPrice, DutiesFreight, DutiesInsurance, VatItemPrice, VatFreight, VatInsurance, VatDutiesItemPrice, VatDutiesFreight, VatDutiesInsurance, ItemPrice, ItemDiscount, Rounding, Insurance, Shipping, OrderDiscount, SubtotalPercentSalesMargin, SubtotalVatPercentSalesMargin, SubtotalDutyPercentSalesMargin, VatSubsidy, DutySubsidy, RemoteAreaSurcharge, FuelSurcharge)

    private[this]
    val byName: Map[String, OrderPriceDetailComponentKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderPriceDetailComponentKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderPriceDetailComponentKey] = byName.get(value.toLowerCase)

  }

  sealed trait OrderPriceDetailKey extends _root_.scala.Product with _root_.scala.Serializable

  object OrderPriceDetailKey {

    /**
     * The details of any adjustments made to the order.
     */
    case object Adjustment extends OrderPriceDetailKey { override def toString = "adjustment" }
    /**
     * The details of the subtotal for the order, including item prices, margins, and
     * rounding.
     */
    case object Subtotal extends OrderPriceDetailKey { override def toString = "subtotal" }
    /**
     * The details of any VAT owed on the order.
     */
    case object Vat extends OrderPriceDetailKey { override def toString = "vat" }
    /**
     * The details of any duties owed on the order.
     */
    case object Duty extends OrderPriceDetailKey { override def toString = "duty" }
    /**
     * The details of shipping costs for the order.
     */
    case object Shipping extends OrderPriceDetailKey { override def toString = "shipping" }
    /**
     * The details of insurance costs for the order.
     */
    case object Insurance extends OrderPriceDetailKey { override def toString = "insurance" }
    /**
     * The details of any discount applied to the order.
     */
    case object Discount extends OrderPriceDetailKey { override def toString = "discount" }
    /**
     * Additional fees and levies applied to the order
     */
    case object Surcharges extends OrderPriceDetailKey { override def toString = "surcharges" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrderPriceDetailKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderPriceDetailKey] = scala.List(Adjustment, Subtotal, Vat, Duty, Shipping, Insurance, Discount, Surcharges)

    private[this]
    val byName: Map[String, OrderPriceDetailKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderPriceDetailKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderPriceDetailKey] = byName.get(value.toLowerCase)

  }

  /**
   * Indicates an order's status
   */
  sealed trait OrderStatus extends _root_.scala.Product with _root_.scala.Serializable

  object OrderStatus {

    case object Open extends OrderStatus { override def toString = "open" }
    case object Submitted extends OrderStatus { override def toString = "submitted" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrderStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderStatus] = scala.List(Open, Submitted)

    private[this]
    val byName: Map[String, OrderStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderStatus] = byName.get(value.toLowerCase)

  }

  sealed trait OrganizationPaymentMethodTag extends PaymentMethodTag

  object OrganizationPaymentMethodTag {

    /**
     * A denied payment method cannot be used for an organization in any experience.
     */
    case object Deny extends OrganizationPaymentMethodTag { override def toString = "deny" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrganizationPaymentMethodTag

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrganizationPaymentMethodTag] = scala.List(Deny)

    private[this]
    val byName: Map[String, OrganizationPaymentMethodTag] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrganizationPaymentMethodTag = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrganizationPaymentMethodTag] = byName.get(value.toLowerCase)

  }

  /**
   * Indicates the intent of a given instance of payment method rule content.
   */
  sealed trait PaymentMethodRuleContentKey extends _root_.scala.Product with _root_.scala.Serializable

  object PaymentMethodRuleContentKey {

    case object Description extends PaymentMethodRuleContentKey { override def toString = "description" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends PaymentMethodRuleContentKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[PaymentMethodRuleContentKey] = scala.List(Description)

    private[this]
    val byName: Map[String, PaymentMethodRuleContentKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PaymentMethodRuleContentKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PaymentMethodRuleContentKey] = byName.get(value.toLowerCase)

  }

  /**
   * The Promotion Trigger Type defines the conditions we evaluate when deciding if a
   * particular promotion should be applied to an order.
   */
  sealed trait PromotionTriggerType extends _root_.scala.Product with _root_.scala.Serializable

  object PromotionTriggerType {

    /**
     * Automatic indicates the the promotion will be automatically applied to the order
     */
    case object Automatic extends PromotionTriggerType { override def toString = "automatic" }
    /**
     * Order subtotal sets a minimum value - orders whose subtotal is greater than the
     * minimum will have the promotion applied. A common use case is to offer free
     * shipping to orders about 150 CAD.
     */
    case object OrderSubtotal extends PromotionTriggerType { override def toString = "order_subtotal" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends PromotionTriggerType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[PromotionTriggerType] = scala.List(Automatic, OrderSubtotal)

    private[this]
    val byName: Map[String, PromotionTriggerType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PromotionTriggerType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PromotionTriggerType] = byName.get(value.toLowerCase)

  }

}

package io.flow.experience.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.catalog.v0.models.json._
    import io.flow.checkout.configuration.v0.models.json._
    import io.flow.common.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.experience.v0.models.json._
    import io.flow.field.validation.v0.models.json._
    import io.flow.fulfillment.v0.models.json._
    import io.flow.harmonization.v0.models.json._
    import io.flow.inventory.v0.models.json._
    import io.flow.payment.v0.models.json._
    import io.flow.permission.v0.models.json._
    import io.flow.price.v0.models.json._
    import io.flow.query.builder.v0.models.json._
    import io.flow.reference.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map { str =>
      _root_.java.util.UUID.fromString(str)
    }

    private[v0] implicit val jsonWritesUUID = new Writes[_root_.java.util.UUID] {
      def writes(x: _root_.java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[_root_.org.joda.time.DateTime] {
      def writes(x: _root_.org.joda.time.DateTime) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x))
      }
    }

    private[v0] implicit val jsonReadsJodaLocalDate = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDate = new Writes[_root_.org.joda.time.LocalDate] {
      def writes(x: _root_.org.joda.time.LocalDate) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.date.print(x))
      }
    }

    implicit val jsonReadsExperienceCreditPaymentErrorCode = new play.api.libs.json.Reads[io.flow.experience.v0.models.CreditPaymentErrorCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.CreditPaymentErrorCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.CreditPaymentErrorCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.CreditPaymentErrorCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceCreditPaymentErrorCode(obj: io.flow.experience.v0.models.CreditPaymentErrorCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCreditPaymentErrorCode(obj: io.flow.experience.v0.models.CreditPaymentErrorCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceCreditPaymentErrorCode: play.api.libs.json.Writes[CreditPaymentErrorCode] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPaymentErrorCode] {
        def writes(obj: io.flow.experience.v0.models.CreditPaymentErrorCode) = {
          jsonWritesExperienceCreditPaymentErrorCode(obj)
        }
      }
    }

    implicit val jsonReadsExperienceDeliveredDutyDisplayType = new play.api.libs.json.Reads[io.flow.experience.v0.models.DeliveredDutyDisplayType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.DeliveredDutyDisplayType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.DeliveredDutyDisplayType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.DeliveredDutyDisplayType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceDeliveredDutyDisplayType(obj: io.flow.experience.v0.models.DeliveredDutyDisplayType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectDeliveredDutyDisplayType(obj: io.flow.experience.v0.models.DeliveredDutyDisplayType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceDeliveredDutyDisplayType: play.api.libs.json.Writes[DeliveredDutyDisplayType] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.DeliveredDutyDisplayType] {
        def writes(obj: io.flow.experience.v0.models.DeliveredDutyDisplayType) = {
          jsonWritesExperienceDeliveredDutyDisplayType(obj)
        }
      }
    }

    implicit val jsonReadsExperienceExperienceCloneStatus = new play.api.libs.json.Reads[io.flow.experience.v0.models.ExperienceCloneStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.ExperienceCloneStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperienceCloneStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperienceCloneStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceExperienceCloneStatus(obj: io.flow.experience.v0.models.ExperienceCloneStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectExperienceCloneStatus(obj: io.flow.experience.v0.models.ExperienceCloneStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceExperienceCloneStatus: play.api.libs.json.Writes[ExperienceCloneStatus] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceCloneStatus] {
        def writes(obj: io.flow.experience.v0.models.ExperienceCloneStatus) = {
          jsonWritesExperienceExperienceCloneStatus(obj)
        }
      }
    }

    implicit val jsonReadsExperienceExperiencePaymentMethodTag = new play.api.libs.json.Reads[io.flow.experience.v0.models.ExperiencePaymentMethodTag] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.ExperiencePaymentMethodTag] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperiencePaymentMethodTag(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperiencePaymentMethodTag(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceExperiencePaymentMethodTag(obj: io.flow.experience.v0.models.ExperiencePaymentMethodTag) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectExperiencePaymentMethodTag(obj: io.flow.experience.v0.models.ExperiencePaymentMethodTag) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceExperiencePaymentMethodTag: play.api.libs.json.Writes[ExperiencePaymentMethodTag] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePaymentMethodTag] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePaymentMethodTag) = {
          jsonWritesExperienceExperiencePaymentMethodTag(obj)
        }
      }
    }

    implicit val jsonReadsExperienceExperienceStatus = new play.api.libs.json.Reads[io.flow.experience.v0.models.ExperienceStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.ExperienceStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperienceStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperienceStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceExperienceStatus(obj: io.flow.experience.v0.models.ExperienceStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectExperienceStatus(obj: io.flow.experience.v0.models.ExperienceStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceExperienceStatus: play.api.libs.json.Writes[ExperienceStatus] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceStatus] {
        def writes(obj: io.flow.experience.v0.models.ExperienceStatus) = {
          jsonWritesExperienceExperienceStatus(obj)
        }
      }
    }

    implicit val jsonReadsExperienceInstallmentPlanPaymentErrorCode = new play.api.libs.json.Reads[io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceInstallmentPlanPaymentErrorCode(obj: io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectInstallmentPlanPaymentErrorCode(obj: io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceInstallmentPlanPaymentErrorCode: play.api.libs.json.Writes[InstallmentPlanPaymentErrorCode] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode] {
        def writes(obj: io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode) = {
          jsonWritesExperienceInstallmentPlanPaymentErrorCode(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderErrorCode = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderErrorCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderErrorCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderErrorCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderErrorCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderErrorCode(obj: io.flow.experience.v0.models.OrderErrorCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderErrorCode(obj: io.flow.experience.v0.models.OrderErrorCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderErrorCode: play.api.libs.json.Writes[OrderErrorCode] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderErrorCode] {
        def writes(obj: io.flow.experience.v0.models.OrderErrorCode) = {
          jsonWritesExperienceOrderErrorCode(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderPaymentType = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderPaymentType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderPaymentType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPaymentType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPaymentType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderPaymentType(obj: io.flow.experience.v0.models.OrderPaymentType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderPaymentType(obj: io.flow.experience.v0.models.OrderPaymentType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderPaymentType: play.api.libs.json.Writes[OrderPaymentType] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPaymentType] {
        def writes(obj: io.flow.experience.v0.models.OrderPaymentType) = {
          jsonWritesExperienceOrderPaymentType(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderPriceDetailComponentKey = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderPriceDetailComponentKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderPriceDetailComponentKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPriceDetailComponentKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPriceDetailComponentKey(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderPriceDetailComponentKey(obj: io.flow.experience.v0.models.OrderPriceDetailComponentKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderPriceDetailComponentKey(obj: io.flow.experience.v0.models.OrderPriceDetailComponentKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderPriceDetailComponentKey: play.api.libs.json.Writes[OrderPriceDetailComponentKey] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPriceDetailComponentKey] {
        def writes(obj: io.flow.experience.v0.models.OrderPriceDetailComponentKey) = {
          jsonWritesExperienceOrderPriceDetailComponentKey(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderPriceDetailKey = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderPriceDetailKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderPriceDetailKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPriceDetailKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPriceDetailKey(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderPriceDetailKey(obj: io.flow.experience.v0.models.OrderPriceDetailKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderPriceDetailKey(obj: io.flow.experience.v0.models.OrderPriceDetailKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderPriceDetailKey: play.api.libs.json.Writes[OrderPriceDetailKey] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPriceDetailKey] {
        def writes(obj: io.flow.experience.v0.models.OrderPriceDetailKey) = {
          jsonWritesExperienceOrderPriceDetailKey(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderStatus = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderStatus(obj: io.flow.experience.v0.models.OrderStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderStatus(obj: io.flow.experience.v0.models.OrderStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderStatus: play.api.libs.json.Writes[OrderStatus] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderStatus] {
        def writes(obj: io.flow.experience.v0.models.OrderStatus) = {
          jsonWritesExperienceOrderStatus(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrganizationPaymentMethodTag = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrganizationPaymentMethodTag] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrganizationPaymentMethodTag] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrganizationPaymentMethodTag(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrganizationPaymentMethodTag(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrganizationPaymentMethodTag(obj: io.flow.experience.v0.models.OrganizationPaymentMethodTag) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrganizationPaymentMethodTag(obj: io.flow.experience.v0.models.OrganizationPaymentMethodTag) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrganizationPaymentMethodTag: play.api.libs.json.Writes[OrganizationPaymentMethodTag] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrganizationPaymentMethodTag] {
        def writes(obj: io.flow.experience.v0.models.OrganizationPaymentMethodTag) = {
          jsonWritesExperienceOrganizationPaymentMethodTag(obj)
        }
      }
    }

    implicit val jsonReadsExperiencePaymentMethodRuleContentKey = new play.api.libs.json.Reads[io.flow.experience.v0.models.PaymentMethodRuleContentKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.PaymentMethodRuleContentKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PaymentMethodRuleContentKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PaymentMethodRuleContentKey(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperiencePaymentMethodRuleContentKey(obj: io.flow.experience.v0.models.PaymentMethodRuleContentKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPaymentMethodRuleContentKey(obj: io.flow.experience.v0.models.PaymentMethodRuleContentKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperiencePaymentMethodRuleContentKey: play.api.libs.json.Writes[PaymentMethodRuleContentKey] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PaymentMethodRuleContentKey] {
        def writes(obj: io.flow.experience.v0.models.PaymentMethodRuleContentKey) = {
          jsonWritesExperiencePaymentMethodRuleContentKey(obj)
        }
      }
    }

    implicit val jsonReadsExperiencePromotionTriggerType = new play.api.libs.json.Reads[io.flow.experience.v0.models.PromotionTriggerType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.PromotionTriggerType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PromotionTriggerType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PromotionTriggerType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperiencePromotionTriggerType(obj: io.flow.experience.v0.models.PromotionTriggerType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPromotionTriggerType(obj: io.flow.experience.v0.models.PromotionTriggerType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperiencePromotionTriggerType: play.api.libs.json.Writes[PromotionTriggerType] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PromotionTriggerType] {
        def writes(obj: io.flow.experience.v0.models.PromotionTriggerType) = {
          jsonWritesExperiencePromotionTriggerType(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAddressConfiguration: play.api.libs.json.Reads[AddressConfiguration] = {
      for {
        country <- (__ \ "country").read[String]
        fieldValidation <- (__ \ "field_validation").read[io.flow.experience.v0.models.AddressFieldValidation]
        provinces <- (__ \ "provinces").read[Seq[io.flow.reference.v0.models.Province]]
      } yield AddressConfiguration(country, fieldValidation, provinces)
    }

    def jsObjectAddressConfiguration(obj: io.flow.experience.v0.models.AddressConfiguration): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "country" -> play.api.libs.json.JsString(obj.country),
        "field_validation" -> jsObjectAddressFieldValidation(obj.fieldValidation),
        "provinces" -> play.api.libs.json.Json.toJson(obj.provinces)
      )
    }

    implicit def jsonWritesExperienceAddressConfiguration: play.api.libs.json.Writes[AddressConfiguration] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AddressConfiguration] {
        def writes(obj: io.flow.experience.v0.models.AddressConfiguration) = {
          jsObjectAddressConfiguration(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAddressFieldValidation: play.api.libs.json.Reads[AddressFieldValidation] = {
      for {
        firstName <- (__ \ "first_name").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
        lastName <- (__ \ "last_name").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
        street1 <- (__ \ "street_1").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
        street2 <- (__ \ "street_2").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
        city <- (__ \ "city").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
        province <- (__ \ "province").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
        postal <- (__ \ "postal").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
        phone <- (__ \ "phone").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
      } yield AddressFieldValidation(firstName, lastName, street1, street2, city, province, postal, phone)
    }

    def jsObjectAddressFieldValidation(obj: io.flow.experience.v0.models.AddressFieldValidation): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "first_name" -> play.api.libs.json.Json.toJson(obj.firstName),
        "last_name" -> play.api.libs.json.Json.toJson(obj.lastName),
        "street_1" -> play.api.libs.json.Json.toJson(obj.street1),
        "street_2" -> play.api.libs.json.Json.toJson(obj.street2),
        "city" -> play.api.libs.json.Json.toJson(obj.city),
        "province" -> play.api.libs.json.Json.toJson(obj.province),
        "postal" -> play.api.libs.json.Json.toJson(obj.postal),
        "phone" -> play.api.libs.json.Json.toJson(obj.phone)
      )
    }

    implicit def jsonWritesExperienceAddressFieldValidation: play.api.libs.json.Writes[AddressFieldValidation] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AddressFieldValidation] {
        def writes(obj: io.flow.experience.v0.models.AddressFieldValidation) = {
          jsObjectAddressFieldValidation(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocation: play.api.libs.json.Reads[Allocation] = {
      for {
        order <- (__ \ "order").read[io.flow.experience.v0.models.AllocationOrderSummary]
        details <- (__ \ "details").read[Seq[io.flow.experience.v0.models.AllocationDetail]]
      } yield Allocation(order, details)
    }

    def jsObjectAllocation(obj: io.flow.experience.v0.models.Allocation): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order" -> jsObjectAllocationOrderSummary(obj.order),
        "details" -> play.api.libs.json.Json.toJson(obj.details)
      )
    }

    implicit def jsonWritesExperienceAllocation: play.api.libs.json.Writes[Allocation] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Allocation] {
        def writes(obj: io.flow.experience.v0.models.Allocation) = {
          jsObjectAllocation(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationDetailComponent: play.api.libs.json.Reads[AllocationDetailComponent] = {
      for {
        key <- (__ \ "key").read[io.flow.experience.v0.models.OrderPriceDetailComponentKey]
        total <- (__ \ "total").read[io.flow.common.v0.models.PriceWithBase]
        price <- (__ \ "price").readNullable[io.flow.common.v0.models.PriceWithBase]
      } yield AllocationDetailComponent(key, total, price)
    }

    def jsObjectAllocationDetailComponent(obj: io.flow.experience.v0.models.AllocationDetailComponent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total)
      ) ++ (obj.price match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(x))
      })
    }

    implicit def jsonReadsExperienceAllocationLevyComponent: play.api.libs.json.Reads[AllocationLevyComponent] = {
      for {
        key <- (__ \ "key").read[io.flow.experience.v0.models.OrderPriceDetailComponentKey]
        total <- (__ \ "total").read[io.flow.common.v0.models.PriceWithBase]
        rate <- (__ \ "rate").read[BigDecimal]
        name <- (__ \ "name").read[String]
        price <- (__ \ "price").readNullable[io.flow.common.v0.models.PriceWithBase]
        accuracy <- (__ \ "accuracy").readWithDefault[io.flow.price.v0.models.PriceAccuracy](io.flow.price.v0.models.PriceAccuracy.Calculated)
        basis <- (__ \ "basis").readNullable[io.flow.common.v0.models.MoneyWithBase]
      } yield AllocationLevyComponent(key, total, rate, name, price, accuracy, basis)
    }

    def jsObjectAllocationLevyComponent(obj: io.flow.experience.v0.models.AllocationLevyComponent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total),
        "rate" -> play.api.libs.json.JsNumber(obj.rate),
        "name" -> play.api.libs.json.JsString(obj.name),
        "accuracy" -> play.api.libs.json.JsString(obj.accuracy.toString)
      ) ++ (obj.price match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(x))
      }) ++
      (obj.basis match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("basis" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(x))
      })
    }

    implicit def jsonReadsExperienceAllocationLineDetail: play.api.libs.json.Reads[AllocationLineDetail] = {
      for {
        number <- (__ \ "number").read[String]
        quantity <- (__ \ "quantity").read[Long]
        key <- (__ \ "key").read[io.flow.experience.v0.models.OrderPriceDetailKey]
        price <- (__ \ "price").read[io.flow.common.v0.models.PriceWithBase]
        total <- (__ \ "total").read[io.flow.common.v0.models.PriceWithBase]
        included <- (__ \ "included").read[Seq[io.flow.experience.v0.models.AllocationComponent]]
        notIncluded <- (__ \ "not_included").read[Seq[io.flow.experience.v0.models.AllocationComponent]]
      } yield AllocationLineDetail(number, quantity, key, price, total, included, notIncluded)
    }

    def jsObjectAllocationLineDetail(obj: io.flow.experience.v0.models.AllocationLineDetail): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "price" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.price),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total),
        "included" -> play.api.libs.json.Json.toJson(obj.included),
        "not_included" -> play.api.libs.json.Json.toJson(obj.notIncluded)
      )
    }

    implicit def jsonReadsExperienceAllocationOrderDetail: play.api.libs.json.Reads[AllocationOrderDetail] = {
      for {
        key <- (__ \ "key").read[io.flow.experience.v0.models.OrderPriceDetailKey]
        total <- (__ \ "total").read[io.flow.common.v0.models.PriceWithBase]
        included <- (__ \ "included").read[Seq[io.flow.experience.v0.models.AllocationComponent]]
        notIncluded <- (__ \ "not_included").read[Seq[io.flow.experience.v0.models.AllocationComponent]]
      } yield AllocationOrderDetail(key, total, included, notIncluded)
    }

    def jsObjectAllocationOrderDetail(obj: io.flow.experience.v0.models.AllocationOrderDetail): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total),
        "included" -> play.api.libs.json.Json.toJson(obj.included),
        "not_included" -> play.api.libs.json.Json.toJson(obj.notIncluded)
      )
    }

    implicit def jsonReadsExperienceAllocationOrderSummary: play.api.libs.json.Reads[AllocationOrderSummary] = {
      for {
        id <- (__ \ "id").read[String]
        number <- (__ \ "number").read[String]
        submittedAt <- (__ \ "submitted_at").readNullable[_root_.org.joda.time.DateTime]
      } yield AllocationOrderSummary(id, number, submittedAt)
    }

    def jsObjectAllocationOrderSummary(obj: io.flow.experience.v0.models.AllocationOrderSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number)
      ) ++ (obj.submittedAt match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("submitted_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      })
    }

    implicit def jsonWritesExperienceAllocationOrderSummary: play.api.libs.json.Writes[AllocationOrderSummary] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationOrderSummary] {
        def writes(obj: io.flow.experience.v0.models.AllocationOrderSummary) = {
          jsObjectAllocationOrderSummary(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationV2: play.api.libs.json.Reads[AllocationV2] = {
      for {
        id <- (__ \ "id").read[String]
        order <- (__ \ "order").read[io.flow.experience.v0.models.AllocationOrderSummary]
        details <- (__ \ "details").read[Seq[io.flow.experience.v0.models.AllocationDetail]]
        total <- (__ \ "total").read[io.flow.catalog.v0.models.LocalizedTotal]
      } yield AllocationV2(id, order, details, total)
    }

    def jsObjectAllocationV2(obj: io.flow.experience.v0.models.AllocationV2): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "order" -> jsObjectAllocationOrderSummary(obj.order),
        "details" -> play.api.libs.json.Json.toJson(obj.details),
        "total" -> io.flow.catalog.v0.models.json.jsObjectLocalizedTotal(obj.total)
      )
    }

    implicit def jsonWritesExperienceAllocationV2: play.api.libs.json.Writes[AllocationV2] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationV2] {
        def writes(obj: io.flow.experience.v0.models.AllocationV2) = {
          jsObjectAllocationV2(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAvailablePromotion: play.api.libs.json.Reads[AvailablePromotion] = {
      for {
        id <- (__ \ "id").read[String]
        shippingConfiguration <- (__ \ "shipping_configuration").read[io.flow.fulfillment.v0.models.ShippingConfigurationReference]
        region <- (__ \ "region").read[io.flow.experience.v0.models.RegionReference]
        promotions <- (__ \ "promotions").read[Seq[io.flow.experience.v0.models.Promotion]]
      } yield AvailablePromotion(id, shippingConfiguration, region, promotions)
    }

    def jsObjectAvailablePromotion(obj: io.flow.experience.v0.models.AvailablePromotion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "shipping_configuration" -> io.flow.fulfillment.v0.models.json.jsObjectShippingConfigurationReference(obj.shippingConfiguration),
        "region" -> jsObjectRegionReference(obj.region),
        "promotions" -> play.api.libs.json.Json.toJson(obj.promotions)
      )
    }

    implicit def jsonWritesExperienceAvailablePromotion: play.api.libs.json.Writes[AvailablePromotion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AvailablePromotion] {
        def writes(obj: io.flow.experience.v0.models.AvailablePromotion) = {
          jsObjectAvailablePromotion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCheckoutAttribute: play.api.libs.json.Reads[CheckoutAttribute] = {
      for {
        id <- (__ \ "id").read[String]
        experience <- (__ \ "experience").read[io.flow.experience.v0.models.ExperienceReference]
        key <- (__ \ "key").read[String]
        attributeKeys <- (__ \ "attribute_keys").read[Seq[String]]
        position <- (__ \ "position").read[Long]
      } yield CheckoutAttribute(id, experience, key, attributeKeys, position)
    }

    def jsObjectCheckoutAttribute(obj: io.flow.experience.v0.models.CheckoutAttribute): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "experience" -> jsObjectExperienceReference(obj.experience),
        "key" -> play.api.libs.json.JsString(obj.key),
        "attribute_keys" -> play.api.libs.json.Json.toJson(obj.attributeKeys),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      )
    }

    implicit def jsonWritesExperienceCheckoutAttribute: play.api.libs.json.Writes[CheckoutAttribute] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CheckoutAttribute] {
        def writes(obj: io.flow.experience.v0.models.CheckoutAttribute) = {
          jsObjectCheckoutAttribute(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCheckoutAttributeForm: play.api.libs.json.Reads[CheckoutAttributeForm] = {
      for {
        key <- (__ \ "key").read[String]
        experienceKey <- (__ \ "experience_key").read[String]
        attributeKeys <- (__ \ "attribute_keys").read[Seq[String]]
        position <- (__ \ "position").readNullable[Long]
      } yield CheckoutAttributeForm(key, experienceKey, attributeKeys, position)
    }

    def jsObjectCheckoutAttributeForm(obj: io.flow.experience.v0.models.CheckoutAttributeForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "experience_key" -> play.api.libs.json.JsString(obj.experienceKey),
        "attribute_keys" -> play.api.libs.json.Json.toJson(obj.attributeKeys)
      ) ++ (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesExperienceCheckoutAttributeForm: play.api.libs.json.Writes[CheckoutAttributeForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CheckoutAttributeForm] {
        def writes(obj: io.flow.experience.v0.models.CheckoutAttributeForm) = {
          jsObjectCheckoutAttributeForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCheckoutItemContent: play.api.libs.json.Reads[CheckoutItemContent] = {
      for {
        item <- (__ \ "item").read[io.flow.catalog.v0.models.Item]
        name <- (__ \ "name").read[String]
        description <- (__ \ "description").readNullable[String]
        attributes <- (__ \ "attributes").read[Seq[io.flow.experience.v0.models.CheckoutItemContentAttribute]]
        image <- (__ \ "image").readNullable[io.flow.catalog.v0.models.Image]
      } yield CheckoutItemContent(item, name, description, attributes, image)
    }

    def jsObjectCheckoutItemContent(obj: io.flow.experience.v0.models.CheckoutItemContent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "item" -> io.flow.catalog.v0.models.json.jsObjectItem(obj.item),
        "name" -> play.api.libs.json.JsString(obj.name),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.image match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("image" -> io.flow.catalog.v0.models.json.jsObjectImage(x))
      })
    }

    implicit def jsonWritesExperienceCheckoutItemContent: play.api.libs.json.Writes[CheckoutItemContent] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CheckoutItemContent] {
        def writes(obj: io.flow.experience.v0.models.CheckoutItemContent) = {
          jsObjectCheckoutItemContent(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCheckoutItemContentAttribute: play.api.libs.json.Reads[CheckoutItemContentAttribute] = {
      for {
        key <- (__ \ "key").read[String]
        value <- (__ \ "value").read[String]
      } yield CheckoutItemContentAttribute(key, value)
    }

    def jsObjectCheckoutItemContentAttribute(obj: io.flow.experience.v0.models.CheckoutItemContentAttribute): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "value" -> play.api.libs.json.JsString(obj.value)
      )
    }

    implicit def jsonWritesExperienceCheckoutItemContentAttribute: play.api.libs.json.Writes[CheckoutItemContentAttribute] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CheckoutItemContentAttribute] {
        def writes(obj: io.flow.experience.v0.models.CheckoutItemContentAttribute) = {
          jsObjectCheckoutItemContentAttribute(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCheckoutSettings: play.api.libs.json.Reads[CheckoutSettings] = {
      (__ \ "configuration").read[io.flow.experience.v0.models.ExperienceConfigurationReference].map { x => new CheckoutSettings(configuration = x) }
    }

    def jsObjectCheckoutSettings(obj: io.flow.experience.v0.models.CheckoutSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "configuration" -> jsObjectExperienceConfigurationReference(obj.configuration)
      )
    }

    implicit def jsonWritesExperienceCheckoutSettings: play.api.libs.json.Writes[CheckoutSettings] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CheckoutSettings] {
        def writes(obj: io.flow.experience.v0.models.CheckoutSettings) = {
          jsObjectCheckoutSettings(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCreditPayment: play.api.libs.json.Reads[CreditPayment] = {
      for {
        id <- (__ \ "id").read[String]
        order <- (__ \ "order").read[io.flow.experience.v0.models.ExpandableOrder]
        key <- (__ \ "key").read[String]
        description <- (__ \ "description").read[String]
        value <- (__ \ "value").read[io.flow.common.v0.models.PriceWithBase]
        original <- (__ \ "original").read[io.flow.experience.v0.models.OriginalPrices]
        attributes <- (__ \ "attributes").read[Map[String, String]]
      } yield CreditPayment(id, order, key, description, value, original, attributes)
    }

    def jsObjectCreditPayment(obj: io.flow.experience.v0.models.CreditPayment): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "order" -> jsObjectExpandableOrder(obj.order),
        "key" -> play.api.libs.json.JsString(obj.key),
        "description" -> play.api.libs.json.JsString(obj.description),
        "value" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.value),
        "original" -> jsObjectOriginalPrices(obj.original),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      )
    }

    implicit def jsonWritesExperienceCreditPayment: play.api.libs.json.Writes[CreditPayment] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPayment] {
        def writes(obj: io.flow.experience.v0.models.CreditPayment) = {
          jsObjectCreditPayment(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCreditPaymentError: play.api.libs.json.Reads[CreditPaymentError] = {
      for {
        code <- (__ \ "code").read[io.flow.experience.v0.models.CreditPaymentErrorCode]
        messages <- (__ \ "messages").read[Seq[String]]
        codes <- (__ \ "codes").read[Seq[io.flow.experience.v0.models.CreditPaymentErrorCode]]
      } yield CreditPaymentError(code, messages, codes)
    }

    def jsObjectCreditPaymentError(obj: io.flow.experience.v0.models.CreditPaymentError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages),
        "codes" -> play.api.libs.json.Json.toJson(obj.codes)
      )
    }

    implicit def jsonWritesExperienceCreditPaymentError: play.api.libs.json.Writes[CreditPaymentError] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPaymentError] {
        def writes(obj: io.flow.experience.v0.models.CreditPaymentError) = {
          jsObjectCreditPaymentError(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCreditPaymentForm: play.api.libs.json.Reads[CreditPaymentForm] = {
      for {
        orderNumber <- (__ \ "order_number").read[String]
        description <- (__ \ "description").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        max <- (__ \ "max").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield CreditPaymentForm(orderNumber, description, amount, max, currency, attributes)
    }

    def jsObjectCreditPaymentForm(obj: io.flow.experience.v0.models.CreditPaymentForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber),
        "description" -> play.api.libs.json.JsString(obj.description),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "max" -> play.api.libs.json.JsNumber(obj.max),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceCreditPaymentForm: play.api.libs.json.Writes[CreditPaymentForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPaymentForm] {
        def writes(obj: io.flow.experience.v0.models.CreditPaymentForm) = {
          jsObjectCreditPaymentForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCreditPaymentVersion: play.api.libs.json.Reads[CreditPaymentVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        creditPayment <- (__ \ "credit_payment").read[io.flow.experience.v0.models.CreditPayment]
      } yield CreditPaymentVersion(id, timestamp, `type`, creditPayment)
    }

    def jsObjectCreditPaymentVersion(obj: io.flow.experience.v0.models.CreditPaymentVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "credit_payment" -> jsObjectCreditPayment(obj.creditPayment)
      )
    }

    implicit def jsonWritesExperienceCreditPaymentVersion: play.api.libs.json.Writes[CreditPaymentVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPaymentVersion] {
        def writes(obj: io.flow.experience.v0.models.CreditPaymentVersion) = {
          jsObjectCreditPaymentVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceDeliveredDutySetting: play.api.libs.json.Reads[DeliveredDutySetting] = {
      for {
        default <- (__ \ "default").read[io.flow.common.v0.models.DeliveredDuty]
        available <- (__ \ "available").read[Seq[io.flow.common.v0.models.DeliveredDuty]]
        display <- (__ \ "display").readNullable[io.flow.experience.v0.models.DeliveredDutyDisplayType]
      } yield DeliveredDutySetting(default, available, display)
    }

    def jsObjectDeliveredDutySetting(obj: io.flow.experience.v0.models.DeliveredDutySetting): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "default" -> play.api.libs.json.JsString(obj.default.toString),
        "available" -> play.api.libs.json.Json.toJson(obj.available)
      ) ++ (obj.display match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("display" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesExperienceDeliveredDutySetting: play.api.libs.json.Writes[DeliveredDutySetting] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.DeliveredDutySetting] {
        def writes(obj: io.flow.experience.v0.models.DeliveredDutySetting) = {
          jsObjectDeliveredDutySetting(obj)
        }
      }
    }

    implicit def jsonReadsExperienceDiscount: play.api.libs.json.Reads[Discount] = {
      for {
        id <- (__ \ "id").read[String]
        code <- (__ \ "code").readNullable[String]
        label <- (__ \ "label").read[String]
        price <- (__ \ "price").read[io.flow.common.v0.models.PriceWithBase]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield Discount(id, code, label, price, attributes)
    }

    def jsObjectDiscount(obj: io.flow.experience.v0.models.Discount): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "label" -> play.api.libs.json.JsString(obj.label),
        "price" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.price)
      ) ++ (obj.code match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("code" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonReadsExperienceExperience: play.api.libs.json.Reads[Experience] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        name <- (__ \ "name").read[String]
        deliveredDuty <- (__ \ "delivered_duty").read[io.flow.common.v0.models.DeliveredDuty]
        region <- (__ \ "region").read[io.flow.experience.v0.models.RegionReference]
        country <- (__ \ "country").read[String]
        currency <- (__ \ "currency").read[String]
        language <- (__ \ "language").read[String]
        measurementSystem <- (__ \ "measurement_system").read[io.flow.common.v0.models.MeasurementSystem]
        subcatalog <- (__ \ "subcatalog").read[io.flow.catalog.v0.models.SubcatalogReference]
        position <- (__ \ "position").read[Long]
        settings <- (__ \ "settings").read[io.flow.experience.v0.models.ExperienceSettings]
        status <- (__ \ "status").readNullable[io.flow.experience.v0.models.ExperienceStatus]
      } yield Experience(id, key, name, deliveredDuty, region, country, currency, language, measurementSystem, subcatalog, position, settings, status)
    }

    def jsObjectExperience(obj: io.flow.experience.v0.models.Experience): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "region" -> jsObjectRegionReference(obj.region),
        "country" -> play.api.libs.json.JsString(obj.country),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "language" -> play.api.libs.json.JsString(obj.language),
        "measurement_system" -> play.api.libs.json.JsString(obj.measurementSystem.toString),
        "subcatalog" -> io.flow.catalog.v0.models.json.jsObjectSubcatalogReference(obj.subcatalog),
        "position" -> play.api.libs.json.JsNumber(obj.position),
        "settings" -> jsObjectExperienceSettings(obj.settings)
      ) ++ (obj.status match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("status" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonReadsExperienceExperienceCheckoutSettings: play.api.libs.json.Reads[ExperienceCheckoutSettings] = {
      for {
        id <- (__ \ "id").read[String]
        experience <- (__ \ "experience").read[io.flow.experience.v0.models.ExperienceOverview]
        checkoutConfiguration <- (__ \ "checkout_configuration").read[io.flow.experience.v0.models.ExperienceConfigurationReference]
      } yield ExperienceCheckoutSettings(id, experience, checkoutConfiguration)
    }

    def jsObjectExperienceCheckoutSettings(obj: io.flow.experience.v0.models.ExperienceCheckoutSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "experience" -> jsObjectExperienceOverview(obj.experience),
        "checkout_configuration" -> jsObjectExperienceConfigurationReference(obj.checkoutConfiguration)
      )
    }

    implicit def jsonWritesExperienceExperienceCheckoutSettings: play.api.libs.json.Writes[ExperienceCheckoutSettings] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceCheckoutSettings] {
        def writes(obj: io.flow.experience.v0.models.ExperienceCheckoutSettings) = {
          jsObjectExperienceCheckoutSettings(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceCheckoutSettingsForm: play.api.libs.json.Reads[ExperienceCheckoutSettingsForm] = {
      (__ \ "checkout_configuration_id").read[String].map { x => new ExperienceCheckoutSettingsForm(checkoutConfigurationId = x) }
    }

    def jsObjectExperienceCheckoutSettingsForm(obj: io.flow.experience.v0.models.ExperienceCheckoutSettingsForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "checkout_configuration_id" -> play.api.libs.json.JsString(obj.checkoutConfigurationId)
      )
    }

    implicit def jsonWritesExperienceExperienceCheckoutSettingsForm: play.api.libs.json.Writes[ExperienceCheckoutSettingsForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceCheckoutSettingsForm] {
        def writes(obj: io.flow.experience.v0.models.ExperienceCheckoutSettingsForm) = {
          jsObjectExperienceCheckoutSettingsForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceClone: play.api.libs.json.Reads[ExperienceClone] = {
      for {
        id <- (__ \ "id").read[String]
        sourceExperience <- (__ \ "source_experience").read[io.flow.experience.v0.models.ExperienceReference]
        clonedExperience <- (__ \ "cloned_experience").readNullable[io.flow.experience.v0.models.ExperienceReference]
        status <- (__ \ "status").read[io.flow.experience.v0.models.ExperienceCloneStatus]
      } yield ExperienceClone(id, sourceExperience, clonedExperience, status)
    }

    def jsObjectExperienceClone(obj: io.flow.experience.v0.models.ExperienceClone): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "source_experience" -> jsObjectExperienceReference(obj.sourceExperience),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.clonedExperience match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cloned_experience" -> jsObjectExperienceReference(x))
      })
    }

    implicit def jsonWritesExperienceExperienceClone: play.api.libs.json.Writes[ExperienceClone] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceClone] {
        def writes(obj: io.flow.experience.v0.models.ExperienceClone) = {
          jsObjectExperienceClone(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceCloneForm: play.api.libs.json.Reads[ExperienceCloneForm] = {
      (__ \ "name").readNullable[String].map { x => new ExperienceCloneForm(name = x) }
    }

    def jsObjectExperienceCloneForm(obj: io.flow.experience.v0.models.ExperienceCloneForm): play.api.libs.json.JsObject = {
      (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceExperienceCloneForm: play.api.libs.json.Writes[ExperienceCloneForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceCloneForm] {
        def writes(obj: io.flow.experience.v0.models.ExperienceCloneForm) = {
          jsObjectExperienceCloneForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceConfigurationReference: play.api.libs.json.Reads[ExperienceConfigurationReference] = {
      (__ \ "id").read[String].map { x => new ExperienceConfigurationReference(id = x) }
    }

    def jsObjectExperienceConfigurationReference(obj: io.flow.experience.v0.models.ExperienceConfigurationReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesExperienceExperienceConfigurationReference: play.api.libs.json.Writes[ExperienceConfigurationReference] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceConfigurationReference] {
        def writes(obj: io.flow.experience.v0.models.ExperienceConfigurationReference) = {
          jsObjectExperienceConfigurationReference(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceCurrencyFormat: play.api.libs.json.Reads[ExperienceCurrencyFormat] = {
      for {
        symbol <- (__ \ "symbol").read[io.flow.common.v0.models.CurrencySymbolFormat]
        labelFormatters <- (__ \ "label_formatters").read[Seq[io.flow.common.v0.models.CurrencyLabelFormatter]]
      } yield ExperienceCurrencyFormat(symbol, labelFormatters)
    }

    def jsObjectExperienceCurrencyFormat(obj: io.flow.experience.v0.models.ExperienceCurrencyFormat): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "symbol" -> play.api.libs.json.JsString(obj.symbol.toString),
        "label_formatters" -> play.api.libs.json.Json.toJson(obj.labelFormatters)
      )
    }

    implicit def jsonWritesExperienceExperienceCurrencyFormat: play.api.libs.json.Writes[ExperienceCurrencyFormat] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceCurrencyFormat] {
        def writes(obj: io.flow.experience.v0.models.ExperienceCurrencyFormat) = {
          jsObjectExperienceCurrencyFormat(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceCurrencyFormatForm: play.api.libs.json.Reads[ExperienceCurrencyFormatForm] = {
      for {
        symbol <- (__ \ "symbol").read[io.flow.common.v0.models.CurrencySymbolFormat]
        labelFormatters <- (__ \ "label_formatters").read[Seq[io.flow.common.v0.models.CurrencyLabelFormatter]]
      } yield ExperienceCurrencyFormatForm(symbol, labelFormatters)
    }

    def jsObjectExperienceCurrencyFormatForm(obj: io.flow.experience.v0.models.ExperienceCurrencyFormatForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "symbol" -> play.api.libs.json.JsString(obj.symbol.toString),
        "label_formatters" -> play.api.libs.json.Json.toJson(obj.labelFormatters)
      )
    }

    implicit def jsonWritesExperienceExperienceCurrencyFormatForm: play.api.libs.json.Writes[ExperienceCurrencyFormatForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceCurrencyFormatForm] {
        def writes(obj: io.flow.experience.v0.models.ExperienceCurrencyFormatForm) = {
          jsObjectExperienceCurrencyFormatForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceDefaults: play.api.libs.json.Reads[ExperienceDefaults] = {
      for {
        key <- (__ \ "key").read[String]
        name <- (__ \ "name").read[String]
        deliveredDuty <- (__ \ "delivered_duty").read[io.flow.common.v0.models.DeliveredDuty]
        country <- (__ \ "country").read[String]
        currency <- (__ \ "currency").read[String]
        language <- (__ \ "language").read[String]
        measurementSystem <- (__ \ "measurement_system").read[io.flow.common.v0.models.MeasurementSystem]
      } yield ExperienceDefaults(key, name, deliveredDuty, country, currency, language, measurementSystem)
    }

    def jsObjectExperienceDefaults(obj: io.flow.experience.v0.models.ExperienceDefaults): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "country" -> play.api.libs.json.JsString(obj.country),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "language" -> play.api.libs.json.JsString(obj.language),
        "measurement_system" -> play.api.libs.json.JsString(obj.measurementSystem.toString)
      )
    }

    implicit def jsonWritesExperienceExperienceDefaults: play.api.libs.json.Writes[ExperienceDefaults] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceDefaults] {
        def writes(obj: io.flow.experience.v0.models.ExperienceDefaults) = {
          jsObjectExperienceDefaults(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceForm: play.api.libs.json.Reads[ExperienceForm] = {
      for {
        regionId <- (__ \ "region_id").read[String]
        name <- (__ \ "name").read[String]
        deliveredDuty <- (__ \ "delivered_duty").readNullable[io.flow.common.v0.models.DeliveredDuty]
        country <- (__ \ "country").readNullable[String]
        currency <- (__ \ "currency").readNullable[String]
        language <- (__ \ "language").readNullable[String]
        key <- (__ \ "key").readNullable[String]
        measurementSystem <- (__ \ "measurement_system").readNullable[io.flow.common.v0.models.MeasurementSystem]
        subcatalogId <- (__ \ "subcatalog_id").readNullable[String]
      } yield ExperienceForm(regionId, name, deliveredDuty, country, currency, language, key, measurementSystem, subcatalogId)
    }

    def jsObjectExperienceForm(obj: io.flow.experience.v0.models.ExperienceForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "region_id" -> play.api.libs.json.JsString(obj.regionId),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.deliveredDuty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("delivered_duty" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.country match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("country" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.language match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("language" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.measurementSystem match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("measurement_system" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.subcatalogId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("subcatalog_id" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceExperienceForm: play.api.libs.json.Writes[ExperienceForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceForm] {
        def writes(obj: io.flow.experience.v0.models.ExperienceForm) = {
          jsObjectExperienceForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceGeo: play.api.libs.json.Reads[ExperienceGeo] = {
      for {
        key <- (__ \ "key").read[String]
        name <- (__ \ "name").read[String]
        region <- (__ \ "region").read[io.flow.experience.v0.models.RegionReference]
        country <- (__ \ "country").read[String]
        currency <- (__ \ "currency").read[String]
        language <- (__ \ "language").read[String]
        measurementSystem <- (__ \ "measurement_system").read[io.flow.common.v0.models.MeasurementSystem]
      } yield ExperienceGeo(key, name, region, country, currency, language, measurementSystem)
    }

    def jsObjectExperienceGeo(obj: io.flow.experience.v0.models.ExperienceGeo): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "region" -> jsObjectRegionReference(obj.region),
        "country" -> play.api.libs.json.JsString(obj.country),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "language" -> play.api.libs.json.JsString(obj.language),
        "measurement_system" -> play.api.libs.json.JsString(obj.measurementSystem.toString)
      )
    }

    implicit def jsonWritesExperienceExperienceGeo: play.api.libs.json.Writes[ExperienceGeo] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceGeo] {
        def writes(obj: io.flow.experience.v0.models.ExperienceGeo) = {
          jsObjectExperienceGeo(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceLogisticsSettings: play.api.libs.json.Reads[ExperienceLogisticsSettings] = {
      for {
        id <- (__ \ "id").read[String]
        experience <- (__ \ "experience").read[io.flow.experience.v0.models.ExperienceOverview]
        shippingConfiguration <- (__ \ "shipping_configuration").read[io.flow.fulfillment.v0.models.ShippingConfigurationReference]
      } yield ExperienceLogisticsSettings(id, experience, shippingConfiguration)
    }

    def jsObjectExperienceLogisticsSettings(obj: io.flow.experience.v0.models.ExperienceLogisticsSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "experience" -> jsObjectExperienceOverview(obj.experience),
        "shipping_configuration" -> io.flow.fulfillment.v0.models.json.jsObjectShippingConfigurationReference(obj.shippingConfiguration)
      )
    }

    implicit def jsonWritesExperienceExperienceLogisticsSettings: play.api.libs.json.Writes[ExperienceLogisticsSettings] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceLogisticsSettings] {
        def writes(obj: io.flow.experience.v0.models.ExperienceLogisticsSettings) = {
          jsObjectExperienceLogisticsSettings(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceLogisticsSettingsPutForm: play.api.libs.json.Reads[ExperienceLogisticsSettingsPutForm] = {
      (__ \ "shipping_configuration_key").read[String].map { x => new ExperienceLogisticsSettingsPutForm(shippingConfigurationKey = x) }
    }

    def jsObjectExperienceLogisticsSettingsPutForm(obj: io.flow.experience.v0.models.ExperienceLogisticsSettingsPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "shipping_configuration_key" -> play.api.libs.json.JsString(obj.shippingConfigurationKey)
      )
    }

    implicit def jsonWritesExperienceExperienceLogisticsSettingsPutForm: play.api.libs.json.Writes[ExperienceLogisticsSettingsPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceLogisticsSettingsPutForm] {
        def writes(obj: io.flow.experience.v0.models.ExperienceLogisticsSettingsPutForm) = {
          jsObjectExperienceLogisticsSettingsPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceLogisticsSummary: play.api.libs.json.Reads[ExperienceLogisticsSummary] = {
      for {
        outbound <- (__ \ "outbound").readNullable[io.flow.experience.v0.models.ExperienceLogisticsTierSummary]
        `return` <- (__ \ "return").readNullable[io.flow.experience.v0.models.ExperienceLogisticsTierSummary]
      } yield ExperienceLogisticsSummary(outbound, `return`)
    }

    def jsObjectExperienceLogisticsSummary(obj: io.flow.experience.v0.models.ExperienceLogisticsSummary): play.api.libs.json.JsObject = {
      (obj.outbound match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("outbound" -> jsObjectExperienceLogisticsTierSummary(x))
      }) ++
      (obj.`return` match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("return" -> jsObjectExperienceLogisticsTierSummary(x))
      })
    }

    implicit def jsonWritesExperienceExperienceLogisticsSummary: play.api.libs.json.Writes[ExperienceLogisticsSummary] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceLogisticsSummary] {
        def writes(obj: io.flow.experience.v0.models.ExperienceLogisticsSummary) = {
          jsObjectExperienceLogisticsSummary(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceLogisticsTierSummary: play.api.libs.json.Reads[ExperienceLogisticsTierSummary] = {
      (__ \ "prices").read[io.flow.experience.v0.models.ExperienceLogisticsTierSummaryPrices].map { x => new ExperienceLogisticsTierSummary(prices = x) }
    }

    def jsObjectExperienceLogisticsTierSummary(obj: io.flow.experience.v0.models.ExperienceLogisticsTierSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "prices" -> jsObjectExperienceLogisticsTierSummaryPrices(obj.prices)
      )
    }

    implicit def jsonWritesExperienceExperienceLogisticsTierSummary: play.api.libs.json.Writes[ExperienceLogisticsTierSummary] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceLogisticsTierSummary] {
        def writes(obj: io.flow.experience.v0.models.ExperienceLogisticsTierSummary) = {
          jsObjectExperienceLogisticsTierSummary(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceLogisticsTierSummaryPrices: play.api.libs.json.Reads[ExperienceLogisticsTierSummaryPrices] = {
      (__ \ "minimum").read[io.flow.common.v0.models.Price].map { x => new ExperienceLogisticsTierSummaryPrices(minimum = x) }
    }

    def jsObjectExperienceLogisticsTierSummaryPrices(obj: io.flow.experience.v0.models.ExperienceLogisticsTierSummaryPrices): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "minimum" -> io.flow.common.v0.models.json.jsObjectPrice(obj.minimum)
      )
    }

    implicit def jsonWritesExperienceExperienceLogisticsTierSummaryPrices: play.api.libs.json.Writes[ExperienceLogisticsTierSummaryPrices] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceLogisticsTierSummaryPrices] {
        def writes(obj: io.flow.experience.v0.models.ExperienceLogisticsTierSummaryPrices) = {
          jsObjectExperienceLogisticsTierSummaryPrices(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceOverview: play.api.libs.json.Reads[ExperienceOverview] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
      } yield ExperienceOverview(id, key)
    }

    def jsObjectExperienceOverview(obj: io.flow.experience.v0.models.ExperienceOverview): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesExperienceExperienceOverview: play.api.libs.json.Writes[ExperienceOverview] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceOverview] {
        def writes(obj: io.flow.experience.v0.models.ExperienceOverview) = {
          jsObjectExperienceOverview(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePaymentMethodRuleForm: play.api.libs.json.Reads[ExperiencePaymentMethodRuleForm] = {
      for {
        paymentMethodId <- (__ \ "payment_method_id").read[String]
        tags <- (__ \ "tags").read[Seq[io.flow.experience.v0.models.ExperiencePaymentMethodTag]]
      } yield ExperiencePaymentMethodRuleForm(paymentMethodId, tags)
    }

    def jsObjectExperiencePaymentMethodRuleForm(obj: io.flow.experience.v0.models.ExperiencePaymentMethodRuleForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "payment_method_id" -> play.api.libs.json.JsString(obj.paymentMethodId),
        "tags" -> play.api.libs.json.Json.toJson(obj.tags)
      )
    }

    implicit def jsonWritesExperienceExperiencePaymentMethodRuleForm: play.api.libs.json.Writes[ExperiencePaymentMethodRuleForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePaymentMethodRuleForm] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePaymentMethodRuleForm) = {
          jsObjectExperiencePaymentMethodRuleForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePriceBookMapping: play.api.libs.json.Reads[ExperiencePriceBookMapping] = {
      for {
        id <- (__ \ "id").read[String]
        experience <- (__ \ "experience").read[io.flow.experience.v0.models.ExperienceReference]
        priceBook <- (__ \ "price_book").read[io.flow.price.v0.models.PriceBookReference]
        position <- (__ \ "position").read[Long]
      } yield ExperiencePriceBookMapping(id, experience, priceBook, position)
    }

    def jsObjectExperiencePriceBookMapping(obj: io.flow.experience.v0.models.ExperiencePriceBookMapping): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "experience" -> jsObjectExperienceReference(obj.experience),
        "price_book" -> io.flow.price.v0.models.json.jsObjectPriceBookReference(obj.priceBook),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      )
    }

    implicit def jsonWritesExperienceExperiencePriceBookMapping: play.api.libs.json.Writes[ExperiencePriceBookMapping] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePriceBookMapping] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePriceBookMapping) = {
          jsObjectExperiencePriceBookMapping(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePriceBookMappingForm: play.api.libs.json.Reads[ExperiencePriceBookMappingForm] = {
      for {
        priceBookKey <- (__ \ "price_book_key").read[String]
        position <- (__ \ "position").readNullable[Long]
      } yield ExperiencePriceBookMappingForm(priceBookKey, position)
    }

    def jsObjectExperiencePriceBookMappingForm(obj: io.flow.experience.v0.models.ExperiencePriceBookMappingForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "price_book_key" -> play.api.libs.json.JsString(obj.priceBookKey)
      ) ++ (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesExperienceExperiencePriceBookMappingForm: play.api.libs.json.Writes[ExperiencePriceBookMappingForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePriceBookMappingForm] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePriceBookMappingForm) = {
          jsObjectExperiencePriceBookMappingForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePriceBookMappingPutForm: play.api.libs.json.Reads[ExperiencePriceBookMappingPutForm] = {
      (__ \ "price_books").read[Seq[io.flow.experience.v0.models.ExperiencePriceBookMappingForm]].map { x => new ExperiencePriceBookMappingPutForm(priceBooks = x) }
    }

    def jsObjectExperiencePriceBookMappingPutForm(obj: io.flow.experience.v0.models.ExperiencePriceBookMappingPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "price_books" -> play.api.libs.json.Json.toJson(obj.priceBooks)
      )
    }

    implicit def jsonWritesExperienceExperiencePriceBookMappingPutForm: play.api.libs.json.Writes[ExperiencePriceBookMappingPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePriceBookMappingPutForm] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePriceBookMappingPutForm) = {
          jsObjectExperiencePriceBookMappingPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceReference: play.api.libs.json.Reads[ExperienceReference] = {
      (__ \ "key").read[String].map { x => new ExperienceReference(key = x) }
    }

    def jsObjectExperienceReference(obj: io.flow.experience.v0.models.ExperienceReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonReadsExperienceExperienceSettings: play.api.libs.json.Reads[ExperienceSettings] = {
      for {
        deliveredDuty <- (__ \ "delivered_duty").read[io.flow.experience.v0.models.DeliveredDutySetting]
        pricingSettings <- (__ \ "pricing_settings").readNullable[io.flow.experience.v0.models.PricingSettings]
        logisticsSettings <- (__ \ "logistics_settings").readNullable[io.flow.experience.v0.models.LogisticsSettings]
        checkoutSettings <- (__ \ "checkout_settings").readNullable[io.flow.experience.v0.models.CheckoutSettings]
      } yield ExperienceSettings(deliveredDuty, pricingSettings, logisticsSettings, checkoutSettings)
    }

    def jsObjectExperienceSettings(obj: io.flow.experience.v0.models.ExperienceSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "delivered_duty" -> jsObjectDeliveredDutySetting(obj.deliveredDuty)
      ) ++ (obj.pricingSettings match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("pricing_settings" -> jsObjectPricingSettings(x))
      }) ++
      (obj.logisticsSettings match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("logistics_settings" -> jsObjectLogisticsSettings(x))
      }) ++
      (obj.checkoutSettings match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("checkout_settings" -> jsObjectCheckoutSettings(x))
      })
    }

    implicit def jsonWritesExperienceExperienceSettings: play.api.libs.json.Writes[ExperienceSettings] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceSettings] {
        def writes(obj: io.flow.experience.v0.models.ExperienceSettings) = {
          jsObjectExperienceSettings(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceStatusForm: play.api.libs.json.Reads[ExperienceStatusForm] = {
      (__ \ "status").read[io.flow.experience.v0.models.ExperienceStatus].map { x => new ExperienceStatusForm(status = x) }
    }

    def jsObjectExperienceStatusForm(obj: io.flow.experience.v0.models.ExperienceStatusForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      )
    }

    implicit def jsonWritesExperienceExperienceStatusForm: play.api.libs.json.Writes[ExperienceStatusForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceStatusForm] {
        def writes(obj: io.flow.experience.v0.models.ExperienceStatusForm) = {
          jsObjectExperienceStatusForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceVersion: play.api.libs.json.Reads[ExperienceVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        experience <- (__ \ "experience").read[io.flow.experience.v0.models.Experience]
      } yield ExperienceVersion(id, timestamp, `type`, experience)
    }

    def jsObjectExperienceVersion(obj: io.flow.experience.v0.models.ExperienceVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "experience" -> jsObjectExperience(obj.experience)
      )
    }

    implicit def jsonWritesExperienceExperienceVersion: play.api.libs.json.Writes[ExperienceVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceVersion] {
        def writes(obj: io.flow.experience.v0.models.ExperienceVersion) = {
          jsObjectExperienceVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceFreeShipping: play.api.libs.json.Reads[FreeShipping] = {
      for {
        trigger <- (__ \ "trigger").read[io.flow.experience.v0.models.PromotionTrigger]
        max <- (__ \ "max").readNullable[io.flow.common.v0.models.Price]
      } yield FreeShipping(trigger, max)
    }

    def jsObjectFreeShipping(obj: io.flow.experience.v0.models.FreeShipping): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "trigger" -> jsObjectPromotionTrigger(obj.trigger)
      ) ++ (obj.max match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("max" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      })
    }

    implicit def jsonReadsExperienceFreeShippingOrderPromotion: play.api.libs.json.Reads[FreeShippingOrderPromotion] = {
      for {
        id <- (__ \ "id").read[String]
        order <- (__ \ "order").read[io.flow.experience.v0.models.ExpandableOrder]
        key <- (__ \ "key").read[String]
        trigger <- (__ \ "trigger").read[io.flow.experience.v0.models.OrderPromotionTrigger]
        max <- (__ \ "max").readNullable[io.flow.common.v0.models.Price]
        attributes <- (__ \ "attributes").read[Map[String, String]]
      } yield FreeShippingOrderPromotion(id, order, key, trigger, max, attributes)
    }

    def jsObjectFreeShippingOrderPromotion(obj: io.flow.experience.v0.models.FreeShippingOrderPromotion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "order" -> jsObjectExpandableOrder(obj.order),
        "key" -> play.api.libs.json.JsString(obj.key),
        "trigger" -> jsObjectOrderPromotionTrigger(obj.trigger),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.max match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("max" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      })
    }

    implicit def jsonReadsExperienceFreeShippingOrderPromotionForm: play.api.libs.json.Reads[FreeShippingOrderPromotionForm] = {
      for {
        trigger <- (__ \ "trigger").read[io.flow.experience.v0.models.PromotionTriggerForm]
        max <- (__ \ "max").readNullable[io.flow.common.v0.models.PriceForm]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield FreeShippingOrderPromotionForm(trigger, max, attributes)
    }

    def jsObjectFreeShippingOrderPromotionForm(obj: io.flow.experience.v0.models.FreeShippingOrderPromotionForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "trigger" -> jsObjectPromotionTriggerForm(obj.trigger)
      ) ++ (obj.max match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("max" -> io.flow.common.v0.models.json.jsObjectPriceForm(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonReadsExperienceInstallmentPlanPaymentError: play.api.libs.json.Reads[InstallmentPlanPaymentError] = {
      for {
        code <- (__ \ "code").read[io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode]
        messages <- (__ \ "messages").read[Seq[String]]
        codes <- (__ \ "codes").read[Seq[io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode]]
      } yield InstallmentPlanPaymentError(code, messages, codes)
    }

    def jsObjectInstallmentPlanPaymentError(obj: io.flow.experience.v0.models.InstallmentPlanPaymentError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages),
        "codes" -> play.api.libs.json.Json.toJson(obj.codes)
      )
    }

    implicit def jsonWritesExperienceInstallmentPlanPaymentError: play.api.libs.json.Writes[InstallmentPlanPaymentError] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.InstallmentPlanPaymentError] {
        def writes(obj: io.flow.experience.v0.models.InstallmentPlanPaymentError) = {
          jsObjectInstallmentPlanPaymentError(obj)
        }
      }
    }

    implicit def jsonReadsExperienceInstallmentPlanPaymentForm: play.api.libs.json.Reads[InstallmentPlanPaymentForm] = {
      for {
        installmentProgramId <- (__ \ "installment_program_id").read[String]
        authorizationKey <- (__ \ "authorization_key").read[String]
      } yield InstallmentPlanPaymentForm(installmentProgramId, authorizationKey)
    }

    def jsObjectInstallmentPlanPaymentForm(obj: io.flow.experience.v0.models.InstallmentPlanPaymentForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "installment_program_id" -> play.api.libs.json.JsString(obj.installmentProgramId),
        "authorization_key" -> play.api.libs.json.JsString(obj.authorizationKey)
      )
    }

    implicit def jsonWritesExperienceInstallmentPlanPaymentForm: play.api.libs.json.Writes[InstallmentPlanPaymentForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.InstallmentPlanPaymentForm] {
        def writes(obj: io.flow.experience.v0.models.InstallmentPlanPaymentForm) = {
          jsObjectInstallmentPlanPaymentForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceInstallmentProgramSummary: play.api.libs.json.Reads[InstallmentProgramSummary] = {
      for {
        id <- (__ \ "id").read[String]
        name <- (__ \ "name").read[String]
        initial <- (__ \ "initial").read[io.flow.common.v0.models.Price]
      } yield InstallmentProgramSummary(id, name, initial)
    }

    def jsObjectInstallmentProgramSummary(obj: io.flow.experience.v0.models.InstallmentProgramSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name),
        "initial" -> io.flow.common.v0.models.json.jsObjectPrice(obj.initial)
      )
    }

    implicit def jsonWritesExperienceInstallmentProgramSummary: play.api.libs.json.Writes[InstallmentProgramSummary] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.InstallmentProgramSummary] {
        def writes(obj: io.flow.experience.v0.models.InstallmentProgramSummary) = {
          jsObjectInstallmentProgramSummary(obj)
        }
      }
    }

    implicit def jsonReadsExperienceItemMargin: play.api.libs.json.Reads[ItemMargin] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        name <- (__ \ "name").read[String]
        q <- (__ \ "q").read[String]
        fixed <- (__ \ "fixed").read[BigDecimal]
        percent <- (__ \ "percent").read[BigDecimal]
        position <- (__ \ "position").read[Long]
      } yield ItemMargin(id, key, name, q, fixed, percent, position)
    }

    def jsObjectItemMargin(obj: io.flow.experience.v0.models.ItemMargin): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "q" -> play.api.libs.json.JsString(obj.q),
        "fixed" -> play.api.libs.json.JsNumber(obj.fixed),
        "percent" -> play.api.libs.json.JsNumber(obj.percent),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      )
    }

    implicit def jsonWritesExperienceItemMargin: play.api.libs.json.Writes[ItemMargin] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ItemMargin] {
        def writes(obj: io.flow.experience.v0.models.ItemMargin) = {
          jsObjectItemMargin(obj)
        }
      }
    }

    implicit def jsonReadsExperienceItemMarginPostForm: play.api.libs.json.Reads[ItemMarginPostForm] = {
      for {
        name <- (__ \ "name").read[String]
        q <- (__ \ "q").read[String]
        key <- (__ \ "key").readNullable[String]
        fixed <- (__ \ "fixed").readNullable[BigDecimal]
        percent <- (__ \ "percent").readNullable[BigDecimal]
        position <- (__ \ "position").readNullable[Long]
      } yield ItemMarginPostForm(name, q, key, fixed, percent, position)
    }

    def jsObjectItemMarginPostForm(obj: io.flow.experience.v0.models.ItemMarginPostForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "q" -> play.api.libs.json.JsString(obj.q)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.fixed match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("fixed" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.percent match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("percent" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesExperienceItemMarginPostForm: play.api.libs.json.Writes[ItemMarginPostForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ItemMarginPostForm] {
        def writes(obj: io.flow.experience.v0.models.ItemMarginPostForm) = {
          jsObjectItemMarginPostForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceItemMarginPutForm: play.api.libs.json.Reads[ItemMarginPutForm] = {
      for {
        name <- (__ \ "name").read[String]
        q <- (__ \ "q").read[String]
        fixed <- (__ \ "fixed").readNullable[BigDecimal]
        percent <- (__ \ "percent").readNullable[BigDecimal]
        position <- (__ \ "position").readNullable[Long]
      } yield ItemMarginPutForm(name, q, fixed, percent, position)
    }

    def jsObjectItemMarginPutForm(obj: io.flow.experience.v0.models.ItemMarginPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "q" -> play.api.libs.json.JsString(obj.q)
      ) ++ (obj.fixed match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("fixed" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.percent match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("percent" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesExperienceItemMarginPutForm: play.api.libs.json.Writes[ItemMarginPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ItemMarginPutForm] {
        def writes(obj: io.flow.experience.v0.models.ItemMarginPutForm) = {
          jsObjectItemMarginPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceItemMarginVersion: play.api.libs.json.Reads[ItemMarginVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        itemMargin <- (__ \ "item_margin").read[io.flow.experience.v0.models.ItemMargin]
      } yield ItemMarginVersion(id, timestamp, `type`, itemMargin)
    }

    def jsObjectItemMarginVersion(obj: io.flow.experience.v0.models.ItemMarginVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "item_margin" -> jsObjectItemMargin(obj.itemMargin)
      )
    }

    implicit def jsonWritesExperienceItemMarginVersion: play.api.libs.json.Writes[ItemMarginVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ItemMarginVersion] {
        def writes(obj: io.flow.experience.v0.models.ItemMarginVersion) = {
          jsObjectItemMarginVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceLine: play.api.libs.json.Reads[Line] = {
      for {
        itemNumber <- (__ \ "item_number").read[String]
        quantity <- (__ \ "quantity").read[Long]
        price <- (__ \ "price").read[io.flow.common.v0.models.PriceWithBase]
        total <- (__ \ "total").read[io.flow.common.v0.models.PriceWithBase]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield Line(itemNumber, quantity, price, total, attributes)
    }

    def jsObjectLine(obj: io.flow.experience.v0.models.Line): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "item_number" -> play.api.libs.json.JsString(obj.itemNumber),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "price" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.price),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total)
      ) ++ (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceLine: play.api.libs.json.Writes[Line] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Line] {
        def writes(obj: io.flow.experience.v0.models.Line) = {
          jsObjectLine(obj)
        }
      }
    }

    implicit def jsonReadsExperienceLocalizedLineItem: play.api.libs.json.Reads[LocalizedLineItem] = {
      for {
        number <- (__ \ "number").read[String]
        name <- (__ \ "name").read[String]
        quantity <- (__ \ "quantity").read[Long]
        center <- (__ \ "center").readNullable[String]
        price <- (__ \ "price").readNullable[io.flow.common.v0.models.Money]
        discount <- (__ \ "discount").readNullable[io.flow.experience.v0.models.LocalizedLineItemDiscount]
        discounts <- (__ \ "discounts").readNullable[Seq[io.flow.experience.v0.models.LocalizedLineItemDiscount]]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        local <- (__ \ "local").read[io.flow.catalog.v0.models.Local]
        shipmentEstimate <- (__ \ "shipment_estimate").readNullable[io.flow.common.v0.models.DatetimeRange]
        priceSource <- (__ \ "price_source").readNullable[io.flow.common.v0.models.PriceSource]
      } yield LocalizedLineItem(number, name, quantity, center, price, discount, discounts, attributes, local, shipmentEstimate, priceSource)
    }

    def jsObjectLocalizedLineItem(obj: io.flow.experience.v0.models.LocalizedLineItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "name" -> play.api.libs.json.JsString(obj.name),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "local" -> io.flow.catalog.v0.models.json.jsObjectLocal(obj.local)
      ) ++ (obj.center match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("center" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.price match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> jsObjectLocalizedLineItemDiscount(x))
      }) ++
      (obj.discounts match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discounts" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.shipmentEstimate match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("shipment_estimate" -> io.flow.common.v0.models.json.jsObjectDatetimeRange(x))
      }) ++
      (obj.priceSource match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price_source" -> io.flow.common.v0.models.json.jsObjectPriceSource(x))
      })
    }

    implicit def jsonWritesExperienceLocalizedLineItem: play.api.libs.json.Writes[LocalizedLineItem] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.LocalizedLineItem] {
        def writes(obj: io.flow.experience.v0.models.LocalizedLineItem) = {
          jsObjectLocalizedLineItem(obj)
        }
      }
    }

    implicit def jsonReadsExperienceLocalizedLineItemDiscount: play.api.libs.json.Reads[LocalizedLineItemDiscount] = {
      for {
        amount <- (__ \ "amount").read[Double]
        currency <- (__ \ "currency").read[String]
        label <- (__ \ "label").readNullable[String]
        base <- (__ \ "base").readNullable[io.flow.common.v0.models.Price]
        requested <- (__ \ "requested").readNullable[io.flow.common.v0.models.Money]
        discountLabel <- (__ \ "discount_label").readNullable[String]
      } yield LocalizedLineItemDiscount(amount, currency, label, base, requested, discountLabel)
    }

    def jsObjectLocalizedLineItemDiscount(obj: io.flow.experience.v0.models.LocalizedLineItemDiscount): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.label match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("label" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.base match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("base" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      }) ++
      (obj.requested match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("requested" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.discountLabel match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount_label" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceLocalizedLineItemDiscount: play.api.libs.json.Writes[LocalizedLineItemDiscount] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.LocalizedLineItemDiscount] {
        def writes(obj: io.flow.experience.v0.models.LocalizedLineItemDiscount) = {
          jsObjectLocalizedLineItemDiscount(obj)
        }
      }
    }

    implicit def jsonReadsExperienceLogisticsSettings: play.api.libs.json.Reads[LogisticsSettings] = {
      (__ \ "shipping_configuration").read[io.flow.fulfillment.v0.models.ShippingConfigurationReference].map { x => new LogisticsSettings(shippingConfiguration = x) }
    }

    def jsObjectLogisticsSettings(obj: io.flow.experience.v0.models.LogisticsSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "shipping_configuration" -> io.flow.fulfillment.v0.models.json.jsObjectShippingConfigurationReference(obj.shippingConfiguration)
      )
    }

    implicit def jsonWritesExperienceLogisticsSettings: play.api.libs.json.Writes[LogisticsSettings] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.LogisticsSettings] {
        def writes(obj: io.flow.experience.v0.models.LogisticsSettings) = {
          jsObjectLogisticsSettings(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrder: play.api.libs.json.Reads[Order] = {
      for {
        id <- (__ \ "id").read[String]
        number <- (__ \ "number").read[String]
        merchantOfRecord <- (__ \ "merchant_of_record").readNullable[io.flow.common.v0.models.OrderMerchantOfRecord]
        experience <- (__ \ "experience").readNullable[io.flow.experience.v0.models.ExpandableExperience]
        customer <- (__ \ "customer").read[io.flow.common.v0.models.OrderCustomer]
        deliveredDuty <- (__ \ "delivered_duty").read[io.flow.common.v0.models.DeliveredDuty]
        destination <- (__ \ "destination").read[io.flow.experience.v0.models.OrderAddress]
        expiresAt <- (__ \ "expires_at").read[_root_.org.joda.time.DateTime]
        items <- (__ \ "items").read[Seq[io.flow.experience.v0.models.LocalizedLineItem]]
        deliveries <- (__ \ "deliveries").read[Seq[io.flow.fulfillment.v0.models.Delivery]]
        selections <- (__ \ "selections").read[Seq[String]]
        prices <- (__ \ "prices").read[Seq[io.flow.experience.v0.models.OrderPriceDetail]]
        total <- (__ \ "total").read[io.flow.catalog.v0.models.LocalizedTotal]
        attributes <- (__ \ "attributes").read[Map[String, String]]
        submittedAt <- (__ \ "submitted_at").readNullable[_root_.org.joda.time.DateTime]
        lines <- (__ \ "lines").readNullable[Seq[io.flow.experience.v0.models.Line]]
        identifiers <- (__ \ "identifiers").readNullable[Seq[String]]
        promotions <- (__ \ "promotions").readNullable[io.flow.experience.v0.models.Promotions]
        payments <- (__ \ "payments").readNullable[Seq[io.flow.experience.v0.models.OrderPayment]]
        balance <- (__ \ "balance").readNullable[io.flow.catalog.v0.models.LocalizedTotal]
        rules <- (__ \ "rules").readNullable[io.flow.experience.v0.models.OrderRulesSummary]
        taxRegistration <- (__ \ "tax_registration").readNullable[io.flow.harmonization.v0.models.TaxRegistration]
        geo <- (__ \ "geo").readNullable[io.flow.experience.v0.models.OrderGeo]
      } yield Order(id, number, merchantOfRecord, experience, customer, deliveredDuty, destination, expiresAt, items, deliveries, selections, prices, total, attributes, submittedAt, lines, identifiers, promotions, payments, balance, rules, taxRegistration, geo)
    }

    def jsObjectOrder(obj: io.flow.experience.v0.models.Order): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number),
        "customer" -> io.flow.common.v0.models.json.jsObjectOrderCustomer(obj.customer),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "destination" -> jsObjectOrderAddress(obj.destination),
        "expires_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.expiresAt)),
        "items" -> play.api.libs.json.Json.toJson(obj.items),
        "deliveries" -> play.api.libs.json.Json.toJson(obj.deliveries),
        "selections" -> play.api.libs.json.Json.toJson(obj.selections),
        "prices" -> play.api.libs.json.Json.toJson(obj.prices),
        "total" -> io.flow.catalog.v0.models.json.jsObjectLocalizedTotal(obj.total),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.merchantOfRecord match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("merchant_of_record" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.experience match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("experience" -> jsObjectExpandableExperience(x))
      }) ++
      (obj.submittedAt match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("submitted_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
      (obj.lines match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("lines" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.identifiers match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("identifiers" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.promotions match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("promotions" -> jsObjectPromotions(x))
      }) ++
      (obj.payments match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("payments" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.balance match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("balance" -> io.flow.catalog.v0.models.json.jsObjectLocalizedTotal(x))
      }) ++
      (obj.rules match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("rules" -> jsObjectOrderRulesSummary(x))
      }) ++
      (obj.taxRegistration match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax_registration" -> io.flow.harmonization.v0.models.json.jsObjectTaxRegistration(x))
      }) ++
      (obj.geo match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("geo" -> jsObjectOrderGeo(x))
      })
    }

    implicit def jsonReadsExperienceOrderAddress: play.api.libs.json.Reads[OrderAddress] = {
      for {
        text <- (__ \ "text").readNullable[String]
        streets <- (__ \ "streets").readNullable[Seq[String]]
        city <- (__ \ "city").readNullable[String]
        province <- (__ \ "province").readNullable[String]
        postal <- (__ \ "postal").readNullable[String]
        country <- (__ \ "country").readNullable[String]
        latitude <- (__ \ "latitude").readNullable[String]
        longitude <- (__ \ "longitude").readNullable[String]
        contact <- (__ \ "contact").readNullable[io.flow.common.v0.models.Contact]
      } yield OrderAddress(text, streets, city, province, postal, country, latitude, longitude, contact)
    }

    def jsObjectOrderAddress(obj: io.flow.experience.v0.models.OrderAddress): play.api.libs.json.JsObject = {
      (obj.text match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("text" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.streets match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("streets" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.city match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("city" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.province match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("province" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.postal match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("postal" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.country match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("country" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.latitude match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("latitude" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.longitude match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("longitude" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.contact match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("contact" -> io.flow.common.v0.models.json.jsObjectContact(x))
      })
    }

    implicit def jsonWritesExperienceOrderAddress: play.api.libs.json.Writes[OrderAddress] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderAddress] {
        def writes(obj: io.flow.experience.v0.models.OrderAddress) = {
          jsObjectOrderAddress(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderBuilder: play.api.libs.json.Reads[OrderBuilder] = {
      for {
        order <- (__ \ "order").readNullable[io.flow.experience.v0.models.Order]
        errors <- (__ \ "errors").readNullable[Seq[io.flow.experience.v0.models.OrderError]]
      } yield OrderBuilder(order, errors)
    }

    def jsObjectOrderBuilder(obj: io.flow.experience.v0.models.OrderBuilder): play.api.libs.json.JsObject = {
      (obj.order match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order" -> jsObjectOrder(x))
      }) ++
      (obj.errors match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("errors" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceOrderBuilder: play.api.libs.json.Writes[OrderBuilder] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderBuilder] {
        def writes(obj: io.flow.experience.v0.models.OrderBuilder) = {
          jsObjectOrderBuilder(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderBuilderAttributesForm: play.api.libs.json.Reads[OrderBuilderAttributesForm] = {
      (__ \ "attributes").read[Map[String, String]].map { x => new OrderBuilderAttributesForm(attributes = x) }
    }

    def jsObjectOrderBuilderAttributesForm(obj: io.flow.experience.v0.models.OrderBuilderAttributesForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      )
    }

    implicit def jsonWritesExperienceOrderBuilderAttributesForm: play.api.libs.json.Writes[OrderBuilderAttributesForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderBuilderAttributesForm] {
        def writes(obj: io.flow.experience.v0.models.OrderBuilderAttributesForm) = {
          jsObjectOrderBuilderAttributesForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderBuilderCustomerInvoiceAddressForm: play.api.libs.json.Reads[OrderBuilderCustomerInvoiceAddressForm] = {
      (__ \ "address").read[io.flow.common.v0.models.BillingAddress].map { x => new OrderBuilderCustomerInvoiceAddressForm(address = x) }
    }

    def jsObjectOrderBuilderCustomerInvoiceAddressForm(obj: io.flow.experience.v0.models.OrderBuilderCustomerInvoiceAddressForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(obj.address)
      )
    }

    implicit def jsonWritesExperienceOrderBuilderCustomerInvoiceAddressForm: play.api.libs.json.Writes[OrderBuilderCustomerInvoiceAddressForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderBuilderCustomerInvoiceAddressForm] {
        def writes(obj: io.flow.experience.v0.models.OrderBuilderCustomerInvoiceAddressForm) = {
          jsObjectOrderBuilderCustomerInvoiceAddressForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderBuilderDeliveredDutyForm: play.api.libs.json.Reads[OrderBuilderDeliveredDutyForm] = {
      (__ \ "delivered_duty").read[io.flow.common.v0.models.DeliveredDuty].map { x => new OrderBuilderDeliveredDutyForm(deliveredDuty = x) }
    }

    def jsObjectOrderBuilderDeliveredDutyForm(obj: io.flow.experience.v0.models.OrderBuilderDeliveredDutyForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString)
      )
    }

    implicit def jsonWritesExperienceOrderBuilderDeliveredDutyForm: play.api.libs.json.Writes[OrderBuilderDeliveredDutyForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderBuilderDeliveredDutyForm] {
        def writes(obj: io.flow.experience.v0.models.OrderBuilderDeliveredDutyForm) = {
          jsObjectOrderBuilderDeliveredDutyForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderBuilderDestinationCountryForm: play.api.libs.json.Reads[OrderBuilderDestinationCountryForm] = {
      (__ \ "country").read[String].map { x => new OrderBuilderDestinationCountryForm(country = x) }
    }

    def jsObjectOrderBuilderDestinationCountryForm(obj: io.flow.experience.v0.models.OrderBuilderDestinationCountryForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "country" -> play.api.libs.json.JsString(obj.country)
      )
    }

    implicit def jsonWritesExperienceOrderBuilderDestinationCountryForm: play.api.libs.json.Writes[OrderBuilderDestinationCountryForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderBuilderDestinationCountryForm] {
        def writes(obj: io.flow.experience.v0.models.OrderBuilderDestinationCountryForm) = {
          jsObjectOrderBuilderDestinationCountryForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderBuilderDestinationForm: play.api.libs.json.Reads[OrderBuilderDestinationForm] = {
      (__ \ "destination").read[io.flow.experience.v0.models.OrderAddress].map { x => new OrderBuilderDestinationForm(destination = x) }
    }

    def jsObjectOrderBuilderDestinationForm(obj: io.flow.experience.v0.models.OrderBuilderDestinationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "destination" -> jsObjectOrderAddress(obj.destination)
      )
    }

    implicit def jsonWritesExperienceOrderBuilderDestinationForm: play.api.libs.json.Writes[OrderBuilderDestinationForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderBuilderDestinationForm] {
        def writes(obj: io.flow.experience.v0.models.OrderBuilderDestinationForm) = {
          jsObjectOrderBuilderDestinationForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderDestinationPutForm: play.api.libs.json.Reads[OrderDestinationPutForm] = {
      (__ \ "destination").read[io.flow.experience.v0.models.OrderAddress].map { x => new OrderDestinationPutForm(destination = x) }
    }

    def jsObjectOrderDestinationPutForm(obj: io.flow.experience.v0.models.OrderDestinationPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "destination" -> jsObjectOrderAddress(obj.destination)
      )
    }

    implicit def jsonWritesExperienceOrderDestinationPutForm: play.api.libs.json.Writes[OrderDestinationPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderDestinationPutForm] {
        def writes(obj: io.flow.experience.v0.models.OrderDestinationPutForm) = {
          jsObjectOrderDestinationPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderError: play.api.libs.json.Reads[OrderError] = {
      for {
        code <- (__ \ "code").read[io.flow.experience.v0.models.OrderErrorCode]
        messages <- (__ \ "messages").read[Seq[String]]
        numbers <- (__ \ "numbers").readNullable[Seq[String]]
        destinationCountry <- (__ \ "destination_country").readNullable[io.flow.reference.v0.models.Country]
        threshold <- (__ \ "threshold").readNullable[io.flow.experience.v0.models.ValueThresholdExceededDetails]
      } yield OrderError(code, messages, numbers, destinationCountry, threshold)
    }

    def jsObjectOrderError(obj: io.flow.experience.v0.models.OrderError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages)
      ) ++ (obj.numbers match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("numbers" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.destinationCountry match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination_country" -> io.flow.reference.v0.models.json.jsObjectCountry(x))
      }) ++
      (obj.threshold match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("threshold" -> jsObjectValueThresholdExceededDetails(x))
      })
    }

    implicit def jsonWritesExperienceOrderError: play.api.libs.json.Writes[OrderError] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderError] {
        def writes(obj: io.flow.experience.v0.models.OrderError) = {
          jsObjectOrderError(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderEstimate: play.api.libs.json.Reads[OrderEstimate] = {
      for {
        id <- (__ \ "id").read[String]
        items <- (__ \ "items").read[Seq[io.flow.experience.v0.models.LocalizedLineItem]]
        destination <- (__ \ "destination").read[io.flow.experience.v0.models.OrderAddress]
        deliveries <- (__ \ "deliveries").read[Seq[io.flow.fulfillment.v0.models.Delivery]]
        prices <- (__ \ "prices").read[Seq[io.flow.experience.v0.models.OrderPriceDetail]]
        selections <- (__ \ "selections").read[Seq[String]]
        total <- (__ \ "total").read[io.flow.catalog.v0.models.LocalizedTotal]
        lines <- (__ \ "lines").readNullable[Seq[io.flow.experience.v0.models.Line]]
        promotions <- (__ \ "promotions").readNullable[io.flow.experience.v0.models.Promotions]
      } yield OrderEstimate(id, items, destination, deliveries, prices, selections, total, lines, promotions)
    }

    def jsObjectOrderEstimate(obj: io.flow.experience.v0.models.OrderEstimate): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "items" -> play.api.libs.json.Json.toJson(obj.items),
        "destination" -> jsObjectOrderAddress(obj.destination),
        "deliveries" -> play.api.libs.json.Json.toJson(obj.deliveries),
        "prices" -> play.api.libs.json.Json.toJson(obj.prices),
        "selections" -> play.api.libs.json.Json.toJson(obj.selections),
        "total" -> io.flow.catalog.v0.models.json.jsObjectLocalizedTotal(obj.total)
      ) ++ (obj.lines match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("lines" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.promotions match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("promotions" -> jsObjectPromotions(x))
      })
    }

    implicit def jsonWritesExperienceOrderEstimate: play.api.libs.json.Writes[OrderEstimate] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderEstimate] {
        def writes(obj: io.flow.experience.v0.models.OrderEstimate) = {
          jsObjectOrderEstimate(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderEstimateForm: play.api.libs.json.Reads[OrderEstimateForm] = {
      for {
        items <- (__ \ "items").read[Seq[io.flow.common.v0.models.LineItemForm]]
        destination <- (__ \ "destination").readNullable[io.flow.experience.v0.models.OrderAddress]
        selections <- (__ \ "selections").readNullable[Seq[String]]
      } yield OrderEstimateForm(items, destination, selections)
    }

    def jsObjectOrderEstimateForm(obj: io.flow.experience.v0.models.OrderEstimateForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> jsObjectOrderAddress(x))
      }) ++
      (obj.selections match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("selections" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceOrderEstimateForm: play.api.libs.json.Writes[OrderEstimateForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderEstimateForm] {
        def writes(obj: io.flow.experience.v0.models.OrderEstimateForm) = {
          jsObjectOrderEstimateForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderForm: play.api.libs.json.Reads[OrderForm] = {
      for {
        customer <- (__ \ "customer").readNullable[io.flow.common.v0.models.OrderCustomerForm]
        items <- (__ \ "items").read[Seq[io.flow.common.v0.models.LineItemForm]]
        deliveredDuty <- (__ \ "delivered_duty").readNullable[io.flow.common.v0.models.DeliveredDuty]
        number <- (__ \ "number").readNullable[String]
        destination <- (__ \ "destination").readNullable[io.flow.experience.v0.models.OrderAddress]
        discount <- (__ \ "discount").readNullable[io.flow.common.v0.models.Money]
        discounts <- (__ \ "discounts").readNullable[io.flow.common.v0.models.DiscountsForm]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        authorizationKeys <- (__ \ "authorization_keys").readNullable[Seq[String]]
      } yield OrderForm(customer, items, deliveredDuty, number, destination, discount, discounts, attributes, authorizationKeys)
    }

    def jsObjectOrderForm(obj: io.flow.experience.v0.models.OrderForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.customer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("customer" -> io.flow.common.v0.models.json.jsObjectOrderCustomerForm(x))
      }) ++
      (obj.deliveredDuty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("delivered_duty" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> jsObjectOrderAddress(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.discounts match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discounts" -> io.flow.common.v0.models.json.jsObjectDiscountsForm(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.authorizationKeys match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("authorization_keys" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceOrderForm: play.api.libs.json.Writes[OrderForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderForm] {
        def writes(obj: io.flow.experience.v0.models.OrderForm) = {
          jsObjectOrderForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderGeo: play.api.libs.json.Reads[OrderGeo] = {
      for {
        ip <- (__ \ "ip").readNullable[String]
        country <- (__ \ "country").read[String]
        currency <- (__ \ "currency").readNullable[String]
        language <- (__ \ "language").readNullable[String]
      } yield OrderGeo(ip, country, currency, language)
    }

    def jsObjectOrderGeo(obj: io.flow.experience.v0.models.OrderGeo): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "country" -> play.api.libs.json.JsString(obj.country)
      ) ++ (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.language match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("language" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceOrderGeo: play.api.libs.json.Writes[OrderGeo] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderGeo] {
        def writes(obj: io.flow.experience.v0.models.OrderGeo) = {
          jsObjectOrderGeo(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderIdentifier: play.api.libs.json.Reads[OrderIdentifier] = {
      for {
        id <- (__ \ "id").read[String]
        order <- (__ \ "order").read[io.flow.experience.v0.models.OrderReference]
        identifier <- (__ \ "identifier").read[String]
        primary <- (__ \ "primary").read[Boolean]
        number <- (__ \ "number").readNullable[String]
      } yield OrderIdentifier(id, order, identifier, primary, number)
    }

    def jsObjectOrderIdentifier(obj: io.flow.experience.v0.models.OrderIdentifier): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "order" -> jsObjectOrderReference(obj.order),
        "identifier" -> play.api.libs.json.JsString(obj.identifier),
        "primary" -> play.api.libs.json.JsBoolean(obj.primary)
      ) ++ (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceOrderIdentifier: play.api.libs.json.Writes[OrderIdentifier] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderIdentifier] {
        def writes(obj: io.flow.experience.v0.models.OrderIdentifier) = {
          jsObjectOrderIdentifier(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderIdentifierForm: play.api.libs.json.Reads[OrderIdentifierForm] = {
      for {
        order <- (__ \ "order").read[String]
        identifier <- (__ \ "identifier").readNullable[String]
        number <- (__ \ "number").readNullable[String]
        primary <- (__ \ "primary").readNullable[Boolean]
      } yield OrderIdentifierForm(order, identifier, number, primary)
    }

    def jsObjectOrderIdentifierForm(obj: io.flow.experience.v0.models.OrderIdentifierForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order" -> play.api.libs.json.JsString(obj.order)
      ) ++ (obj.identifier match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("identifier" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.primary match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("primary" -> play.api.libs.json.JsBoolean(x))
      })
    }

    implicit def jsonWritesExperienceOrderIdentifierForm: play.api.libs.json.Writes[OrderIdentifierForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderIdentifierForm] {
        def writes(obj: io.flow.experience.v0.models.OrderIdentifierForm) = {
          jsObjectOrderIdentifierForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderIdentifierPutForm: play.api.libs.json.Reads[OrderIdentifierPutForm] = {
      for {
        order <- (__ \ "order").read[String]
        primary <- (__ \ "primary").readNullable[Boolean]
      } yield OrderIdentifierPutForm(order, primary)
    }

    def jsObjectOrderIdentifierPutForm(obj: io.flow.experience.v0.models.OrderIdentifierPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order" -> play.api.libs.json.JsString(obj.order)
      ) ++ (obj.primary match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("primary" -> play.api.libs.json.JsBoolean(x))
      })
    }

    implicit def jsonWritesExperienceOrderIdentifierPutForm: play.api.libs.json.Writes[OrderIdentifierPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderIdentifierPutForm] {
        def writes(obj: io.flow.experience.v0.models.OrderIdentifierPutForm) = {
          jsObjectOrderIdentifierPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderIdentifierVersion: play.api.libs.json.Reads[OrderIdentifierVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        orderIdentifier <- (__ \ "order_identifier").read[io.flow.experience.v0.models.OrderIdentifier]
      } yield OrderIdentifierVersion(id, timestamp, `type`, orderIdentifier)
    }

    def jsObjectOrderIdentifierVersion(obj: io.flow.experience.v0.models.OrderIdentifierVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "order_identifier" -> jsObjectOrderIdentifier(obj.orderIdentifier)
      )
    }

    implicit def jsonWritesExperienceOrderIdentifierVersion: play.api.libs.json.Writes[OrderIdentifierVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderIdentifierVersion] {
        def writes(obj: io.flow.experience.v0.models.OrderIdentifierVersion) = {
          jsObjectOrderIdentifierVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderNumberGeneratorDefaults: play.api.libs.json.Reads[OrderNumberGeneratorDefaults] = {
      for {
        startsWith <- (__ \ "starts_with").read[Long]
        minHexLength <- (__ \ "min_hex_length").read[Int]
        minStartsWith <- (__ \ "min_starts_with").read[Long]
      } yield OrderNumberGeneratorDefaults(startsWith, minHexLength, minStartsWith)
    }

    def jsObjectOrderNumberGeneratorDefaults(obj: io.flow.experience.v0.models.OrderNumberGeneratorDefaults): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "starts_with" -> play.api.libs.json.JsNumber(obj.startsWith),
        "min_hex_length" -> play.api.libs.json.JsNumber(obj.minHexLength),
        "min_starts_with" -> play.api.libs.json.JsNumber(obj.minStartsWith)
      )
    }

    implicit def jsonWritesExperienceOrderNumberGeneratorDefaults: play.api.libs.json.Writes[OrderNumberGeneratorDefaults] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderNumberGeneratorDefaults] {
        def writes(obj: io.flow.experience.v0.models.OrderNumberGeneratorDefaults) = {
          jsObjectOrderNumberGeneratorDefaults(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderNumberGeneratorFixedLength: play.api.libs.json.Reads[OrderNumberGeneratorFixedLength] = {
      for {
        length <- (__ \ "length").read[Int]
        padding <- (__ \ "padding").read[String]
      } yield OrderNumberGeneratorFixedLength(length, padding)
    }

    def jsObjectOrderNumberGeneratorFixedLength(obj: io.flow.experience.v0.models.OrderNumberGeneratorFixedLength): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "length" -> play.api.libs.json.JsNumber(obj.length),
        "padding" -> play.api.libs.json.JsString(obj.padding)
      )
    }

    implicit def jsonWritesExperienceOrderNumberGeneratorFixedLength: play.api.libs.json.Writes[OrderNumberGeneratorFixedLength] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderNumberGeneratorFixedLength] {
        def writes(obj: io.flow.experience.v0.models.OrderNumberGeneratorFixedLength) = {
          jsObjectOrderNumberGeneratorFixedLength(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderNumberGeneratorHexadecimal: play.api.libs.json.Reads[OrderNumberGeneratorHexadecimal] = {
      (__ \ "length").read[Int].map { x => new OrderNumberGeneratorHexadecimal(length = x) }
    }

    def jsObjectOrderNumberGeneratorHexadecimal(obj: io.flow.experience.v0.models.OrderNumberGeneratorHexadecimal): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "length" -> play.api.libs.json.JsNumber(obj.length)
      )
    }

    implicit def jsonReadsExperienceOrderNumberGeneratorPrefixSuffix: play.api.libs.json.Reads[OrderNumberGeneratorPrefixSuffix] = {
      for {
        prefix <- (__ \ "prefix").readNullable[String]
        startsWith <- (__ \ "starts_with").readNullable[Long]
        suffix <- (__ \ "suffix").readNullable[String]
        fixedLength <- (__ \ "fixed_length").readNullable[io.flow.experience.v0.models.OrderNumberGeneratorFixedLength]
      } yield OrderNumberGeneratorPrefixSuffix(prefix, startsWith, suffix, fixedLength)
    }

    def jsObjectOrderNumberGeneratorPrefixSuffix(obj: io.flow.experience.v0.models.OrderNumberGeneratorPrefixSuffix): play.api.libs.json.JsObject = {
      (obj.prefix match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("prefix" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.startsWith match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("starts_with" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.suffix match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("suffix" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.fixedLength match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("fixed_length" -> jsObjectOrderNumberGeneratorFixedLength(x))
      })
    }

    implicit def jsonReadsExperienceOrderNumberGeneratorUuid: play.api.libs.json.Reads[OrderNumberGeneratorUuid] = {
      (__ \ "prefix").readWithDefault[String]("ord-").map { x => new OrderNumberGeneratorUuid(prefix = x) }
    }

    def jsObjectOrderNumberGeneratorUuid(obj: io.flow.experience.v0.models.OrderNumberGeneratorUuid): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "prefix" -> play.api.libs.json.JsString(obj.prefix)
      )
    }

    implicit def jsonReadsExperienceOrderNumberReference: play.api.libs.json.Reads[OrderNumberReference] = {
      (__ \ "number").read[String].map { x => new OrderNumberReference(number = x) }
    }

    def jsObjectOrderNumberReference(obj: io.flow.experience.v0.models.OrderNumberReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonWritesExperienceOrderNumberReference: play.api.libs.json.Writes[OrderNumberReference] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderNumberReference] {
        def writes(obj: io.flow.experience.v0.models.OrderNumberReference) = {
          jsObjectOrderNumberReference(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPayment: play.api.libs.json.Reads[OrderPayment] = {
      for {
        id <- (__ \ "id").read[String]
        `type` <- (__ \ "type").read[io.flow.experience.v0.models.OrderPaymentType]
        merchantOfRecord <- (__ \ "merchant_of_record").readWithDefault[io.flow.common.v0.models.MerchantOfRecord](io.flow.common.v0.models.MerchantOfRecord.Flow)
        reference <- (__ \ "reference").read[String]
        description <- (__ \ "description").read[String]
        total <- (__ \ "total").read[io.flow.common.v0.models.PriceWithBase]
        address <- (__ \ "address").readNullable[io.flow.common.v0.models.BillingAddress]
        date <- (__ \ "date").readNullable[_root_.org.joda.time.DateTime]
        attributes <- (__ \ "attributes").readWithDefault[Map[String, String]](Map.empty)
      } yield OrderPayment(id, `type`, merchantOfRecord, reference, description, total, address, date, attributes)
    }

    def jsObjectOrderPayment(obj: io.flow.experience.v0.models.OrderPayment): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "merchant_of_record" -> play.api.libs.json.JsString(obj.merchantOfRecord.toString),
        "reference" -> play.api.libs.json.JsString(obj.reference),
        "description" -> play.api.libs.json.JsString(obj.description),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      }) ++
      (obj.date match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("date" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      })
    }

    implicit def jsonWritesExperienceOrderPayment: play.api.libs.json.Writes[OrderPayment] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPayment] {
        def writes(obj: io.flow.experience.v0.models.OrderPayment) = {
          jsObjectOrderPayment(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPriceDetail: play.api.libs.json.Reads[OrderPriceDetail] = {
      for {
        key <- (__ \ "key").read[io.flow.experience.v0.models.OrderPriceDetailKey]
        currency <- (__ \ "currency").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        label <- (__ \ "label").read[String]
        base <- (__ \ "base").read[io.flow.common.v0.models.Price]
        components <- (__ \ "components").read[Seq[io.flow.experience.v0.models.OrderPriceDetailComponent]]
        name <- (__ \ "name").readNullable[String]
        rate <- (__ \ "rate").readNullable[BigDecimal]
        accuracy <- (__ \ "accuracy").readWithDefault[io.flow.price.v0.models.PriceAccuracy](io.flow.price.v0.models.PriceAccuracy.Calculated)
      } yield OrderPriceDetail(key, currency, amount, label, base, components, name, rate, accuracy)
    }

    def jsObjectOrderPriceDetail(obj: io.flow.experience.v0.models.OrderPriceDetail): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label),
        "base" -> io.flow.common.v0.models.json.jsObjectPrice(obj.base),
        "components" -> play.api.libs.json.Json.toJson(obj.components),
        "accuracy" -> play.api.libs.json.JsString(obj.accuracy.toString)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.rate match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("rate" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesExperienceOrderPriceDetail: play.api.libs.json.Writes[OrderPriceDetail] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPriceDetail] {
        def writes(obj: io.flow.experience.v0.models.OrderPriceDetail) = {
          jsObjectOrderPriceDetail(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPriceDetailComponent: play.api.libs.json.Reads[OrderPriceDetailComponent] = {
      for {
        key <- (__ \ "key").read[io.flow.experience.v0.models.OrderPriceDetailComponentKey]
        currency <- (__ \ "currency").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        label <- (__ \ "label").read[String]
        base <- (__ \ "base").read[io.flow.common.v0.models.Price]
        name <- (__ \ "name").readNullable[String]
      } yield OrderPriceDetailComponent(key, currency, amount, label, base, name)
    }

    def jsObjectOrderPriceDetailComponent(obj: io.flow.experience.v0.models.OrderPriceDetailComponent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label),
        "base" -> io.flow.common.v0.models.json.jsObjectPrice(obj.base)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceOrderPriceDetailComponent: play.api.libs.json.Writes[OrderPriceDetailComponent] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPriceDetailComponent] {
        def writes(obj: io.flow.experience.v0.models.OrderPriceDetailComponent) = {
          jsObjectOrderPriceDetailComponent(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPromotionTrigger: play.api.libs.json.Reads[OrderPromotionTrigger] = {
      for {
        `type` <- (__ \ "type").read[io.flow.experience.v0.models.PromotionTriggerType]
        min <- (__ \ "min").readNullable[io.flow.common.v0.models.Price]
      } yield OrderPromotionTrigger(`type`, min)
    }

    def jsObjectOrderPromotionTrigger(obj: io.flow.experience.v0.models.OrderPromotionTrigger): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      ) ++ (obj.min match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("min" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      })
    }

    implicit def jsonWritesExperienceOrderPromotionTrigger: play.api.libs.json.Writes[OrderPromotionTrigger] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPromotionTrigger] {
        def writes(obj: io.flow.experience.v0.models.OrderPromotionTrigger) = {
          jsObjectOrderPromotionTrigger(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPutForm: play.api.libs.json.Reads[OrderPutForm] = {
      for {
        items <- (__ \ "items").read[Seq[io.flow.common.v0.models.LineItemForm]]
        customer <- (__ \ "customer").readNullable[io.flow.common.v0.models.OrderCustomerForm]
        deliveredDuty <- (__ \ "delivered_duty").readNullable[io.flow.common.v0.models.DeliveredDuty]
        selections <- (__ \ "selections").readNullable[Seq[String]]
        destination <- (__ \ "destination").readNullable[io.flow.experience.v0.models.OrderAddress]
        discount <- (__ \ "discount").readNullable[io.flow.common.v0.models.Money]
        discounts <- (__ \ "discounts").readNullable[io.flow.common.v0.models.DiscountsForm]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        authorizationKeys <- (__ \ "authorization_keys").readNullable[Seq[String]]
      } yield OrderPutForm(items, customer, deliveredDuty, selections, destination, discount, discounts, attributes, authorizationKeys)
    }

    def jsObjectOrderPutForm(obj: io.flow.experience.v0.models.OrderPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.customer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("customer" -> io.flow.common.v0.models.json.jsObjectOrderCustomerForm(x))
      }) ++
      (obj.deliveredDuty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("delivered_duty" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.selections match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("selections" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> jsObjectOrderAddress(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.discounts match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discounts" -> io.flow.common.v0.models.json.jsObjectDiscountsForm(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.authorizationKeys match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("authorization_keys" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceOrderPutForm: play.api.libs.json.Writes[OrderPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPutForm] {
        def writes(obj: io.flow.experience.v0.models.OrderPutForm) = {
          jsObjectOrderPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderReference: play.api.libs.json.Reads[OrderReference] = {
      for {
        id <- (__ \ "id").read[String]
        number <- (__ \ "number").read[String]
      } yield OrderReference(id, number)
    }

    def jsObjectOrderReference(obj: io.flow.experience.v0.models.OrderReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonReadsExperienceOrderRuleReference: play.api.libs.json.Reads[OrderRuleReference] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
      } yield OrderRuleReference(id, key)
    }

    def jsObjectOrderRuleReference(obj: io.flow.experience.v0.models.OrderRuleReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesExperienceOrderRuleReference: play.api.libs.json.Writes[OrderRuleReference] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderRuleReference] {
        def writes(obj: io.flow.experience.v0.models.OrderRuleReference) = {
          jsObjectOrderRuleReference(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderRulesSummary: play.api.libs.json.Reads[OrderRulesSummary] = {
      (__ \ "applied").read[Seq[io.flow.experience.v0.models.OrderRuleReference]].map { x => new OrderRulesSummary(applied = x) }
    }

    def jsObjectOrderRulesSummary(obj: io.flow.experience.v0.models.OrderRulesSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "applied" -> play.api.libs.json.Json.toJson(obj.applied)
      )
    }

    implicit def jsonWritesExperienceOrderRulesSummary: play.api.libs.json.Writes[OrderRulesSummary] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderRulesSummary] {
        def writes(obj: io.flow.experience.v0.models.OrderRulesSummary) = {
          jsObjectOrderRulesSummary(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderVersion: play.api.libs.json.Reads[OrderVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        order <- (__ \ "order").read[io.flow.experience.v0.models.Order]
      } yield OrderVersion(id, timestamp, `type`, order)
    }

    def jsObjectOrderVersion(obj: io.flow.experience.v0.models.OrderVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "order" -> jsObjectOrder(obj.order)
      )
    }

    implicit def jsonWritesExperienceOrderVersion: play.api.libs.json.Writes[OrderVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderVersion] {
        def writes(obj: io.flow.experience.v0.models.OrderVersion) = {
          jsObjectOrderVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOriginalPrices: play.api.libs.json.Reads[OriginalPrices] = {
      for {
        value <- (__ \ "value").read[io.flow.common.v0.models.Price]
        max <- (__ \ "max").read[io.flow.common.v0.models.Price]
      } yield OriginalPrices(value, max)
    }

    def jsObjectOriginalPrices(obj: io.flow.experience.v0.models.OriginalPrices): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "value" -> io.flow.common.v0.models.json.jsObjectPrice(obj.value),
        "max" -> io.flow.common.v0.models.json.jsObjectPrice(obj.max)
      )
    }

    implicit def jsonWritesExperienceOriginalPrices: play.api.libs.json.Writes[OriginalPrices] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OriginalPrices] {
        def writes(obj: io.flow.experience.v0.models.OriginalPrices) = {
          jsObjectOriginalPrices(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePaymentMethodIssuer: play.api.libs.json.Reads[PaymentMethodIssuer] = {
      for {
        id <- (__ \ "id").read[String]
        name <- (__ \ "name").read[String]
      } yield PaymentMethodIssuer(id, name)
    }

    def jsObjectPaymentMethodIssuer(obj: io.flow.experience.v0.models.PaymentMethodIssuer): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name)
      )
    }

    implicit def jsonWritesExperiencePaymentMethodIssuer: play.api.libs.json.Writes[PaymentMethodIssuer] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PaymentMethodIssuer] {
        def writes(obj: io.flow.experience.v0.models.PaymentMethodIssuer) = {
          jsObjectPaymentMethodIssuer(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePaymentMethodRule: play.api.libs.json.Reads[PaymentMethodRule] = {
      for {
        tags <- (__ \ "tags").read[Seq[io.flow.experience.v0.models.PaymentMethodTag]]
        paymentMethod <- (__ \ "payment_method").read[io.flow.reference.v0.models.PaymentMethod]
        displayPosition <- (__ \ "display_position").read[Int]
        content <- (__ \ "content").readNullable[Seq[io.flow.experience.v0.models.PaymentMethodRuleContent]]
        issuers <- (__ \ "issuers").readNullable[Seq[io.flow.experience.v0.models.PaymentMethodIssuer]]
        programs <- (__ \ "programs").read[Seq[io.flow.experience.v0.models.InstallmentProgramSummary]]
      } yield PaymentMethodRule(tags, paymentMethod, displayPosition, content, issuers, programs)
    }

    def jsObjectPaymentMethodRule(obj: io.flow.experience.v0.models.PaymentMethodRule): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "tags" -> play.api.libs.json.Json.toJson(obj.tags),
        "payment_method" -> io.flow.reference.v0.models.json.jsObjectPaymentMethod(obj.paymentMethod),
        "display_position" -> play.api.libs.json.JsNumber(obj.displayPosition),
        "programs" -> play.api.libs.json.Json.toJson(obj.programs)
      ) ++ (obj.content match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("content" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.issuers match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("issuers" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperiencePaymentMethodRule: play.api.libs.json.Writes[PaymentMethodRule] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PaymentMethodRule] {
        def writes(obj: io.flow.experience.v0.models.PaymentMethodRule) = {
          jsObjectPaymentMethodRule(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePaymentMethodRuleContent: play.api.libs.json.Reads[PaymentMethodRuleContent] = {
      for {
        key <- (__ \ "key").read[io.flow.experience.v0.models.PaymentMethodRuleContentKey]
        value <- (__ \ "value").read[String]
      } yield PaymentMethodRuleContent(key, value)
    }

    def jsObjectPaymentMethodRuleContent(obj: io.flow.experience.v0.models.PaymentMethodRuleContent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "value" -> play.api.libs.json.JsString(obj.value)
      )
    }

    implicit def jsonWritesExperiencePaymentMethodRuleContent: play.api.libs.json.Writes[PaymentMethodRuleContent] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PaymentMethodRuleContent] {
        def writes(obj: io.flow.experience.v0.models.PaymentMethodRuleContent) = {
          jsObjectPaymentMethodRuleContent(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePricingSettings: play.api.libs.json.Reads[PricingSettings] = {
      for {
        editable <- (__ \ "editable").read[Boolean]
        defaultTaxDisplay <- (__ \ "default_tax_display").read[io.flow.price.v0.models.PricingLevySetting]
        defaultDutyDisplay <- (__ \ "default_duty_display").read[io.flow.price.v0.models.PricingLevySetting]
      } yield PricingSettings(editable, defaultTaxDisplay, defaultDutyDisplay)
    }

    def jsObjectPricingSettings(obj: io.flow.experience.v0.models.PricingSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "editable" -> play.api.libs.json.JsBoolean(obj.editable),
        "default_tax_display" -> play.api.libs.json.JsString(obj.defaultTaxDisplay.toString),
        "default_duty_display" -> play.api.libs.json.JsString(obj.defaultDutyDisplay.toString)
      )
    }

    implicit def jsonWritesExperiencePricingSettings: play.api.libs.json.Writes[PricingSettings] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PricingSettings] {
        def writes(obj: io.flow.experience.v0.models.PricingSettings) = {
          jsObjectPricingSettings(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePromotionTrigger: play.api.libs.json.Reads[PromotionTrigger] = {
      for {
        `type` <- (__ \ "type").read[io.flow.experience.v0.models.PromotionTriggerType]
        min <- (__ \ "min").read[io.flow.common.v0.models.Price]
        remaining <- (__ \ "remaining").read[io.flow.common.v0.models.Price]
      } yield PromotionTrigger(`type`, min, remaining)
    }

    def jsObjectPromotionTrigger(obj: io.flow.experience.v0.models.PromotionTrigger): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "min" -> io.flow.common.v0.models.json.jsObjectPrice(obj.min),
        "remaining" -> io.flow.common.v0.models.json.jsObjectPrice(obj.remaining)
      )
    }

    implicit def jsonWritesExperiencePromotionTrigger: play.api.libs.json.Writes[PromotionTrigger] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PromotionTrigger] {
        def writes(obj: io.flow.experience.v0.models.PromotionTrigger) = {
          jsObjectPromotionTrigger(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePromotionTriggerForm: play.api.libs.json.Reads[PromotionTriggerForm] = {
      for {
        `type` <- (__ \ "type").read[io.flow.experience.v0.models.PromotionTriggerType]
        min <- (__ \ "min").readNullable[io.flow.common.v0.models.PriceForm]
      } yield PromotionTriggerForm(`type`, min)
    }

    def jsObjectPromotionTriggerForm(obj: io.flow.experience.v0.models.PromotionTriggerForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      ) ++ (obj.min match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("min" -> io.flow.common.v0.models.json.jsObjectPriceForm(x))
      })
    }

    implicit def jsonWritesExperiencePromotionTriggerForm: play.api.libs.json.Writes[PromotionTriggerForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PromotionTriggerForm] {
        def writes(obj: io.flow.experience.v0.models.PromotionTriggerForm) = {
          jsObjectPromotionTriggerForm(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePromotions: play.api.libs.json.Reads[Promotions] = {
      for {
        applied <- (__ \ "applied").read[Seq[io.flow.experience.v0.models.Promotion]]
        available <- (__ \ "available").read[Seq[io.flow.experience.v0.models.Promotion]]
      } yield Promotions(applied, available)
    }

    def jsObjectPromotions(obj: io.flow.experience.v0.models.Promotions): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "applied" -> play.api.libs.json.Json.toJson(obj.applied),
        "available" -> play.api.libs.json.Json.toJson(obj.available)
      )
    }

    implicit def jsonWritesExperiencePromotions: play.api.libs.json.Writes[Promotions] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Promotions] {
        def writes(obj: io.flow.experience.v0.models.Promotions) = {
          jsObjectPromotions(obj)
        }
      }
    }

    implicit def jsonReadsExperienceRegionReference: play.api.libs.json.Reads[RegionReference] = {
      (__ \ "id").read[String].map { x => new RegionReference(id = x) }
    }

    def jsObjectRegionReference(obj: io.flow.experience.v0.models.RegionReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesExperienceRegionReference: play.api.libs.json.Writes[RegionReference] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.RegionReference] {
        def writes(obj: io.flow.experience.v0.models.RegionReference) = {
          jsObjectRegionReference(obj)
        }
      }
    }

    implicit def jsonReadsExperienceValueThresholdExceededDetails: play.api.libs.json.Reads[ValueThresholdExceededDetails] = {
      for {
        local <- (__ \ "local").read[io.flow.common.v0.models.Price]
        original <- (__ \ "original").read[io.flow.common.v0.models.Price]
      } yield ValueThresholdExceededDetails(local, original)
    }

    def jsObjectValueThresholdExceededDetails(obj: io.flow.experience.v0.models.ValueThresholdExceededDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "local" -> io.flow.common.v0.models.json.jsObjectPrice(obj.local),
        "original" -> io.flow.common.v0.models.json.jsObjectPrice(obj.original)
      )
    }

    implicit def jsonWritesExperienceValueThresholdExceededDetails: play.api.libs.json.Writes[ValueThresholdExceededDetails] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ValueThresholdExceededDetails] {
        def writes(obj: io.flow.experience.v0.models.ValueThresholdExceededDetails) = {
          jsObjectValueThresholdExceededDetails(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationComponent: play.api.libs.json.Reads[AllocationComponent] = new play.api.libs.json.Reads[AllocationComponent] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[AllocationComponent] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[AllocationComponent] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "allocation_detail_component" => js.validate[io.flow.experience.v0.models.AllocationDetailComponent]
          case "allocation_levy_component" => js.validate[io.flow.experience.v0.models.AllocationLevyComponent]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.AllocationComponentUndefinedType(other))
        }
      }
    }

    def jsObjectAllocationComponent(obj: io.flow.experience.v0.models.AllocationComponent): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.AllocationDetailComponent => jsObjectAllocationDetailComponent(x) ++ play.api.libs.json.Json.obj("discriminator" -> "allocation_detail_component")
        case x: io.flow.experience.v0.models.AllocationLevyComponent => jsObjectAllocationLevyComponent(x) ++ play.api.libs.json.Json.obj("discriminator" -> "allocation_levy_component")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceAllocationComponent: play.api.libs.json.Writes[AllocationComponent] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationComponent] {
        def writes(obj: io.flow.experience.v0.models.AllocationComponent) = {
          jsObjectAllocationComponent(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationDetail: play.api.libs.json.Reads[AllocationDetail] = new play.api.libs.json.Reads[AllocationDetail] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[AllocationDetail] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[AllocationDetail] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "allocation_line_detail" => js.validate[io.flow.experience.v0.models.AllocationLineDetail]
          case "allocation_order_detail" => js.validate[io.flow.experience.v0.models.AllocationOrderDetail]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.AllocationDetailUndefinedType(other))
        }
      }
    }

    def jsObjectAllocationDetail(obj: io.flow.experience.v0.models.AllocationDetail): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.AllocationLineDetail => jsObjectAllocationLineDetail(x) ++ play.api.libs.json.Json.obj("discriminator" -> "allocation_line_detail")
        case x: io.flow.experience.v0.models.AllocationOrderDetail => jsObjectAllocationOrderDetail(x) ++ play.api.libs.json.Json.obj("discriminator" -> "allocation_order_detail")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceAllocationDetail: play.api.libs.json.Writes[AllocationDetail] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationDetail] {
        def writes(obj: io.flow.experience.v0.models.AllocationDetail) = {
          jsObjectAllocationDetail(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExpandableExperience: play.api.libs.json.Reads[ExpandableExperience] = new play.api.libs.json.Reads[ExpandableExperience] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ExpandableExperience] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[ExpandableExperience] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "experience" => js.validate[io.flow.experience.v0.models.Experience]
          case "experience_reference" => js.validate[io.flow.experience.v0.models.ExperienceReference]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExpandableExperienceUndefinedType(other))
        }
      }
    }

    def jsObjectExpandableExperience(obj: io.flow.experience.v0.models.ExpandableExperience): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.Experience => jsObjectExperience(x) ++ play.api.libs.json.Json.obj("discriminator" -> "experience")
        case x: io.flow.experience.v0.models.ExperienceReference => jsObjectExperienceReference(x) ++ play.api.libs.json.Json.obj("discriminator" -> "experience_reference")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceExpandableExperience: play.api.libs.json.Writes[ExpandableExperience] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExpandableExperience] {
        def writes(obj: io.flow.experience.v0.models.ExpandableExperience) = {
          jsObjectExpandableExperience(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExpandableOrder: play.api.libs.json.Reads[ExpandableOrder] = new play.api.libs.json.Reads[ExpandableOrder] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ExpandableOrder] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[ExpandableOrder] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "order" => js.validate[io.flow.experience.v0.models.Order]
          case "order_reference" => js.validate[io.flow.experience.v0.models.OrderReference]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExpandableOrderUndefinedType(other))
        }
      }
    }

    def jsObjectExpandableOrder(obj: io.flow.experience.v0.models.ExpandableOrder): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.Order => jsObjectOrder(x) ++ play.api.libs.json.Json.obj("discriminator" -> "order")
        case x: io.flow.experience.v0.models.OrderReference => jsObjectOrderReference(x) ++ play.api.libs.json.Json.obj("discriminator" -> "order_reference")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceExpandableOrder: play.api.libs.json.Writes[ExpandableOrder] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExpandableOrder] {
        def writes(obj: io.flow.experience.v0.models.ExpandableOrder) = {
          jsObjectExpandableOrder(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderNumberGenerator: play.api.libs.json.Reads[OrderNumberGenerator] = new play.api.libs.json.Reads[OrderNumberGenerator] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[OrderNumberGenerator] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[OrderNumberGenerator] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "uuid" => js.validate[io.flow.experience.v0.models.OrderNumberGeneratorUuid]
          case "hexadecimal" => js.validate[io.flow.experience.v0.models.OrderNumberGeneratorHexadecimal]
          case "prefix_suffix" => js.validate[io.flow.experience.v0.models.OrderNumberGeneratorPrefixSuffix]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderNumberGeneratorUndefinedType(other))
        }
      }
    }

    def jsObjectOrderNumberGenerator(obj: io.flow.experience.v0.models.OrderNumberGenerator): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.OrderNumberGeneratorUuid => jsObjectOrderNumberGeneratorUuid(x) ++ play.api.libs.json.Json.obj("discriminator" -> "uuid")
        case x: io.flow.experience.v0.models.OrderNumberGeneratorHexadecimal => jsObjectOrderNumberGeneratorHexadecimal(x) ++ play.api.libs.json.Json.obj("discriminator" -> "hexadecimal")
        case x: io.flow.experience.v0.models.OrderNumberGeneratorPrefixSuffix => jsObjectOrderNumberGeneratorPrefixSuffix(x) ++ play.api.libs.json.Json.obj("discriminator" -> "prefix_suffix")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceOrderNumberGenerator: play.api.libs.json.Writes[OrderNumberGenerator] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderNumberGenerator] {
        def writes(obj: io.flow.experience.v0.models.OrderNumberGenerator) = {
          jsObjectOrderNumberGenerator(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPromotion: play.api.libs.json.Reads[OrderPromotion] = new play.api.libs.json.Reads[OrderPromotion] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[OrderPromotion] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[OrderPromotion] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "free_shipping_order_promotion" => js.validate[io.flow.experience.v0.models.FreeShippingOrderPromotion]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPromotionUndefinedType(other))
        }
      }
    }

    def jsObjectOrderPromotion(obj: io.flow.experience.v0.models.OrderPromotion): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.FreeShippingOrderPromotion => jsObjectFreeShippingOrderPromotion(x) ++ play.api.libs.json.Json.obj("discriminator" -> "free_shipping_order_promotion")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceOrderPromotion: play.api.libs.json.Writes[OrderPromotion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPromotion] {
        def writes(obj: io.flow.experience.v0.models.OrderPromotion) = {
          jsObjectOrderPromotion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPromotionForm: play.api.libs.json.Reads[OrderPromotionForm] = new play.api.libs.json.Reads[OrderPromotionForm] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[OrderPromotionForm] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[OrderPromotionForm] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "free_shipping_order_promotion_form" => js.validate[io.flow.experience.v0.models.FreeShippingOrderPromotionForm]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPromotionFormUndefinedType(other))
        }
      }
    }

    def jsObjectOrderPromotionForm(obj: io.flow.experience.v0.models.OrderPromotionForm): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.FreeShippingOrderPromotionForm => jsObjectFreeShippingOrderPromotionForm(x) ++ play.api.libs.json.Json.obj("discriminator" -> "free_shipping_order_promotion_form")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceOrderPromotionForm: play.api.libs.json.Writes[OrderPromotionForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPromotionForm] {
        def writes(obj: io.flow.experience.v0.models.OrderPromotionForm) = {
          jsObjectOrderPromotionForm(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePaymentMethodTag: play.api.libs.json.Reads[PaymentMethodTag] = new play.api.libs.json.Reads[PaymentMethodTag] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[PaymentMethodTag] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[PaymentMethodTag] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "organization_payment_method_tag" => js.validate[io.flow.experience.v0.models.OrganizationPaymentMethodTag]
          case "experience_payment_method_tag" => js.validate[io.flow.experience.v0.models.ExperiencePaymentMethodTag]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PaymentMethodTagUndefinedType(other))
        }
      }
    }

    def jsObjectPaymentMethodTag(obj: io.flow.experience.v0.models.PaymentMethodTag): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.OrganizationPaymentMethodTag => play.api.libs.json.Json.obj("discriminator" -> "organization_payment_method_tag", "value" -> play.api.libs.json.JsString(x.toString))
        case x: io.flow.experience.v0.models.ExperiencePaymentMethodTag => play.api.libs.json.Json.obj("discriminator" -> "experience_payment_method_tag", "value" -> play.api.libs.json.JsString(x.toString))
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperiencePaymentMethodTag: play.api.libs.json.Writes[PaymentMethodTag] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PaymentMethodTag] {
        def writes(obj: io.flow.experience.v0.models.PaymentMethodTag) = {
          jsObjectPaymentMethodTag(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePromotion: play.api.libs.json.Reads[Promotion] = new play.api.libs.json.Reads[Promotion] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[Promotion] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[Promotion] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "free_shipping" => js.validate[io.flow.experience.v0.models.FreeShipping]
          case "discount" => js.validate[io.flow.experience.v0.models.Discount]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PromotionUndefinedType(other))
        }
      }
    }

    def jsObjectPromotion(obj: io.flow.experience.v0.models.Promotion): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.FreeShipping => jsObjectFreeShipping(x) ++ play.api.libs.json.Json.obj("discriminator" -> "free_shipping")
        case x: io.flow.experience.v0.models.Discount => jsObjectDiscount(x) ++ play.api.libs.json.Json.obj("discriminator" -> "discount")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperiencePromotion: play.api.libs.json.Writes[Promotion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Promotion] {
        def writes(obj: io.flow.experience.v0.models.Promotion) = {
          jsObjectPromotion(obj)
        }
      }
    }
  }
}

package io.flow.experience.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}

    // import models directly for backwards compatibility with prior versions of the generator
    import Core._
    import Models._

    object Core {
      implicit def pathBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.DateTime] = ApibuilderPathBindable(ApibuilderTypes.dateTimeIso8601)
      implicit def queryStringBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.DateTime] = ApibuilderQueryStringBindable(ApibuilderTypes.dateTimeIso8601)

      implicit def pathBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.LocalDate] = ApibuilderPathBindable(ApibuilderTypes.dateIso8601)
      implicit def queryStringBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.LocalDate] = ApibuilderQueryStringBindable(ApibuilderTypes.dateIso8601)
    }

    object Models {
      import io.flow.experience.v0.models._

      val creditPaymentErrorCodeConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.CreditPaymentErrorCode] = new ApibuilderTypeConverter[io.flow.experience.v0.models.CreditPaymentErrorCode] {
        override def convert(value: String): io.flow.experience.v0.models.CreditPaymentErrorCode = io.flow.experience.v0.models.CreditPaymentErrorCode(value)
        override def convert(value: io.flow.experience.v0.models.CreditPaymentErrorCode): String = value.toString
        override def example: io.flow.experience.v0.models.CreditPaymentErrorCode = io.flow.experience.v0.models.CreditPaymentErrorCode.GenericError
        override def validValues: Seq[io.flow.experience.v0.models.CreditPaymentErrorCode] = io.flow.experience.v0.models.CreditPaymentErrorCode.all
      }
      implicit def pathBindableCreditPaymentErrorCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.CreditPaymentErrorCode] = ApibuilderPathBindable(creditPaymentErrorCodeConverter)
      implicit def queryStringBindableCreditPaymentErrorCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.CreditPaymentErrorCode] = ApibuilderQueryStringBindable(creditPaymentErrorCodeConverter)

      val deliveredDutyDisplayTypeConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.DeliveredDutyDisplayType] = new ApibuilderTypeConverter[io.flow.experience.v0.models.DeliveredDutyDisplayType] {
        override def convert(value: String): io.flow.experience.v0.models.DeliveredDutyDisplayType = io.flow.experience.v0.models.DeliveredDutyDisplayType(value)
        override def convert(value: io.flow.experience.v0.models.DeliveredDutyDisplayType): String = value.toString
        override def example: io.flow.experience.v0.models.DeliveredDutyDisplayType = io.flow.experience.v0.models.DeliveredDutyDisplayType.All
        override def validValues: Seq[io.flow.experience.v0.models.DeliveredDutyDisplayType] = io.flow.experience.v0.models.DeliveredDutyDisplayType.all
      }
      implicit def pathBindableDeliveredDutyDisplayType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.DeliveredDutyDisplayType] = ApibuilderPathBindable(deliveredDutyDisplayTypeConverter)
      implicit def queryStringBindableDeliveredDutyDisplayType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.DeliveredDutyDisplayType] = ApibuilderQueryStringBindable(deliveredDutyDisplayTypeConverter)

      val experienceCloneStatusConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.ExperienceCloneStatus] = new ApibuilderTypeConverter[io.flow.experience.v0.models.ExperienceCloneStatus] {
        override def convert(value: String): io.flow.experience.v0.models.ExperienceCloneStatus = io.flow.experience.v0.models.ExperienceCloneStatus(value)
        override def convert(value: io.flow.experience.v0.models.ExperienceCloneStatus): String = value.toString
        override def example: io.flow.experience.v0.models.ExperienceCloneStatus = io.flow.experience.v0.models.ExperienceCloneStatus.Pending
        override def validValues: Seq[io.flow.experience.v0.models.ExperienceCloneStatus] = io.flow.experience.v0.models.ExperienceCloneStatus.all
      }
      implicit def pathBindableExperienceCloneStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.ExperienceCloneStatus] = ApibuilderPathBindable(experienceCloneStatusConverter)
      implicit def queryStringBindableExperienceCloneStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.ExperienceCloneStatus] = ApibuilderQueryStringBindable(experienceCloneStatusConverter)

      val experiencePaymentMethodTagConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.ExperiencePaymentMethodTag] = new ApibuilderTypeConverter[io.flow.experience.v0.models.ExperiencePaymentMethodTag] {
        override def convert(value: String): io.flow.experience.v0.models.ExperiencePaymentMethodTag = io.flow.experience.v0.models.ExperiencePaymentMethodTag(value)
        override def convert(value: io.flow.experience.v0.models.ExperiencePaymentMethodTag): String = value.toString
        override def example: io.flow.experience.v0.models.ExperiencePaymentMethodTag = io.flow.experience.v0.models.ExperiencePaymentMethodTag.Display
        override def validValues: Seq[io.flow.experience.v0.models.ExperiencePaymentMethodTag] = io.flow.experience.v0.models.ExperiencePaymentMethodTag.all
      }
      implicit def pathBindableExperiencePaymentMethodTag(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.ExperiencePaymentMethodTag] = ApibuilderPathBindable(experiencePaymentMethodTagConverter)
      implicit def queryStringBindableExperiencePaymentMethodTag(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.ExperiencePaymentMethodTag] = ApibuilderQueryStringBindable(experiencePaymentMethodTagConverter)

      val experienceStatusConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.ExperienceStatus] = new ApibuilderTypeConverter[io.flow.experience.v0.models.ExperienceStatus] {
        override def convert(value: String): io.flow.experience.v0.models.ExperienceStatus = io.flow.experience.v0.models.ExperienceStatus(value)
        override def convert(value: io.flow.experience.v0.models.ExperienceStatus): String = value.toString
        override def example: io.flow.experience.v0.models.ExperienceStatus = io.flow.experience.v0.models.ExperienceStatus.Draft
        override def validValues: Seq[io.flow.experience.v0.models.ExperienceStatus] = io.flow.experience.v0.models.ExperienceStatus.all
      }
      implicit def pathBindableExperienceStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.ExperienceStatus] = ApibuilderPathBindable(experienceStatusConverter)
      implicit def queryStringBindableExperienceStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.ExperienceStatus] = ApibuilderQueryStringBindable(experienceStatusConverter)

      val installmentPlanPaymentErrorCodeConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode] = new ApibuilderTypeConverter[io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode] {
        override def convert(value: String): io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode = io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode(value)
        override def convert(value: io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode): String = value.toString
        override def example: io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode = io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode.InvalidAuthorization
        override def validValues: Seq[io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode] = io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode.all
      }
      implicit def pathBindableInstallmentPlanPaymentErrorCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode] = ApibuilderPathBindable(installmentPlanPaymentErrorCodeConverter)
      implicit def queryStringBindableInstallmentPlanPaymentErrorCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.InstallmentPlanPaymentErrorCode] = ApibuilderQueryStringBindable(installmentPlanPaymentErrorCodeConverter)

      val orderErrorCodeConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.OrderErrorCode] = new ApibuilderTypeConverter[io.flow.experience.v0.models.OrderErrorCode] {
        override def convert(value: String): io.flow.experience.v0.models.OrderErrorCode = io.flow.experience.v0.models.OrderErrorCode(value)
        override def convert(value: io.flow.experience.v0.models.OrderErrorCode): String = value.toString
        override def example: io.flow.experience.v0.models.OrderErrorCode = io.flow.experience.v0.models.OrderErrorCode.GenericError
        override def validValues: Seq[io.flow.experience.v0.models.OrderErrorCode] = io.flow.experience.v0.models.OrderErrorCode.all
      }
      implicit def pathBindableOrderErrorCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.OrderErrorCode] = ApibuilderPathBindable(orderErrorCodeConverter)
      implicit def queryStringBindableOrderErrorCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.OrderErrorCode] = ApibuilderQueryStringBindable(orderErrorCodeConverter)

      val orderPaymentTypeConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.OrderPaymentType] = new ApibuilderTypeConverter[io.flow.experience.v0.models.OrderPaymentType] {
        override def convert(value: String): io.flow.experience.v0.models.OrderPaymentType = io.flow.experience.v0.models.OrderPaymentType(value)
        override def convert(value: io.flow.experience.v0.models.OrderPaymentType): String = value.toString
        override def example: io.flow.experience.v0.models.OrderPaymentType = io.flow.experience.v0.models.OrderPaymentType.Card
        override def validValues: Seq[io.flow.experience.v0.models.OrderPaymentType] = io.flow.experience.v0.models.OrderPaymentType.all
      }
      implicit def pathBindableOrderPaymentType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.OrderPaymentType] = ApibuilderPathBindable(orderPaymentTypeConverter)
      implicit def queryStringBindableOrderPaymentType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.OrderPaymentType] = ApibuilderQueryStringBindable(orderPaymentTypeConverter)

      val orderPriceDetailComponentKeyConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.OrderPriceDetailComponentKey] = new ApibuilderTypeConverter[io.flow.experience.v0.models.OrderPriceDetailComponentKey] {
        override def convert(value: String): io.flow.experience.v0.models.OrderPriceDetailComponentKey = io.flow.experience.v0.models.OrderPriceDetailComponentKey(value)
        override def convert(value: io.flow.experience.v0.models.OrderPriceDetailComponentKey): String = value.toString
        override def example: io.flow.experience.v0.models.OrderPriceDetailComponentKey = io.flow.experience.v0.models.OrderPriceDetailComponentKey.Adjustment
        override def validValues: Seq[io.flow.experience.v0.models.OrderPriceDetailComponentKey] = io.flow.experience.v0.models.OrderPriceDetailComponentKey.all
      }
      implicit def pathBindableOrderPriceDetailComponentKey(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.OrderPriceDetailComponentKey] = ApibuilderPathBindable(orderPriceDetailComponentKeyConverter)
      implicit def queryStringBindableOrderPriceDetailComponentKey(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.OrderPriceDetailComponentKey] = ApibuilderQueryStringBindable(orderPriceDetailComponentKeyConverter)

      val orderPriceDetailKeyConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.OrderPriceDetailKey] = new ApibuilderTypeConverter[io.flow.experience.v0.models.OrderPriceDetailKey] {
        override def convert(value: String): io.flow.experience.v0.models.OrderPriceDetailKey = io.flow.experience.v0.models.OrderPriceDetailKey(value)
        override def convert(value: io.flow.experience.v0.models.OrderPriceDetailKey): String = value.toString
        override def example: io.flow.experience.v0.models.OrderPriceDetailKey = io.flow.experience.v0.models.OrderPriceDetailKey.Adjustment
        override def validValues: Seq[io.flow.experience.v0.models.OrderPriceDetailKey] = io.flow.experience.v0.models.OrderPriceDetailKey.all
      }
      implicit def pathBindableOrderPriceDetailKey(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.OrderPriceDetailKey] = ApibuilderPathBindable(orderPriceDetailKeyConverter)
      implicit def queryStringBindableOrderPriceDetailKey(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.OrderPriceDetailKey] = ApibuilderQueryStringBindable(orderPriceDetailKeyConverter)

      val orderStatusConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.OrderStatus] = new ApibuilderTypeConverter[io.flow.experience.v0.models.OrderStatus] {
        override def convert(value: String): io.flow.experience.v0.models.OrderStatus = io.flow.experience.v0.models.OrderStatus(value)
        override def convert(value: io.flow.experience.v0.models.OrderStatus): String = value.toString
        override def example: io.flow.experience.v0.models.OrderStatus = io.flow.experience.v0.models.OrderStatus.Open
        override def validValues: Seq[io.flow.experience.v0.models.OrderStatus] = io.flow.experience.v0.models.OrderStatus.all
      }
      implicit def pathBindableOrderStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.OrderStatus] = ApibuilderPathBindable(orderStatusConverter)
      implicit def queryStringBindableOrderStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.OrderStatus] = ApibuilderQueryStringBindable(orderStatusConverter)

      val organizationPaymentMethodTagConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.OrganizationPaymentMethodTag] = new ApibuilderTypeConverter[io.flow.experience.v0.models.OrganizationPaymentMethodTag] {
        override def convert(value: String): io.flow.experience.v0.models.OrganizationPaymentMethodTag = io.flow.experience.v0.models.OrganizationPaymentMethodTag(value)
        override def convert(value: io.flow.experience.v0.models.OrganizationPaymentMethodTag): String = value.toString
        override def example: io.flow.experience.v0.models.OrganizationPaymentMethodTag = io.flow.experience.v0.models.OrganizationPaymentMethodTag.Deny
        override def validValues: Seq[io.flow.experience.v0.models.OrganizationPaymentMethodTag] = io.flow.experience.v0.models.OrganizationPaymentMethodTag.all
      }
      implicit def pathBindableOrganizationPaymentMethodTag(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.OrganizationPaymentMethodTag] = ApibuilderPathBindable(organizationPaymentMethodTagConverter)
      implicit def queryStringBindableOrganizationPaymentMethodTag(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.OrganizationPaymentMethodTag] = ApibuilderQueryStringBindable(organizationPaymentMethodTagConverter)

      val paymentMethodRuleContentKeyConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.PaymentMethodRuleContentKey] = new ApibuilderTypeConverter[io.flow.experience.v0.models.PaymentMethodRuleContentKey] {
        override def convert(value: String): io.flow.experience.v0.models.PaymentMethodRuleContentKey = io.flow.experience.v0.models.PaymentMethodRuleContentKey(value)
        override def convert(value: io.flow.experience.v0.models.PaymentMethodRuleContentKey): String = value.toString
        override def example: io.flow.experience.v0.models.PaymentMethodRuleContentKey = io.flow.experience.v0.models.PaymentMethodRuleContentKey.Description
        override def validValues: Seq[io.flow.experience.v0.models.PaymentMethodRuleContentKey] = io.flow.experience.v0.models.PaymentMethodRuleContentKey.all
      }
      implicit def pathBindablePaymentMethodRuleContentKey(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.PaymentMethodRuleContentKey] = ApibuilderPathBindable(paymentMethodRuleContentKeyConverter)
      implicit def queryStringBindablePaymentMethodRuleContentKey(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.PaymentMethodRuleContentKey] = ApibuilderQueryStringBindable(paymentMethodRuleContentKeyConverter)

      val promotionTriggerTypeConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.PromotionTriggerType] = new ApibuilderTypeConverter[io.flow.experience.v0.models.PromotionTriggerType] {
        override def convert(value: String): io.flow.experience.v0.models.PromotionTriggerType = io.flow.experience.v0.models.PromotionTriggerType(value)
        override def convert(value: io.flow.experience.v0.models.PromotionTriggerType): String = value.toString
        override def example: io.flow.experience.v0.models.PromotionTriggerType = io.flow.experience.v0.models.PromotionTriggerType.Automatic
        override def validValues: Seq[io.flow.experience.v0.models.PromotionTriggerType] = io.flow.experience.v0.models.PromotionTriggerType.all
      }
      implicit def pathBindablePromotionTriggerType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.PromotionTriggerType] = ApibuilderPathBindable(promotionTriggerTypeConverter)
      implicit def queryStringBindablePromotionTriggerType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.PromotionTriggerType] = ApibuilderQueryStringBindable(promotionTriggerTypeConverter)
    }

    trait ApibuilderTypeConverter[T] {

      def convert(value: String): T

      def convert(value: T): String

      def example: T

      def validValues: Seq[T] = Nil

      def errorMessage(key: String, value: String, ex: java.lang.Exception): String = {
        val base = s"Invalid value '$value' for parameter '$key'. "
        validValues.toList match {
          case Nil => base + "Ex: " + convert(example)
          case values => base + ". Valid values are: " + values.mkString("'", "', '", "'")
        }
      }
    }

    object ApibuilderTypes {
      val dateTimeIso8601: ApibuilderTypeConverter[_root_.org.joda.time.DateTime] = new ApibuilderTypeConverter[_root_.org.joda.time.DateTime] {
        override def convert(value: String): _root_.org.joda.time.DateTime = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(value)
        override def convert(value: _root_.org.joda.time.DateTime): String = _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(value)
        override def example: _root_.org.joda.time.DateTime = _root_.org.joda.time.DateTime.now
      }

      val dateIso8601: ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] = new ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] {
        override def convert(value: String): _root_.org.joda.time.LocalDate = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(value)
        override def convert(value: _root_.org.joda.time.LocalDate): String = _root_.org.joda.time.format.ISODateTimeFormat.date.print(value)
        override def example: _root_.org.joda.time.LocalDate = _root_.org.joda.time.LocalDate.now
      }
    }

    final case class ApibuilderQueryStringBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends QueryStringBindable[T] {

      override def bind(key: String, params: Map[String, Seq[String]]): _root_.scala.Option[_root_.scala.Either[String, T]] = {
        params.getOrElse(key, Nil).headOption.map { v =>
          try {
            Right(
              converters.convert(v)
            )
          } catch {
            case ex: java.lang.Exception => Left(
              converters.errorMessage(key, v, ex)
            )
          }
        }
      }

      override def unbind(key: String, value: T): String = {
        s"$key=${converters.convert(value)}"
      }
    }

    final case class ApibuilderPathBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends PathBindable[T] {

      override def bind(key: String, value: String): _root_.scala.Either[String, T] = {
        try {
          Right(
            converters.convert(value)
          )
        } catch {
          case ex: java.lang.Exception => Left(
            converters.errorMessage(key, value, ex)
          )
        }
      }

      override def unbind(key: String, value: T): String = {
        converters.convert(value)
      }
    }

  }

}
