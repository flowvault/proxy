/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.3.76
 * apibuilder:0.12.61 https://app.apibuilder.io/flow/experience/0.3.76/play_2_5_client
 */
package io.flow.experience.v0.models {

  sealed trait AllocationComponent extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type AllocationComponent
   */
  sealed trait AllocationComponentDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AllocationComponentDiscriminator {

    case object AllocationDetailComponent extends AllocationComponentDiscriminator { override def toString = "allocation_detail_component" }
    case object AllocationLevyComponent extends AllocationComponentDiscriminator { override def toString = "allocation_levy_component" }

    case class UNDEFINED(override val toString: String) extends AllocationComponentDiscriminator

    val all: scala.List[AllocationComponentDiscriminator] = scala.List(AllocationDetailComponent, AllocationLevyComponent)

    private[this] val byName: Map[String, AllocationComponentDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AllocationComponentDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AllocationComponentDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait AllocationDetail extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type AllocationDetail
   */
  sealed trait AllocationDetailDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AllocationDetailDiscriminator {

    case object AllocationLineDetail extends AllocationDetailDiscriminator { override def toString = "allocation_line_detail" }
    case object AllocationOrderDetail extends AllocationDetailDiscriminator { override def toString = "allocation_order_detail" }

    case class UNDEFINED(override val toString: String) extends AllocationDetailDiscriminator

    val all: scala.List[AllocationDetailDiscriminator] = scala.List(AllocationLineDetail, AllocationOrderDetail)

    private[this] val byName: Map[String, AllocationDetailDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AllocationDetailDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AllocationDetailDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait ExpandableExperience extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type ExpandableExperience
   */
  sealed trait ExpandableExperienceDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ExpandableExperienceDiscriminator {

    case object Experience extends ExpandableExperienceDiscriminator { override def toString = "experience" }
    case object ExperienceReference extends ExpandableExperienceDiscriminator { override def toString = "experience_reference" }

    case class UNDEFINED(override val toString: String) extends ExpandableExperienceDiscriminator

    val all: scala.List[ExpandableExperienceDiscriminator] = scala.List(Experience, ExperienceReference)

    private[this] val byName: Map[String, ExpandableExperienceDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExpandableExperienceDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExpandableExperienceDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait ExpandableOrder extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type ExpandableOrder
   */
  sealed trait ExpandableOrderDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ExpandableOrderDiscriminator {

    case object Order extends ExpandableOrderDiscriminator { override def toString = "order" }
    case object OrderReference extends ExpandableOrderDiscriminator { override def toString = "order_reference" }

    case class UNDEFINED(override val toString: String) extends ExpandableOrderDiscriminator

    val all: scala.List[ExpandableOrderDiscriminator] = scala.List(Order, OrderReference)

    private[this] val byName: Map[String, ExpandableOrderDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExpandableOrderDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExpandableOrderDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait PaymentMethodTag extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type PaymentMethodTag
   */
  sealed trait PaymentMethodTagDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object PaymentMethodTagDiscriminator {

    case object OrganizationPaymentMethodTag extends PaymentMethodTagDiscriminator { override def toString = "organization_payment_method_tag" }
    case object ExperiencePaymentMethodTag extends PaymentMethodTagDiscriminator { override def toString = "experience_payment_method_tag" }

    case class UNDEFINED(override val toString: String) extends PaymentMethodTagDiscriminator

    val all: scala.List[PaymentMethodTagDiscriminator] = scala.List(OrganizationPaymentMethodTag, ExperiencePaymentMethodTag)

    private[this] val byName: Map[String, PaymentMethodTagDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PaymentMethodTagDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PaymentMethodTagDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait Promotion extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type Promotion
   */
  sealed trait PromotionDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object PromotionDiscriminator {

    case object FreeShipping extends PromotionDiscriminator { override def toString = "free_shipping" }

    case class UNDEFINED(override val toString: String) extends PromotionDiscriminator

    val all: scala.List[PromotionDiscriminator] = scala.List(FreeShipping)

    private[this] val byName: Map[String, PromotionDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PromotionDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PromotionDiscriminator] = byName.get(value.toLowerCase)

  }

  case class Allocation(
    order: io.flow.experience.v0.models.OrderReference,
    details: Seq[io.flow.experience.v0.models.AllocationDetail]
  )

  /**
   * Represents any component that is not VAT or duty, such as item price, rounding,
   * shipping, etc.
   */
  case class AllocationDetailComponent(
    key: io.flow.experience.v0.models.OrderPriceDetailComponentKey,
    total: io.flow.common.v0.models.PriceWithBase
  ) extends AllocationComponent

  /**
   * Represents either a VAT or duty component.
   * 
   * @param rate The rate of the levy.
   * @param name The name of the levy, for display purposes.
   */
  case class AllocationLevyComponent(
    key: io.flow.experience.v0.models.OrderPriceDetailComponentKey,
    total: io.flow.common.v0.models.PriceWithBase,
    rate: BigDecimal,
    name: String
  ) extends AllocationComponent

  /**
   * @param price Represents the price of all included detail components for one unit of this line
   *        item.
   * @param total Represents the total price of this line item, which equals the price times the
   *        quantity.
   * @param included Contains all components that are included in this detail's total.
   * @param notIncluded Contains all components that are not included in this detail's total. For
   *        example, this may contain VAT components when the VAT pricing setting is
   *        displayed or ignored.
   */
  case class AllocationLineDetail(
    number: String,
    quantity: Long,
    key: io.flow.experience.v0.models.OrderPriceDetailKey,
    price: io.flow.common.v0.models.PriceWithBase,
    total: io.flow.common.v0.models.PriceWithBase,
    included: Seq[io.flow.experience.v0.models.AllocationComponent],
    notIncluded: Seq[io.flow.experience.v0.models.AllocationComponent]
  ) extends AllocationDetail

  /**
   * Represents an order-specific detail such as shipping, insurance, or an
   * order-level discount.
   * 
   * @param included Contains all components that are included in this detail's total.
   * @param notIncluded Contains all components that are not included in this detail's total. For
   *        example, this may contain VAT components when the VAT pricing setting is
   *        displayed or ignored.
   */
  case class AllocationOrderDetail(
    key: io.flow.experience.v0.models.OrderPriceDetailKey,
    total: io.flow.common.v0.models.PriceWithBase,
    included: Seq[io.flow.experience.v0.models.AllocationComponent],
    notIncluded: Seq[io.flow.experience.v0.models.AllocationComponent]
  ) extends AllocationDetail

  /**
   * A Credit Payment records a 'non cash' payment against an order (e.g. a store
   * credit, gift card, etc.), recording the amount of that credit and additional
   * details to reconcile payments. The primary purpose of the credit payment is to
   * record that a payment has been made against an order so the remaining balance
   * can be correctly computed.
   * 
   * @param description Description to show to the user describing the source of this credit payment
   * @param value The value of the credit in the local and base currencies of the associated
   *        order. This value will match the original credit payment if the currency is the
   *        same as the order or otherwise will match the currency of the order
   * @param original The provided value and maximum value amounts and currencies applicable fot the
   *        store credit
   */
  case class CreditPayment(
    id: String,
    order: io.flow.experience.v0.models.ExpandableOrder,
    key: String,
    description: String,
    value: io.flow.common.v0.models.PriceWithBase,
    original: io.flow.experience.v0.models.OriginalPrices,
    attributes: Map[String, String]
  )

  case class CreditPaymentError(
    code: io.flow.experience.v0.models.CreditPaymentErrorCode,
    messages: Seq[String],
    codes: Seq[io.flow.experience.v0.models.CreditPaymentErrorCode]
  )

  /**
   * @param key If provided, a unique key to identify this credit payment in your systems. This
   *        key is used to implement idempotency
   * @param description Description to show to the user describing the source of this credit payment
   * @param max Indicates the maximum amount applicable for this credit payment.
   * @param currency The ISO-4217 3 character currency code in which the amount is calculated.
   */
  case class CreditPaymentForm(
    orderNumber: String,
    key: _root_.scala.Option[String] = None,
    description: String,
    amount: BigDecimal,
    max: BigDecimal,
    currency: String,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * @param description Description to show to the user describing the source of this credit payment
   * @param currency The ISO-4217 3 character currency code in which the amount is calculated.
   * @param max Indicates the maximum amount applicable for this credit payment.
   */
  case class CreditPaymentPutForm(
    orderNumber: String,
    description: String,
    amount: BigDecimal,
    currency: String,
    max: BigDecimal,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  case class CreditPaymentVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    creditPayment: io.flow.experience.v0.models.CreditPayment
  )

  /**
   * @param default Default delivered duty setting based on experience default settings and
   *        reference data.
   * @param available Available delivered duty options to pick.
   */
  case class DeliveredDutySetting(
    default: io.flow.common.v0.models.DeliveredDuty,
    available: Seq[io.flow.common.v0.models.DeliveredDuty]
  )

  /**
   * Experiences define a local experience for a given geographic region
   * 
   * @param deliveredDuty Determines if a given experience should be DDP, DDU, or customer choice. If DDP,
   *        note that in some cases if a customer is shipping to a country where DDP is not
   *        available, information may still come back as DDU
   * @param region Reference to region as defined in https://api.flow.io/reference/regions
   * @param country When otherwise not known, the default country to use for this experience. One
   *        example would be an experience setup for Europe - when you request landed cost,
   *        if there is no geolocation information available, we will use this country as
   *        the basis for landed cost. ISO 3166 3 currency code as defined in
   *        https://api.flow.io/reference/countries
   * @param currency This currency defines the base currency for all pricing related features - e.g.
   *        pricing functions. ISO 4217 3 currency code as defined in
   *        https://api.flow.io/reference/currencies
   * @param language The default language to use for when displaying products, e.g. to display
   *        product information in this language by default. ISO 639 2 language code as
   *        defined in https://api.flow.io/reference/languages
   * @param position Position of this experience relative to other experiences. Lower position
   *        indicates experience should be considered first. Main use is to resolve incoming
   *        geolocation data (e.g. ip, country) to pick an experience. We do this by walking
   *        through the list of experiences to find the first one that matches the user's
   *        geography.
   */
  case class Experience(
    id: String,
    key: String,
    name: String,
    deliveredDuty: io.flow.common.v0.models.DeliveredDuty,
    region: io.flow.experience.v0.models.RegionReference,
    country: String,
    currency: String,
    language: String,
    measurementSystem: io.flow.common.v0.models.MeasurementSystem,
    subcatalog: io.flow.catalog.v0.models.SubcatalogReference,
    position: Long,
    settings: io.flow.experience.v0.models.ExperienceSettings
  ) extends ExpandableExperience

  /**
   * Defines a set of defaults for a given organization and region
   * 
   * @param key Default key - guaranteed to be unique
   * @param name Default name for the experience - guaranteed to be unique
   */
  case class ExperienceDefaults(
    key: String,
    name: String,
    deliveredDuty: io.flow.common.v0.models.DeliveredDuty,
    country: String,
    currency: String,
    language: String,
    measurementSystem: io.flow.common.v0.models.MeasurementSystem
  )

  /**
   * Experiences define a local experience for a given geographic region
   * 
   * @param regionId The actual geographic area to which this experience is targeted. Value is the
   *        region Id as defined in https://api.flow.io/reference/regions - To create a
   *        'default' experience, set region_id to 'world'
   * @param name Name for the experience
   * @param deliveredDuty Determines if a given experience should be DDP, DDU, or customer choice. If DDP,
   *        note that in some cases if a customer is shipping to a country where DDP is not
   *        available, information may still come back as DDU. If not provided, Flow will
   *        set a base default based on the country
   * @param country When otherwise not known, the default country to use for this experience. One
   *        example would be an experience setup for Europe - when you request landed cost,
   *        if there is no geolocation information available, we will use this country as
   *        the basis for landed cost. ISO 3166 3 currency code as defined in
   *        https://api.flow.io/reference/countries
   * @param currency The default currency for this experience which will define the currency of the
   *        pricing for this experience as well as the default currency displayed when no
   *        other information is available. Value is an ISO 4217 3 currency code as defined
   *        in https://api.flow.io/reference/currencies
   * @param language The default language in which to display information for this experience, when
   *        no other information is present. Value is an ISO 639 2 language code as defined
   *        in https://api.flow.io/reference/languages
   * @param key The key to use for this experience. If not provided, we will generate a unique
   *        key based on the experience name.
   * @param subcatalogId The Id of the subcatalog that will define the specific list of products to offer
   *        in this experience. If not specified, a new subcatalog will be created.
   * @param position Position of this experience relative to other experiences. Lower position
   *        indicates experience should be considered first. Main use is to resolve incoming
   *        geolocation data (e.g. ip, country) to pick an experience. We do this by walking
   *        through the list of experiences to find the first one that matches the user's
   *        geography. If not specified, then defaults to a: if region is not world, the
   *        last non world experience or b: If region is world, the end of the list.
   */
  case class ExperienceForm(
    regionId: String,
    name: String,
    deliveredDuty: _root_.scala.Option[io.flow.common.v0.models.DeliveredDuty] = None,
    country: _root_.scala.Option[String] = None,
    currency: _root_.scala.Option[String] = None,
    language: _root_.scala.Option[String] = None,
    key: _root_.scala.Option[String] = None,
    measurementSystem: _root_.scala.Option[io.flow.common.v0.models.MeasurementSystem] = None,
    subcatalogId: _root_.scala.Option[String] = None,
    position: _root_.scala.Option[Long] = None
  )

  /**
   * Experience Geo summarizes an experience along with geographic info
   * 
   * @param region Reference to region as defined in https://api.flow.io/reference/regions
   * @param country ISO 3166 3 currency code as defined in https://api.flow.io/reference/countries
   * @param currency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   * @param language ISO 639 2 language code as defined in https://api.flow.io/reference/languages
   */
  case class ExperienceGeo(
    key: String,
    name: String,
    region: io.flow.experience.v0.models.RegionReference,
    country: String,
    currency: String,
    language: String,
    measurementSystem: io.flow.common.v0.models.MeasurementSystem
  )

  /**
   * @param paymentMethodId The id of a payment method.
   * @param tags A collection of active tags for this payment such as whether it is to be
   *        displayed at checkout.
   */
  case class ExperiencePaymentMethodRuleForm(
    paymentMethodId: String,
    tags: Seq[io.flow.experience.v0.models.ExperiencePaymentMethodTag]
  )

  case class ExperienceReference(
    key: String
  ) extends ExpandableExperience

  /**
   * @param deliveredDuty Wrapper for settings around delivered duties. This includes the default for the
   *        experience and the choices available for a customer to pick.
   */
  case class ExperienceSettings(
    deliveredDuty: io.flow.experience.v0.models.DeliveredDutySetting
  )

  case class ExperienceVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    experience: io.flow.experience.v0.models.Experience
  )

  case class Ference(
    id: String
  )

  /**
   * @param trigger Trigger used to calculate eligibility for free shipping, showing information
   *        necessary.
   */
  case class FreeShipping(
    trigger: io.flow.experience.v0.models.PromotionTrigger
  ) extends Promotion

  /**
   * Defines a fixed and percent margin to apply to items matching a query.
   * 
   * @param q The query used to select items to which the margins are applied.
   * @param fixed A fixed amount to add to an item in the base currency, e.g 1.25.
   * @param percent A percent of the base cost to add, e.g. 2.25 would indicate 2.25%.
   */
  case class ItemMargin(
    id: String,
    key: String,
    name: String,
    q: String,
    fixed: BigDecimal,
    percent: BigDecimal,
    position: Long
  )

  /**
   * A percent and/or fixed margin to apply to items based on query.
   * 
   * @param fixed A fixed amount to add to an item in the base currency, e.g 1.25.
   * @param percent A percent of the base cost to add, e.g. 2.25 would indicate 2.25%.
   * @param position Defaults to end of list
   */
  case class ItemMarginPostForm(
    name: String,
    q: String,
    key: _root_.scala.Option[String] = None,
    fixed: _root_.scala.Option[BigDecimal] = None,
    percent: _root_.scala.Option[BigDecimal] = None,
    position: _root_.scala.Option[Long] = None
  )

  /**
   * A percent and/or fixed margin to apply to items based on query.
   * 
   * @param fixed A fixed amount to add to an item in the base currency, e.g 1.25.
   * @param percent A percent of the base cost to add, e.g. 2.25 would indicate 2.25%.
   * @param position Defaults to end of list
   */
  case class ItemMarginPutForm(
    name: String,
    q: String,
    fixed: _root_.scala.Option[BigDecimal] = None,
    percent: _root_.scala.Option[BigDecimal] = None,
    position: _root_.scala.Option[Long] = None
  )

  case class ItemMarginVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    itemMargin: io.flow.experience.v0.models.ItemMargin
  )

  /**
   * Provides display data for a line item.
   */
  case class Line(
    itemNumber: String,
    quantity: Long,
    price: io.flow.common.v0.models.PriceWithBase,
    total: io.flow.common.v0.models.PriceWithBase
  )

  /**
   * Line items on the order, with localized pricing information
   * 
   * @param name The item name associated to the number (e.g. Long Sleeve Dress).
   * @param center Optional center key associated with this item. Used for orders and quotes to
   *        specify where to ship an item from. If not specified, Flow will infer based on
   *        inventory setup.
   * @param price The price of this item for this order. If not specified, we will use the item
   *        price from the experience
   * @param discount The total discount, if any, to apply to this line item. Note that the discount
   *        is the total discount to apply regardless of the quantity here
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   */
  case class LocalizedLineItem(
    number: String,
    name: String,
    quantity: Long,
    center: _root_.scala.Option[String] = None,
    price: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    discount: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    local: io.flow.catalog.v0.models.Local
  )

  /**
   * An order represents all of the information about a particular line item,
   * including pricing, currency rates, delivery options, etc. All information in an
   * order is guaranteed by Flow - if an order is submitted before its expiration.
   * The intended use case is to create an order as a consumer enters checkout, then
   * to submit that order as part of the user submitting their order. Note that Flow
   * will automatically mark an order submitted if we see a payment authorization for
   * an order.
   * 
   * @param experience Contains information on the experience on which this order was submitted.
   * @param customer The customer who is actually making the purchase
   * @param deliveredDuty Options returned will only use tiers with the matching delivered duty. This
   *        would also affect whether duties are included in the total or not. If not
   *        specified, defaults based on the experience default setting.
   * @param expiresAt The date and time on which this order will expire unless submitted. Used only
   *        when the order status is 'open'. New orders will expire 1 hour after creation.
   * @param selections The currently selected delivery option ids. These IDs represent the shipping
   *        tiers that the customer has chosen (e.g. standard or express) for each delivery.
   *        The shipping price is then based on these selections (and included in the prices
   *        array). You can update an order before it has been submitted to change the
   *        delivery options, getting back accurate pricing for the order.
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   * @param submittedAt The timestamp on which the order is submitted. Once submitted, production orders
   *        can no longer be deleted as they represent transactions in the real world
   * @param lines Provides display data for each of the line items belonging to this order.
   * @param identifiers Other identifiers which are used to identify this order, if available.
   * @param promotions The current available and applied promotions for this order
   * @param payments Represents the list of payments on an order. Each payment will be typed -
   *        supporting options like a $25 account credit applied to an order plus a balance
   *        baid by a card, paypal, cash on delivery, etc. The list of payments here is
   *        summary information only for display back to the user; each individual payment
   *        will have varying levels of detail based on the actual type of the payment
   * @param balance The remaining balance on this order. Will be marked required in a future version
   *        of the Flow API
   */
  case class Order(
    id: String,
    number: String,
    experience: _root_.scala.Option[io.flow.experience.v0.models.ExpandableExperience] = None,
    customer: io.flow.common.v0.models.Customer,
    deliveredDuty: io.flow.common.v0.models.DeliveredDuty,
    destination: io.flow.experience.v0.models.OrderAddress,
    expiresAt: _root_.org.joda.time.DateTime,
    items: Seq[io.flow.experience.v0.models.LocalizedLineItem],
    deliveries: Seq[io.flow.fulfillment.v0.models.Delivery],
    selections: Seq[String],
    prices: Seq[io.flow.experience.v0.models.OrderPriceDetail],
    total: io.flow.catalog.v0.models.LocalizedTotal,
    attributes: Map[String, String],
    submittedAt: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    lines: _root_.scala.Option[Seq[io.flow.experience.v0.models.Line]] = None,
    identifiers: _root_.scala.Option[Seq[String]] = None,
    promotions: _root_.scala.Option[io.flow.experience.v0.models.Promotions] = None,
    payments: _root_.scala.Option[Seq[io.flow.experience.v0.models.OrderPayment]] = None,
    balance: _root_.scala.Option[io.flow.catalog.v0.models.LocalizedTotal] = None
  ) extends ExpandableOrder

  /**
   * @param text Full text version of address
   * @param streets Array for street line 1, street line 2, etc., in order
   * @param country The ISO 3166-3 country code. Case insensitive. See
   *        https://api.flow.io/reference/countries
   * @param contact Contact information of entity at the address
   */
  case class OrderAddress(
    text: _root_.scala.Option[String] = None,
    streets: _root_.scala.Option[Seq[String]] = None,
    city: _root_.scala.Option[String] = None,
    province: _root_.scala.Option[String] = None,
    postal: _root_.scala.Option[String] = None,
    country: _root_.scala.Option[String] = None,
    latitude: _root_.scala.Option[String] = None,
    longitude: _root_.scala.Option[String] = None,
    contact: _root_.scala.Option[io.flow.common.v0.models.Contact] = None
  )

  /**
   * @param messages A summary of the errors
   * @param numbers A list of all of the item numbers that are not available
   * @param destinationCountry Destination country of the order, if available.
   */
  case class OrderError(
    code: io.flow.experience.v0.models.OrderErrorCode,
    messages: Seq[String],
    numbers: _root_.scala.Option[Seq[String]] = None,
    destinationCountry: _root_.scala.Option[io.flow.reference.v0.models.Country] = None
  )

  /**
   * Lightweight estimate for a group of items without any customer-related
   * information. This will contain available estimates on shipping, taxes, and
   * duties.
   * 
   * @param selections The currently selected delivery option ids. These IDs represent the shipping
   *        tiers that the customer has chosen (e.g. standard or express) for each delivery.
   *        The shipping price is then based on these selections (and included in the prices
   *        array). You can update an order before it has been submitted to change the
   *        delivery options, getting back accurate pricing for the order.
   * @param lines Provides display data for each of the line items belonging to this order
   *        estimate.
   * @param promotions The current available and applied promotions for this order
   */
  @deprecated("Estimates are deprecated. Please use orders with optional destination") case class OrderEstimate(
    id: String,
    items: Seq[io.flow.experience.v0.models.LocalizedLineItem],
    destination: io.flow.experience.v0.models.OrderAddress,
    deliveries: Seq[io.flow.fulfillment.v0.models.Delivery],
    prices: Seq[io.flow.experience.v0.models.OrderPriceDetail],
    selections: Seq[String],
    total: io.flow.catalog.v0.models.LocalizedTotal,
    lines: _root_.scala.Option[Seq[io.flow.experience.v0.models.Line]] = None,
    promotions: _root_.scala.Option[io.flow.experience.v0.models.Promotions] = None
  )

  /**
   * Form to get a lightweight estimate of an order.
   * 
   * @param selections Selected list of delivery options for this quote. The original order will
   *        contain one or more deliveries. Each delivery will contain one or more shipping
   *        options (e.g. standard or express). We need to know which shipping options the
   *        user selected in order to provide accurate, local shipping pricing. You should
   *        only specify if you are explicitly changing the delivery options
   */
  @deprecated("Estimates are deprecated. Please use orders with optional destination") case class OrderEstimateForm(
    items: Seq[io.flow.common.v0.models.LineItemForm],
    destination: _root_.scala.Option[io.flow.experience.v0.models.OrderAddress] = None,
    selections: _root_.scala.Option[Seq[String]] = None
  )

  /**
   * The order form is used to create an open order, providing the details on pricing
   * and delivery options for destination and items/quantities specified
   * 
   * @param customer The customer who actually is making the purchase. We recommend providing as much
   *        information as you have, notably email address which can be used to increase
   *        acceptance rates if Flow is processing payment for this order. If you can also
   *        provide your customer number - we can link multiple orders for each customer in
   *        the Flow console.
   * @param deliveredDuty Options returned will only use tiers with the matching delivered duty. This
   *        would also affect whether duties are included in the total or not. If not
   *        specified, defaults based on the experience default setting.
   * @param number If not provided, will default to the generated unique order identifier.
   * @param discount An optional discount to apply to the entire order
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   */
  case class OrderForm(
    customer: _root_.scala.Option[io.flow.common.v0.models.Customer] = None,
    items: Seq[io.flow.common.v0.models.LineItemForm],
    deliveredDuty: _root_.scala.Option[io.flow.common.v0.models.DeliveredDuty] = None,
    number: _root_.scala.Option[String] = None,
    destination: _root_.scala.Option[io.flow.experience.v0.models.OrderAddress] = None,
    discount: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * Represents alternate numbers with which to identify an order.
   */
  case class OrderIdentifier(
    id: String,
    order: io.flow.experience.v0.models.OrderReference,
    number: String
  )

  case class OrderIdentifierForm(
    order: String,
    number: String
  )

  case class OrderIdentifierPutForm(
    order: String
  )

  case class OrderIdentifierVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    orderIdentifier: io.flow.experience.v0.models.OrderIdentifier
  )

  /**
   * An Order Payment represents an individual payment applied to an order. The type
   * of the payment can be used to further lookup transaction level detail
   * 
   * @param reference The reference identifier for the details behind this order payment. For example,
   *        if this payment was a card payment, the reference will be the unique
   *        authorization key.
   * @param description Human understandable description of this payment method
   */
  case class OrderPayment(
    id: String,
    `type`: io.flow.experience.v0.models.OrderPaymentType,
    reference: String,
    description: String,
    total: io.flow.common.v0.models.PriceWithBase
  )

  /**
   * Represents a top-level order price detail, e.g. 'Subtotal' or 'VAT'.
   * 
   * @param key The key indicating what this price detail represents.
   * @param currency The ISO-4217 3 character currency code in which the amount is calculated.
   * @param amount The total cost of the price detail in the currency of the experience in which
   *        the order is placed.
   * @param label The formatted label for this price detail that should be displayed to the user.
   * @param base The amount of this price detail in the base currency of the organization.
   * @param components Contains the components of this price detail that are used to calculate the
   *        total.
   * @param name The display name for this order price detail.
   */
  case class OrderPriceDetail(
    key: io.flow.experience.v0.models.OrderPriceDetailKey,
    currency: String,
    amount: BigDecimal,
    label: String,
    base: io.flow.common.v0.models.Price,
    components: Seq[io.flow.experience.v0.models.OrderPriceDetailComponent],
    name: _root_.scala.Option[String] = None
  )

  /**
   * @param currency The ISO-4217 3 character currency code in which the amount is calculated.
   * @param amount The total cost of the price detail component in the currency of the experience
   *        in which the order is placed.
   * @param base The amount of this price detail component in the base currency of the
   *        organization.
   * @param name The display name for this order price detail component.
   */
  case class OrderPriceDetailComponent(
    key: io.flow.experience.v0.models.OrderPriceDetailComponentKey,
    currency: String,
    amount: BigDecimal,
    label: String,
    base: io.flow.common.v0.models.Price,
    name: _root_.scala.Option[String] = None
  )

  /**
   * The order put form is used to upsert an order, providing the details on pricing
   * and delivery options for destination and items/quantities specified.
   * 
   * @param customer The customer who actually is making the purchase. We recommend providing as much
   *        information as you have, notably email address which can be used to increase
   *        acceptance rates if Flow is processing payment for this order. If you can also
   *        provide your customer number - we can link multiple orders for each customer in
   *        the Flow console.
   * @param deliveredDuty Options returned will only use tiers with the matching delivered duty. This
   *        would also affect whether duties are included in the total or not. If not
   *        specified, defaults based on the experience default setting.
   * @param selections Selected list of delivery options for this quote. The original order will
   *        contain one or more deliveries. Each delivery will contain one or more shipping
   *        options (e.g. standard or express). We need to know which shipping options the
   *        user selected in order to provide accurate, local shipping pricing. You should
   *        only specify if you are explicitly changing the delivery options
   * @param discount An optional discount to apply to the entire order
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   */
  case class OrderPutForm(
    items: Seq[io.flow.common.v0.models.LineItemForm],
    customer: _root_.scala.Option[io.flow.common.v0.models.Customer] = None,
    deliveredDuty: _root_.scala.Option[io.flow.common.v0.models.DeliveredDuty] = None,
    selections: _root_.scala.Option[Seq[String]] = None,
    destination: _root_.scala.Option[io.flow.experience.v0.models.OrderAddress] = None,
    discount: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  case class OrderReference(
    id: String,
    number: String
  ) extends ExpandableOrder

  case class OrderVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    order: io.flow.experience.v0.models.Order
  )

  /**
   * Model representing original and max values and currencies.
   */
  case class OriginalPrices(
    value: io.flow.common.v0.models.Price,
    max: io.flow.common.v0.models.Price
  )

  /**
   * @param tags A collection of active tags for this payment such as whether it is denied for an
   *        organization or to be displayed at checkout.
   * @param displayPosition The order in which payment methods will be displayed. Lower numbers will have
   *        priority.
   */
  case class PaymentMethodRule(
    tags: Seq[io.flow.experience.v0.models.PaymentMethodTag],
    paymentMethod: io.flow.reference.v0.models.PaymentMethod,
    displayPosition: Int
  )

  /**
   * @param min Minimum amount to be eligible for the trigger
   * @param remaining Remaining value necessary to apply the trigger
   * @param max Maximum value covered by trigger
   */
  case class PromotionTrigger(
    `type`: io.flow.experience.v0.models.PromotionTriggerType,
    min: io.flow.common.v0.models.Price,
    remaining: io.flow.common.v0.models.Price,
    max: _root_.scala.Option[io.flow.common.v0.models.Price] = None
  )

  /**
   * @param applied List of promotions that have been applied to this order. For example, free
   *        shipping promotion is applied to the shipping price.
   * @param available List of available promotions that are applicable for this order. If a promotion
   *        is here, the promo is not yet applied to the order, but the order can become
   *        eligible for it given some criteria.
   */
  case class Promotions(
    applied: Seq[io.flow.experience.v0.models.Promotion],
    available: Seq[io.flow.experience.v0.models.Promotion]
  )

  case class RegionReference(
    id: String
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AllocationComponent, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  case class AllocationComponentUndefinedType(
    description: String
  ) extends AllocationComponent

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AllocationDetail, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  case class AllocationDetailUndefinedType(
    description: String
  ) extends AllocationDetail

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableExperience, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  case class ExpandableExperienceUndefinedType(
    description: String
  ) extends ExpandableExperience

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableOrder, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  case class ExpandableOrderUndefinedType(
    description: String
  ) extends ExpandableOrder

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union PaymentMethodTag, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  case class PaymentMethodTagUndefinedType(
    description: String
  ) extends PaymentMethodTag

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Promotion, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  case class PromotionUndefinedType(
    description: String
  ) extends Promotion

  sealed trait CreditPaymentErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object CreditPaymentErrorCode {

    case object GenericError extends CreditPaymentErrorCode { override def toString = "generic_error" }
    /**
     * Indicates the specified order does not exist
     */
    case object InvalidOrderNumber extends CreditPaymentErrorCode { override def toString = "invalid_order_number" }
    /**
     * Indicates that the specified currency code is not valid
     */
    case object InvalidCurrency extends CreditPaymentErrorCode { override def toString = "invalid_currency" }
    /**
     * Indicates that the description is invalid (must be non-empty)
     */
    case object InvalidDescription extends CreditPaymentErrorCode { override def toString = "invalid_description" }
    /**
     * Indicates that a credit payment with the specified key already exists
     */
    case object Duplicate extends CreditPaymentErrorCode { override def toString = "duplicate" }
    /**
     * Indicates the provided credit amount was <= 0
     */
    case object AmountMustBePositive extends CreditPaymentErrorCode { override def toString = "amount_must_be_positive" }
    /**
     * Indicates the provided credit amount exceeds the remaining balance on the order
     */
    case object AmountExceedsBalance extends CreditPaymentErrorCode { override def toString = "amount_exceeds_balance" }
    /**
     * Indicates the provided credit amount exceeds the maximum amount of applicable
     * credit
     */
    case object InsufficientAmount extends CreditPaymentErrorCode { override def toString = "insufficient_amount" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends CreditPaymentErrorCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CreditPaymentErrorCode] = scala.List(GenericError, InvalidOrderNumber, InvalidCurrency, InvalidDescription, Duplicate, AmountMustBePositive, AmountExceedsBalance, InsufficientAmount)

    private[this]
    val byName: Map[String, CreditPaymentErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CreditPaymentErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CreditPaymentErrorCode] = byName.get(value.toLowerCase)

  }

  sealed trait ExperiencePaymentMethodTag extends PaymentMethodTag

  object ExperiencePaymentMethodTag {

    /**
     * A displayed payment method will be highlighted during the checkout process for
     * an experience.
     */
    case object Display extends ExperiencePaymentMethodTag { override def toString = "display" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends ExperiencePaymentMethodTag

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ExperiencePaymentMethodTag] = scala.List(Display)

    private[this]
    val byName: Map[String, ExperiencePaymentMethodTag] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExperiencePaymentMethodTag = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExperiencePaymentMethodTag] = byName.get(value.toLowerCase)

  }

  sealed trait OrderErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object OrderErrorCode {

    case object GenericError extends OrderErrorCode { override def toString = "generic_error" }
    /**
     * When creating an order, if a particular item is not available in the country /
     * destination (either because it was restricted or excluded from that country), we
     * return this error code and list the specific item numbers which are not
     * available in the 'numbers' field.
     */
    case object OrderItemNotAvailable extends OrderErrorCode { override def toString = "order_item_not_available" }
    /**
     * Indicates that there is no order with the specified number (nor an order for
     * which an order identifier with that number has been created)
     */
    case object OrderIdentifierError extends OrderErrorCode { override def toString = "order_identifier_error" }
    /**
     * Indicates that an order was created for a country to which you have asked Flow
     * not to ship. Usually this indicates an error that a request was made to create
     * an order for your domestic country
     */
    case object DomesticShippingUnavailable extends OrderErrorCode { override def toString = "domestic_shipping_unavailable" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends OrderErrorCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderErrorCode] = scala.List(GenericError, OrderItemNotAvailable, OrderIdentifierError, DomesticShippingUnavailable)

    private[this]
    val byName: Map[String, OrderErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderErrorCode] = byName.get(value.toLowerCase)

  }

  /**
   * The order payment type identified the different ways a consumer may have paid
   * for an order. The primary purpose is in displaying summary level payment
   * information to the user; the type can then be used to know how to request
   * additional details for each payment.
   */
  sealed trait OrderPaymentType extends _root_.scala.Product with _root_.scala.Serializable

  object OrderPaymentType {

    /**
     * Represents a payment in the form of a credit or debit card
     */
    case object Card extends OrderPaymentType { override def toString = "card" }
    /**
     * Represents an online payment (e.g. paypal, alipay, etc)
     */
    case object Online extends OrderPaymentType { override def toString = "online" }
    /**
     * A payment in the form of a credit of some type (e.g. a store credit, gift card)
     * applied to an order
     */
    case object Credit extends OrderPaymentType { override def toString = "credit" }
    /**
     * Request to pay the balance with cash on delivery. Offered only when the final
     * mile carriers support cash on delivery.
     */
    case object CashOnDelivery extends OrderPaymentType { override def toString = "cash_on_delivery" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends OrderPaymentType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderPaymentType] = scala.List(Card, Online, Credit, CashOnDelivery)

    private[this]
    val byName: Map[String, OrderPaymentType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderPaymentType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderPaymentType] = byName.get(value.toLowerCase)

  }

  sealed trait OrderPriceDetailComponentKey extends _root_.scala.Product with _root_.scala.Serializable

  object OrderPriceDetailComponentKey {

    /**
     * A general purpose adjustment applied to the order.
     */
    case object Adjustment extends OrderPriceDetailComponentKey { override def toString = "adjustment" }
    /**
     * An adjustment based on whether the VAT de minimis applies to the order.
     */
    case object VatDeminimis extends OrderPriceDetailComponentKey { override def toString = "vat_deminimis" }
    /**
     * An adjustment based on whether the duty de minimis applies to the order.
     */
    case object DutyDeminimis extends OrderPriceDetailComponentKey { override def toString = "duty_deminimis" }
    /**
     * The VAT owed on the price of the order's items, including any added margins and
     * rounding.
     */
    case object DutiesItemPrice extends OrderPriceDetailComponentKey { override def toString = "duties_item_price" }
    /**
     * The duty owed on the freight cost of the order.
     */
    case object DutiesFreight extends OrderPriceDetailComponentKey { override def toString = "duties_freight" }
    /**
     * The duty owed on the insurance cost of the order.
     */
    case object DutiesInsurance extends OrderPriceDetailComponentKey { override def toString = "duties_insurance" }
    /**
     * The VAT owed on the price of the order's items, including any added margins and
     * rounding.
     */
    case object VatItemPrice extends OrderPriceDetailComponentKey { override def toString = "vat_item_price" }
    /**
     * The VAT owed on the freight cost of the order.
     */
    case object VatFreight extends OrderPriceDetailComponentKey { override def toString = "vat_freight" }
    /**
     * The VAT owed on the insurance cost of the order.
     */
    case object VatInsurance extends OrderPriceDetailComponentKey { override def toString = "vat_insurance" }
    /**
     * The VAT owed on the duties on the price of the order's items, including any
     * added margins and rounding.
     */
    case object VatDutiesItemPrice extends OrderPriceDetailComponentKey { override def toString = "vat_duties_item_price" }
    /**
     * The VAT owed on the duties on the freight cost of the order.
     */
    case object VatDutiesFreight extends OrderPriceDetailComponentKey { override def toString = "vat_duties_freight" }
    /**
     * The VAT owed on the duties on the insurance cost of the order.
     */
    case object VatDutiesInsurance extends OrderPriceDetailComponentKey { override def toString = "vat_duties_insurance" }
    /**
     * The sum of the price of the order's items with their currency margins, percent
     * margins, and fixed margins included.
     */
    case object ItemPrice extends OrderPriceDetailComponentKey { override def toString = "item_price" }
    /**
     * The sum of any rounding applied to the order's items.
     */
    case object Rounding extends OrderPriceDetailComponentKey { override def toString = "rounding" }
    /**
     * The insurance cost for the order.
     */
    case object Insurance extends OrderPriceDetailComponentKey { override def toString = "insurance" }
    /**
     * The shipping cost for the order.
     */
    case object Shipping extends OrderPriceDetailComponentKey { override def toString = "shipping" }
    /**
     * A discount applied to the entire order.
     */
    case object OrderDiscount extends OrderPriceDetailComponentKey { override def toString = "order_discount" }
    /**
     * The sum of adjustments to item price, margin and rounding made due to percentage
     * sales margins.
     */
    case object SubtotalPercentSalesMargin extends OrderPriceDetailComponentKey { override def toString = "subtotal_percent_sales_margin" }
    /**
     * The sum of adjustments to VAT owed made due to percentage sales margins.
     */
    case object SubtotalVatPercentSalesMargin extends OrderPriceDetailComponentKey { override def toString = "subtotal_vat_percent_sales_margin" }
    /**
     * The sum of adjustments to duty owed made due to percentage sales margins.
     */
    case object SubtotalDutyPercentSalesMargin extends OrderPriceDetailComponentKey { override def toString = "subtotal_duty_percent_sales_margin" }
    /**
     * An offset to account for any VAT subsidized by the organization. For example, if
     * VAT is included in an item price and changes at the order level (due to passing
     * de minimis threshold, or the destination having a more specific VAT rate), the
     * difference will be represented here.
     */
    case object VatSubsidy extends OrderPriceDetailComponentKey { override def toString = "vat_subsidy" }
    /**
     * An offset to account for any duty subsidized by the organization. For example,
     * if duty is included in an item price and changes at the order level (due to
     * passing de minimis threshold, or the destination having a more specific duty
     * rate), the difference will be represented here.
     */
    case object DutySubsidy extends OrderPriceDetailComponentKey { override def toString = "duty_subsidy" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends OrderPriceDetailComponentKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderPriceDetailComponentKey] = scala.List(Adjustment, VatDeminimis, DutyDeminimis, DutiesItemPrice, DutiesFreight, DutiesInsurance, VatItemPrice, VatFreight, VatInsurance, VatDutiesItemPrice, VatDutiesFreight, VatDutiesInsurance, ItemPrice, Rounding, Insurance, Shipping, OrderDiscount, SubtotalPercentSalesMargin, SubtotalVatPercentSalesMargin, SubtotalDutyPercentSalesMargin, VatSubsidy, DutySubsidy)

    private[this]
    val byName: Map[String, OrderPriceDetailComponentKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderPriceDetailComponentKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderPriceDetailComponentKey] = byName.get(value.toLowerCase)

  }

  sealed trait OrderPriceDetailKey extends _root_.scala.Product with _root_.scala.Serializable

  object OrderPriceDetailKey {

    /**
     * The details of any adjustments made to the order.
     */
    case object Adjustment extends OrderPriceDetailKey { override def toString = "adjustment" }
    /**
     * The details of the subtotal for the order, including item prices, margins, and
     * rounding.
     */
    case object Subtotal extends OrderPriceDetailKey { override def toString = "subtotal" }
    /**
     * The details of any VAT owed on the order.
     */
    case object Vat extends OrderPriceDetailKey { override def toString = "vat" }
    /**
     * The details of any duties owed on the order.
     */
    case object Duty extends OrderPriceDetailKey { override def toString = "duty" }
    /**
     * The details of shipping costs for the order.
     */
    case object Shipping extends OrderPriceDetailKey { override def toString = "shipping" }
    /**
     * The details of insurance costs for the order.
     */
    case object Insurance extends OrderPriceDetailKey { override def toString = "insurance" }
    /**
     * The details of any discount applied to the order.
     */
    case object Discount extends OrderPriceDetailKey { override def toString = "discount" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends OrderPriceDetailKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderPriceDetailKey] = scala.List(Adjustment, Subtotal, Vat, Duty, Shipping, Insurance, Discount)

    private[this]
    val byName: Map[String, OrderPriceDetailKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderPriceDetailKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderPriceDetailKey] = byName.get(value.toLowerCase)

  }

  /**
   * Indicates an order's status
   */
  sealed trait OrderStatus extends _root_.scala.Product with _root_.scala.Serializable

  object OrderStatus {

    case object Open extends OrderStatus { override def toString = "open" }
    case object Submitted extends OrderStatus { override def toString = "submitted" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends OrderStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderStatus] = scala.List(Open, Submitted)

    private[this]
    val byName: Map[String, OrderStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderStatus] = byName.get(value.toLowerCase)

  }

  sealed trait OrganizationPaymentMethodTag extends PaymentMethodTag

  object OrganizationPaymentMethodTag {

    /**
     * A denied payment method cannot be used for an organization in any experience.
     */
    case object Deny extends OrganizationPaymentMethodTag { override def toString = "deny" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends OrganizationPaymentMethodTag

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrganizationPaymentMethodTag] = scala.List(Deny)

    private[this]
    val byName: Map[String, OrganizationPaymentMethodTag] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrganizationPaymentMethodTag = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrganizationPaymentMethodTag] = byName.get(value.toLowerCase)

  }

  sealed trait PromotionTriggerType extends _root_.scala.Product with _root_.scala.Serializable

  object PromotionTriggerType {

    case object OrderSubtotal extends PromotionTriggerType { override def toString = "order_subtotal" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends PromotionTriggerType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[PromotionTriggerType] = scala.List(OrderSubtotal)

    private[this]
    val byName: Map[String, PromotionTriggerType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PromotionTriggerType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PromotionTriggerType] = byName.get(value.toLowerCase)

  }

}

package io.flow.experience.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.catalog.v0.models.json._
    import io.flow.common.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.experience.v0.models.json._
    import io.flow.fulfillment.v0.models.json._
    import io.flow.price.v0.models.json._
    import io.flow.reference.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

    private[v0] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
      def writes(x: java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      import org.joda.time.format.ISODateTimeFormat.dateTimeParser
      dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
      def writes(x: org.joda.time.DateTime) = {
        import org.joda.time.format.ISODateTimeFormat.dateTime
        val str = dateTime.print(x)
        JsString(str)
      }
    }

    implicit val jsonReadsExperienceCreditPaymentErrorCode = new play.api.libs.json.Reads[io.flow.experience.v0.models.CreditPaymentErrorCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.CreditPaymentErrorCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.CreditPaymentErrorCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.CreditPaymentErrorCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceCreditPaymentErrorCode(obj: io.flow.experience.v0.models.CreditPaymentErrorCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCreditPaymentErrorCode(obj: io.flow.experience.v0.models.CreditPaymentErrorCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceCreditPaymentErrorCode: play.api.libs.json.Writes[CreditPaymentErrorCode] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPaymentErrorCode] {
        def writes(obj: io.flow.experience.v0.models.CreditPaymentErrorCode) = {
          jsonWritesExperienceCreditPaymentErrorCode(obj)
        }
      }
    }

    implicit val jsonReadsExperienceExperiencePaymentMethodTag = new play.api.libs.json.Reads[io.flow.experience.v0.models.ExperiencePaymentMethodTag] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.ExperiencePaymentMethodTag] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperiencePaymentMethodTag(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperiencePaymentMethodTag(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceExperiencePaymentMethodTag(obj: io.flow.experience.v0.models.ExperiencePaymentMethodTag) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectExperiencePaymentMethodTag(obj: io.flow.experience.v0.models.ExperiencePaymentMethodTag) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceExperiencePaymentMethodTag: play.api.libs.json.Writes[ExperiencePaymentMethodTag] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePaymentMethodTag] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePaymentMethodTag) = {
          jsonWritesExperienceExperiencePaymentMethodTag(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderErrorCode = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderErrorCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderErrorCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderErrorCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderErrorCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderErrorCode(obj: io.flow.experience.v0.models.OrderErrorCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderErrorCode(obj: io.flow.experience.v0.models.OrderErrorCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderErrorCode: play.api.libs.json.Writes[OrderErrorCode] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderErrorCode] {
        def writes(obj: io.flow.experience.v0.models.OrderErrorCode) = {
          jsonWritesExperienceOrderErrorCode(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderPaymentType = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderPaymentType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderPaymentType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPaymentType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPaymentType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderPaymentType(obj: io.flow.experience.v0.models.OrderPaymentType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderPaymentType(obj: io.flow.experience.v0.models.OrderPaymentType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderPaymentType: play.api.libs.json.Writes[OrderPaymentType] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPaymentType] {
        def writes(obj: io.flow.experience.v0.models.OrderPaymentType) = {
          jsonWritesExperienceOrderPaymentType(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderPriceDetailComponentKey = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderPriceDetailComponentKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderPriceDetailComponentKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPriceDetailComponentKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPriceDetailComponentKey(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderPriceDetailComponentKey(obj: io.flow.experience.v0.models.OrderPriceDetailComponentKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderPriceDetailComponentKey(obj: io.flow.experience.v0.models.OrderPriceDetailComponentKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderPriceDetailComponentKey: play.api.libs.json.Writes[OrderPriceDetailComponentKey] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPriceDetailComponentKey] {
        def writes(obj: io.flow.experience.v0.models.OrderPriceDetailComponentKey) = {
          jsonWritesExperienceOrderPriceDetailComponentKey(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderPriceDetailKey = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderPriceDetailKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderPriceDetailKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPriceDetailKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPriceDetailKey(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderPriceDetailKey(obj: io.flow.experience.v0.models.OrderPriceDetailKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderPriceDetailKey(obj: io.flow.experience.v0.models.OrderPriceDetailKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderPriceDetailKey: play.api.libs.json.Writes[OrderPriceDetailKey] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPriceDetailKey] {
        def writes(obj: io.flow.experience.v0.models.OrderPriceDetailKey) = {
          jsonWritesExperienceOrderPriceDetailKey(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderStatus = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderStatus(obj: io.flow.experience.v0.models.OrderStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderStatus(obj: io.flow.experience.v0.models.OrderStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderStatus: play.api.libs.json.Writes[OrderStatus] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderStatus] {
        def writes(obj: io.flow.experience.v0.models.OrderStatus) = {
          jsonWritesExperienceOrderStatus(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrganizationPaymentMethodTag = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrganizationPaymentMethodTag] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrganizationPaymentMethodTag] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrganizationPaymentMethodTag(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrganizationPaymentMethodTag(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrganizationPaymentMethodTag(obj: io.flow.experience.v0.models.OrganizationPaymentMethodTag) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrganizationPaymentMethodTag(obj: io.flow.experience.v0.models.OrganizationPaymentMethodTag) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrganizationPaymentMethodTag: play.api.libs.json.Writes[OrganizationPaymentMethodTag] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrganizationPaymentMethodTag] {
        def writes(obj: io.flow.experience.v0.models.OrganizationPaymentMethodTag) = {
          jsonWritesExperienceOrganizationPaymentMethodTag(obj)
        }
      }
    }

    implicit val jsonReadsExperiencePromotionTriggerType = new play.api.libs.json.Reads[io.flow.experience.v0.models.PromotionTriggerType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.PromotionTriggerType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PromotionTriggerType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PromotionTriggerType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesExperiencePromotionTriggerType(obj: io.flow.experience.v0.models.PromotionTriggerType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPromotionTriggerType(obj: io.flow.experience.v0.models.PromotionTriggerType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperiencePromotionTriggerType: play.api.libs.json.Writes[PromotionTriggerType] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PromotionTriggerType] {
        def writes(obj: io.flow.experience.v0.models.PromotionTriggerType) = {
          jsonWritesExperiencePromotionTriggerType(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocation: play.api.libs.json.Reads[Allocation] = {
      (
        (__ \ "order").read[io.flow.experience.v0.models.OrderReference] and
        (__ \ "details").read[Seq[io.flow.experience.v0.models.AllocationDetail]]
      )(Allocation.apply _)
    }

    def jsObjectAllocation(obj: io.flow.experience.v0.models.Allocation): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order" -> jsObjectOrderReference(obj.order),
        "details" -> play.api.libs.json.Json.toJson(obj.details)
      )
    }

    implicit def jsonWritesExperienceAllocation: play.api.libs.json.Writes[Allocation] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Allocation] {
        def writes(obj: io.flow.experience.v0.models.Allocation) = {
          jsObjectAllocation(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationDetailComponent: play.api.libs.json.Reads[AllocationDetailComponent] = {
      (
        (__ \ "key").read[io.flow.experience.v0.models.OrderPriceDetailComponentKey] and
        (__ \ "total").read[io.flow.common.v0.models.PriceWithBase]
      )(AllocationDetailComponent.apply _)
    }

    def jsObjectAllocationDetailComponent(obj: io.flow.experience.v0.models.AllocationDetailComponent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total)
      )
    }

    implicit def jsonReadsExperienceAllocationLevyComponent: play.api.libs.json.Reads[AllocationLevyComponent] = {
      (
        (__ \ "key").read[io.flow.experience.v0.models.OrderPriceDetailComponentKey] and
        (__ \ "total").read[io.flow.common.v0.models.PriceWithBase] and
        (__ \ "rate").read[BigDecimal] and
        (__ \ "name").read[String]
      )(AllocationLevyComponent.apply _)
    }

    def jsObjectAllocationLevyComponent(obj: io.flow.experience.v0.models.AllocationLevyComponent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total),
        "rate" -> play.api.libs.json.JsNumber(obj.rate),
        "name" -> play.api.libs.json.JsString(obj.name)
      )
    }

    implicit def jsonReadsExperienceAllocationLineDetail: play.api.libs.json.Reads[AllocationLineDetail] = {
      (
        (__ \ "number").read[String] and
        (__ \ "quantity").read[Long] and
        (__ \ "key").read[io.flow.experience.v0.models.OrderPriceDetailKey] and
        (__ \ "price").read[io.flow.common.v0.models.PriceWithBase] and
        (__ \ "total").read[io.flow.common.v0.models.PriceWithBase] and
        (__ \ "included").read[Seq[io.flow.experience.v0.models.AllocationComponent]] and
        (__ \ "not_included").read[Seq[io.flow.experience.v0.models.AllocationComponent]]
      )(AllocationLineDetail.apply _)
    }

    def jsObjectAllocationLineDetail(obj: io.flow.experience.v0.models.AllocationLineDetail): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "price" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.price),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total),
        "included" -> play.api.libs.json.Json.toJson(obj.included),
        "not_included" -> play.api.libs.json.Json.toJson(obj.notIncluded)
      )
    }

    implicit def jsonReadsExperienceAllocationOrderDetail: play.api.libs.json.Reads[AllocationOrderDetail] = {
      (
        (__ \ "key").read[io.flow.experience.v0.models.OrderPriceDetailKey] and
        (__ \ "total").read[io.flow.common.v0.models.PriceWithBase] and
        (__ \ "included").read[Seq[io.flow.experience.v0.models.AllocationComponent]] and
        (__ \ "not_included").read[Seq[io.flow.experience.v0.models.AllocationComponent]]
      )(AllocationOrderDetail.apply _)
    }

    def jsObjectAllocationOrderDetail(obj: io.flow.experience.v0.models.AllocationOrderDetail): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total),
        "included" -> play.api.libs.json.Json.toJson(obj.included),
        "not_included" -> play.api.libs.json.Json.toJson(obj.notIncluded)
      )
    }

    implicit def jsonReadsExperienceCreditPayment: play.api.libs.json.Reads[CreditPayment] = {
      (
        (__ \ "id").read[String] and
        (__ \ "order").read[io.flow.experience.v0.models.ExpandableOrder] and
        (__ \ "key").read[String] and
        (__ \ "description").read[String] and
        (__ \ "value").read[io.flow.common.v0.models.PriceWithBase] and
        (__ \ "original").read[io.flow.experience.v0.models.OriginalPrices] and
        (__ \ "attributes").read[Map[String, String]]
      )(CreditPayment.apply _)
    }

    def jsObjectCreditPayment(obj: io.flow.experience.v0.models.CreditPayment): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "order" -> jsObjectExpandableOrder(obj.order),
        "key" -> play.api.libs.json.JsString(obj.key),
        "description" -> play.api.libs.json.JsString(obj.description),
        "value" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.value),
        "original" -> jsObjectOriginalPrices(obj.original),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      )
    }

    implicit def jsonWritesExperienceCreditPayment: play.api.libs.json.Writes[CreditPayment] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPayment] {
        def writes(obj: io.flow.experience.v0.models.CreditPayment) = {
          jsObjectCreditPayment(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCreditPaymentError: play.api.libs.json.Reads[CreditPaymentError] = {
      (
        (__ \ "code").read[io.flow.experience.v0.models.CreditPaymentErrorCode] and
        (__ \ "messages").read[Seq[String]] and
        (__ \ "codes").read[Seq[io.flow.experience.v0.models.CreditPaymentErrorCode]]
      )(CreditPaymentError.apply _)
    }

    def jsObjectCreditPaymentError(obj: io.flow.experience.v0.models.CreditPaymentError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages),
        "codes" -> play.api.libs.json.Json.toJson(obj.codes)
      )
    }

    implicit def jsonWritesExperienceCreditPaymentError: play.api.libs.json.Writes[CreditPaymentError] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPaymentError] {
        def writes(obj: io.flow.experience.v0.models.CreditPaymentError) = {
          jsObjectCreditPaymentError(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCreditPaymentForm: play.api.libs.json.Reads[CreditPaymentForm] = {
      (
        (__ \ "order_number").read[String] and
        (__ \ "key").readNullable[String] and
        (__ \ "description").read[String] and
        (__ \ "amount").read[BigDecimal] and
        (__ \ "max").read[BigDecimal] and
        (__ \ "currency").read[String] and
        (__ \ "attributes").readNullable[Map[String, String]]
      )(CreditPaymentForm.apply _)
    }

    def jsObjectCreditPaymentForm(obj: io.flow.experience.v0.models.CreditPaymentForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber),
        "description" -> play.api.libs.json.JsString(obj.description),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "max" -> play.api.libs.json.JsNumber(obj.max),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceCreditPaymentForm: play.api.libs.json.Writes[CreditPaymentForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPaymentForm] {
        def writes(obj: io.flow.experience.v0.models.CreditPaymentForm) = {
          jsObjectCreditPaymentForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCreditPaymentPutForm: play.api.libs.json.Reads[CreditPaymentPutForm] = {
      (
        (__ \ "order_number").read[String] and
        (__ \ "description").read[String] and
        (__ \ "amount").read[BigDecimal] and
        (__ \ "currency").read[String] and
        (__ \ "max").read[BigDecimal] and
        (__ \ "attributes").readNullable[Map[String, String]]
      )(CreditPaymentPutForm.apply _)
    }

    def jsObjectCreditPaymentPutForm(obj: io.flow.experience.v0.models.CreditPaymentPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber),
        "description" -> play.api.libs.json.JsString(obj.description),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "max" -> play.api.libs.json.JsNumber(obj.max)
      ) ++ (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceCreditPaymentPutForm: play.api.libs.json.Writes[CreditPaymentPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPaymentPutForm] {
        def writes(obj: io.flow.experience.v0.models.CreditPaymentPutForm) = {
          jsObjectCreditPaymentPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCreditPaymentVersion: play.api.libs.json.Reads[CreditPaymentVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.common.v0.models.ChangeType] and
        (__ \ "credit_payment").read[io.flow.experience.v0.models.CreditPayment]
      )(CreditPaymentVersion.apply _)
    }

    def jsObjectCreditPaymentVersion(obj: io.flow.experience.v0.models.CreditPaymentVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "credit_payment" -> jsObjectCreditPayment(obj.creditPayment)
      )
    }

    implicit def jsonWritesExperienceCreditPaymentVersion: play.api.libs.json.Writes[CreditPaymentVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPaymentVersion] {
        def writes(obj: io.flow.experience.v0.models.CreditPaymentVersion) = {
          jsObjectCreditPaymentVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceDeliveredDutySetting: play.api.libs.json.Reads[DeliveredDutySetting] = {
      (
        (__ \ "default").read[io.flow.common.v0.models.DeliveredDuty] and
        (__ \ "available").read[Seq[io.flow.common.v0.models.DeliveredDuty]]
      )(DeliveredDutySetting.apply _)
    }

    def jsObjectDeliveredDutySetting(obj: io.flow.experience.v0.models.DeliveredDutySetting): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "default" -> play.api.libs.json.JsString(obj.default.toString),
        "available" -> play.api.libs.json.Json.toJson(obj.available)
      )
    }

    implicit def jsonWritesExperienceDeliveredDutySetting: play.api.libs.json.Writes[DeliveredDutySetting] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.DeliveredDutySetting] {
        def writes(obj: io.flow.experience.v0.models.DeliveredDutySetting) = {
          jsObjectDeliveredDutySetting(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperience: play.api.libs.json.Reads[Experience] = {
      (
        (__ \ "id").read[String] and
        (__ \ "key").read[String] and
        (__ \ "name").read[String] and
        (__ \ "delivered_duty").read[io.flow.common.v0.models.DeliveredDuty] and
        (__ \ "region").read[io.flow.experience.v0.models.RegionReference] and
        (__ \ "country").read[String] and
        (__ \ "currency").read[String] and
        (__ \ "language").read[String] and
        (__ \ "measurement_system").read[io.flow.common.v0.models.MeasurementSystem] and
        (__ \ "subcatalog").read[io.flow.catalog.v0.models.SubcatalogReference] and
        (__ \ "position").read[Long] and
        (__ \ "settings").read[io.flow.experience.v0.models.ExperienceSettings]
      )(Experience.apply _)
    }

    def jsObjectExperience(obj: io.flow.experience.v0.models.Experience): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "region" -> jsObjectRegionReference(obj.region),
        "country" -> play.api.libs.json.JsString(obj.country),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "language" -> play.api.libs.json.JsString(obj.language),
        "measurement_system" -> play.api.libs.json.JsString(obj.measurementSystem.toString),
        "subcatalog" -> io.flow.catalog.v0.models.json.jsObjectSubcatalogReference(obj.subcatalog),
        "position" -> play.api.libs.json.JsNumber(obj.position),
        "settings" -> jsObjectExperienceSettings(obj.settings)
      )
    }

    implicit def jsonReadsExperienceExperienceDefaults: play.api.libs.json.Reads[ExperienceDefaults] = {
      (
        (__ \ "key").read[String] and
        (__ \ "name").read[String] and
        (__ \ "delivered_duty").read[io.flow.common.v0.models.DeliveredDuty] and
        (__ \ "country").read[String] and
        (__ \ "currency").read[String] and
        (__ \ "language").read[String] and
        (__ \ "measurement_system").read[io.flow.common.v0.models.MeasurementSystem]
      )(ExperienceDefaults.apply _)
    }

    def jsObjectExperienceDefaults(obj: io.flow.experience.v0.models.ExperienceDefaults): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "country" -> play.api.libs.json.JsString(obj.country),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "language" -> play.api.libs.json.JsString(obj.language),
        "measurement_system" -> play.api.libs.json.JsString(obj.measurementSystem.toString)
      )
    }

    implicit def jsonWritesExperienceExperienceDefaults: play.api.libs.json.Writes[ExperienceDefaults] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceDefaults] {
        def writes(obj: io.flow.experience.v0.models.ExperienceDefaults) = {
          jsObjectExperienceDefaults(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceForm: play.api.libs.json.Reads[ExperienceForm] = {
      (
        (__ \ "region_id").read[String] and
        (__ \ "name").read[String] and
        (__ \ "delivered_duty").readNullable[io.flow.common.v0.models.DeliveredDuty] and
        (__ \ "country").readNullable[String] and
        (__ \ "currency").readNullable[String] and
        (__ \ "language").readNullable[String] and
        (__ \ "key").readNullable[String] and
        (__ \ "measurement_system").readNullable[io.flow.common.v0.models.MeasurementSystem] and
        (__ \ "subcatalog_id").readNullable[String] and
        (__ \ "position").readNullable[Long]
      )(ExperienceForm.apply _)
    }

    def jsObjectExperienceForm(obj: io.flow.experience.v0.models.ExperienceForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "region_id" -> play.api.libs.json.JsString(obj.regionId),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.deliveredDuty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("delivered_duty" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.country match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("country" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.language match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("language" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.measurementSystem match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("measurement_system" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.subcatalogId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("subcatalog_id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesExperienceExperienceForm: play.api.libs.json.Writes[ExperienceForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceForm] {
        def writes(obj: io.flow.experience.v0.models.ExperienceForm) = {
          jsObjectExperienceForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceGeo: play.api.libs.json.Reads[ExperienceGeo] = {
      (
        (__ \ "key").read[String] and
        (__ \ "name").read[String] and
        (__ \ "region").read[io.flow.experience.v0.models.RegionReference] and
        (__ \ "country").read[String] and
        (__ \ "currency").read[String] and
        (__ \ "language").read[String] and
        (__ \ "measurement_system").read[io.flow.common.v0.models.MeasurementSystem]
      )(ExperienceGeo.apply _)
    }

    def jsObjectExperienceGeo(obj: io.flow.experience.v0.models.ExperienceGeo): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "region" -> jsObjectRegionReference(obj.region),
        "country" -> play.api.libs.json.JsString(obj.country),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "language" -> play.api.libs.json.JsString(obj.language),
        "measurement_system" -> play.api.libs.json.JsString(obj.measurementSystem.toString)
      )
    }

    implicit def jsonWritesExperienceExperienceGeo: play.api.libs.json.Writes[ExperienceGeo] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceGeo] {
        def writes(obj: io.flow.experience.v0.models.ExperienceGeo) = {
          jsObjectExperienceGeo(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePaymentMethodRuleForm: play.api.libs.json.Reads[ExperiencePaymentMethodRuleForm] = {
      (
        (__ \ "payment_method_id").read[String] and
        (__ \ "tags").read[Seq[io.flow.experience.v0.models.ExperiencePaymentMethodTag]]
      )(ExperiencePaymentMethodRuleForm.apply _)
    }

    def jsObjectExperiencePaymentMethodRuleForm(obj: io.flow.experience.v0.models.ExperiencePaymentMethodRuleForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "payment_method_id" -> play.api.libs.json.JsString(obj.paymentMethodId),
        "tags" -> play.api.libs.json.Json.toJson(obj.tags)
      )
    }

    implicit def jsonWritesExperienceExperiencePaymentMethodRuleForm: play.api.libs.json.Writes[ExperiencePaymentMethodRuleForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePaymentMethodRuleForm] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePaymentMethodRuleForm) = {
          jsObjectExperiencePaymentMethodRuleForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceReference: play.api.libs.json.Reads[ExperienceReference] = {
      (__ \ "key").read[String].map { x => new ExperienceReference(key = x) }
    }

    def jsObjectExperienceReference(obj: io.flow.experience.v0.models.ExperienceReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonReadsExperienceExperienceSettings: play.api.libs.json.Reads[ExperienceSettings] = {
      (__ \ "delivered_duty").read[io.flow.experience.v0.models.DeliveredDutySetting].map { x => new ExperienceSettings(deliveredDuty = x) }
    }

    def jsObjectExperienceSettings(obj: io.flow.experience.v0.models.ExperienceSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "delivered_duty" -> jsObjectDeliveredDutySetting(obj.deliveredDuty)
      )
    }

    implicit def jsonWritesExperienceExperienceSettings: play.api.libs.json.Writes[ExperienceSettings] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceSettings] {
        def writes(obj: io.flow.experience.v0.models.ExperienceSettings) = {
          jsObjectExperienceSettings(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceVersion: play.api.libs.json.Reads[ExperienceVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.common.v0.models.ChangeType] and
        (__ \ "experience").read[io.flow.experience.v0.models.Experience]
      )(ExperienceVersion.apply _)
    }

    def jsObjectExperienceVersion(obj: io.flow.experience.v0.models.ExperienceVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "experience" -> jsObjectExperience(obj.experience)
      )
    }

    implicit def jsonWritesExperienceExperienceVersion: play.api.libs.json.Writes[ExperienceVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceVersion] {
        def writes(obj: io.flow.experience.v0.models.ExperienceVersion) = {
          jsObjectExperienceVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceFerence: play.api.libs.json.Reads[Ference] = {
      (__ \ "id").read[String].map { x => new Ference(id = x) }
    }

    def jsObjectFerence(obj: io.flow.experience.v0.models.Ference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesExperienceFerence: play.api.libs.json.Writes[Ference] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Ference] {
        def writes(obj: io.flow.experience.v0.models.Ference) = {
          jsObjectFerence(obj)
        }
      }
    }

    implicit def jsonReadsExperienceFreeShipping: play.api.libs.json.Reads[FreeShipping] = {
      (__ \ "trigger").read[io.flow.experience.v0.models.PromotionTrigger].map { x => new FreeShipping(trigger = x) }
    }

    def jsObjectFreeShipping(obj: io.flow.experience.v0.models.FreeShipping): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "trigger" -> jsObjectPromotionTrigger(obj.trigger)
      )
    }

    implicit def jsonReadsExperienceItemMargin: play.api.libs.json.Reads[ItemMargin] = {
      (
        (__ \ "id").read[String] and
        (__ \ "key").read[String] and
        (__ \ "name").read[String] and
        (__ \ "q").read[String] and
        (__ \ "fixed").read[BigDecimal] and
        (__ \ "percent").read[BigDecimal] and
        (__ \ "position").read[Long]
      )(ItemMargin.apply _)
    }

    def jsObjectItemMargin(obj: io.flow.experience.v0.models.ItemMargin): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "q" -> play.api.libs.json.JsString(obj.q),
        "fixed" -> play.api.libs.json.JsNumber(obj.fixed),
        "percent" -> play.api.libs.json.JsNumber(obj.percent),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      )
    }

    implicit def jsonWritesExperienceItemMargin: play.api.libs.json.Writes[ItemMargin] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ItemMargin] {
        def writes(obj: io.flow.experience.v0.models.ItemMargin) = {
          jsObjectItemMargin(obj)
        }
      }
    }

    implicit def jsonReadsExperienceItemMarginPostForm: play.api.libs.json.Reads[ItemMarginPostForm] = {
      (
        (__ \ "name").read[String] and
        (__ \ "q").read[String] and
        (__ \ "key").readNullable[String] and
        (__ \ "fixed").readNullable[BigDecimal] and
        (__ \ "percent").readNullable[BigDecimal] and
        (__ \ "position").readNullable[Long]
      )(ItemMarginPostForm.apply _)
    }

    def jsObjectItemMarginPostForm(obj: io.flow.experience.v0.models.ItemMarginPostForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "q" -> play.api.libs.json.JsString(obj.q)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.fixed match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("fixed" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.percent match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("percent" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesExperienceItemMarginPostForm: play.api.libs.json.Writes[ItemMarginPostForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ItemMarginPostForm] {
        def writes(obj: io.flow.experience.v0.models.ItemMarginPostForm) = {
          jsObjectItemMarginPostForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceItemMarginPutForm: play.api.libs.json.Reads[ItemMarginPutForm] = {
      (
        (__ \ "name").read[String] and
        (__ \ "q").read[String] and
        (__ \ "fixed").readNullable[BigDecimal] and
        (__ \ "percent").readNullable[BigDecimal] and
        (__ \ "position").readNullable[Long]
      )(ItemMarginPutForm.apply _)
    }

    def jsObjectItemMarginPutForm(obj: io.flow.experience.v0.models.ItemMarginPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "q" -> play.api.libs.json.JsString(obj.q)
      ) ++ (obj.fixed match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("fixed" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.percent match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("percent" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesExperienceItemMarginPutForm: play.api.libs.json.Writes[ItemMarginPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ItemMarginPutForm] {
        def writes(obj: io.flow.experience.v0.models.ItemMarginPutForm) = {
          jsObjectItemMarginPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceItemMarginVersion: play.api.libs.json.Reads[ItemMarginVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.common.v0.models.ChangeType] and
        (__ \ "item_margin").read[io.flow.experience.v0.models.ItemMargin]
      )(ItemMarginVersion.apply _)
    }

    def jsObjectItemMarginVersion(obj: io.flow.experience.v0.models.ItemMarginVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "item_margin" -> jsObjectItemMargin(obj.itemMargin)
      )
    }

    implicit def jsonWritesExperienceItemMarginVersion: play.api.libs.json.Writes[ItemMarginVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ItemMarginVersion] {
        def writes(obj: io.flow.experience.v0.models.ItemMarginVersion) = {
          jsObjectItemMarginVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceLine: play.api.libs.json.Reads[Line] = {
      (
        (__ \ "item_number").read[String] and
        (__ \ "quantity").read[Long] and
        (__ \ "price").read[io.flow.common.v0.models.PriceWithBase] and
        (__ \ "total").read[io.flow.common.v0.models.PriceWithBase]
      )(Line.apply _)
    }

    def jsObjectLine(obj: io.flow.experience.v0.models.Line): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "item_number" -> play.api.libs.json.JsString(obj.itemNumber),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "price" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.price),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total)
      )
    }

    implicit def jsonWritesExperienceLine: play.api.libs.json.Writes[Line] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Line] {
        def writes(obj: io.flow.experience.v0.models.Line) = {
          jsObjectLine(obj)
        }
      }
    }

    implicit def jsonReadsExperienceLocalizedLineItem: play.api.libs.json.Reads[LocalizedLineItem] = {
      (
        (__ \ "number").read[String] and
        (__ \ "name").read[String] and
        (__ \ "quantity").read[Long] and
        (__ \ "center").readNullable[String] and
        (__ \ "price").readNullable[io.flow.common.v0.models.Money] and
        (__ \ "discount").readNullable[io.flow.common.v0.models.Money] and
        (__ \ "attributes").readNullable[Map[String, String]] and
        (__ \ "local").read[io.flow.catalog.v0.models.Local]
      )(LocalizedLineItem.apply _)
    }

    def jsObjectLocalizedLineItem(obj: io.flow.experience.v0.models.LocalizedLineItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "name" -> play.api.libs.json.JsString(obj.name),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "local" -> io.flow.catalog.v0.models.json.jsObjectLocal(obj.local)
      ) ++ (obj.center match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("center" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.price match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceLocalizedLineItem: play.api.libs.json.Writes[LocalizedLineItem] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.LocalizedLineItem] {
        def writes(obj: io.flow.experience.v0.models.LocalizedLineItem) = {
          jsObjectLocalizedLineItem(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrder: play.api.libs.json.Reads[Order] = {
      (
        (__ \ "id").read[String] and
        (__ \ "number").read[String] and
        (__ \ "experience").readNullable[io.flow.experience.v0.models.ExpandableExperience] and
        (__ \ "customer").read[io.flow.common.v0.models.Customer] and
        (__ \ "delivered_duty").read[io.flow.common.v0.models.DeliveredDuty] and
        (__ \ "destination").read[io.flow.experience.v0.models.OrderAddress] and
        (__ \ "expires_at").read[_root_.org.joda.time.DateTime] and
        (__ \ "items").read[Seq[io.flow.experience.v0.models.LocalizedLineItem]] and
        (__ \ "deliveries").read[Seq[io.flow.fulfillment.v0.models.Delivery]] and
        (__ \ "selections").read[Seq[String]] and
        (__ \ "prices").read[Seq[io.flow.experience.v0.models.OrderPriceDetail]] and
        (__ \ "total").read[io.flow.catalog.v0.models.LocalizedTotal] and
        (__ \ "attributes").read[Map[String, String]] and
        (__ \ "submitted_at").readNullable[_root_.org.joda.time.DateTime] and
        (__ \ "lines").readNullable[Seq[io.flow.experience.v0.models.Line]] and
        (__ \ "identifiers").readNullable[Seq[String]] and
        (__ \ "promotions").readNullable[io.flow.experience.v0.models.Promotions] and
        (__ \ "payments").readNullable[Seq[io.flow.experience.v0.models.OrderPayment]] and
        (__ \ "balance").readNullable[io.flow.catalog.v0.models.LocalizedTotal]
      )(Order.apply _)
    }

    def jsObjectOrder(obj: io.flow.experience.v0.models.Order): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number),
        "customer" -> io.flow.common.v0.models.json.jsObjectCustomer(obj.customer),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "destination" -> jsObjectOrderAddress(obj.destination),
        "expires_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.expiresAt)),
        "items" -> play.api.libs.json.Json.toJson(obj.items),
        "deliveries" -> play.api.libs.json.Json.toJson(obj.deliveries),
        "selections" -> play.api.libs.json.Json.toJson(obj.selections),
        "prices" -> play.api.libs.json.Json.toJson(obj.prices),
        "total" -> io.flow.catalog.v0.models.json.jsObjectLocalizedTotal(obj.total),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.experience match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("experience" -> jsObjectExpandableExperience(x))
      }) ++
      (obj.submittedAt match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("submitted_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
      (obj.lines match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("lines" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.identifiers match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("identifiers" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.promotions match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("promotions" -> jsObjectPromotions(x))
      }) ++
      (obj.payments match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("payments" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.balance match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("balance" -> io.flow.catalog.v0.models.json.jsObjectLocalizedTotal(x))
      })
    }

    implicit def jsonReadsExperienceOrderAddress: play.api.libs.json.Reads[OrderAddress] = {
      (
        (__ \ "text").readNullable[String] and
        (__ \ "streets").readNullable[Seq[String]] and
        (__ \ "city").readNullable[String] and
        (__ \ "province").readNullable[String] and
        (__ \ "postal").readNullable[String] and
        (__ \ "country").readNullable[String] and
        (__ \ "latitude").readNullable[String] and
        (__ \ "longitude").readNullable[String] and
        (__ \ "contact").readNullable[io.flow.common.v0.models.Contact]
      )(OrderAddress.apply _)
    }

    def jsObjectOrderAddress(obj: io.flow.experience.v0.models.OrderAddress): play.api.libs.json.JsObject = {
      (obj.text match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("text" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.streets match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("streets" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.city match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("city" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.province match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("province" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.postal match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("postal" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.country match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("country" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.latitude match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("latitude" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.longitude match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("longitude" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.contact match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("contact" -> io.flow.common.v0.models.json.jsObjectContact(x))
      })
    }

    implicit def jsonWritesExperienceOrderAddress: play.api.libs.json.Writes[OrderAddress] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderAddress] {
        def writes(obj: io.flow.experience.v0.models.OrderAddress) = {
          jsObjectOrderAddress(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderError: play.api.libs.json.Reads[OrderError] = {
      (
        (__ \ "code").read[io.flow.experience.v0.models.OrderErrorCode] and
        (__ \ "messages").read[Seq[String]] and
        (__ \ "numbers").readNullable[Seq[String]] and
        (__ \ "destination_country").readNullable[io.flow.reference.v0.models.Country]
      )(OrderError.apply _)
    }

    def jsObjectOrderError(obj: io.flow.experience.v0.models.OrderError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages)
      ) ++ (obj.numbers match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("numbers" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.destinationCountry match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination_country" -> io.flow.reference.v0.models.json.jsObjectCountry(x))
      })
    }

    implicit def jsonWritesExperienceOrderError: play.api.libs.json.Writes[OrderError] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderError] {
        def writes(obj: io.flow.experience.v0.models.OrderError) = {
          jsObjectOrderError(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderEstimate: play.api.libs.json.Reads[OrderEstimate] = {
      (
        (__ \ "id").read[String] and
        (__ \ "items").read[Seq[io.flow.experience.v0.models.LocalizedLineItem]] and
        (__ \ "destination").read[io.flow.experience.v0.models.OrderAddress] and
        (__ \ "deliveries").read[Seq[io.flow.fulfillment.v0.models.Delivery]] and
        (__ \ "prices").read[Seq[io.flow.experience.v0.models.OrderPriceDetail]] and
        (__ \ "selections").read[Seq[String]] and
        (__ \ "total").read[io.flow.catalog.v0.models.LocalizedTotal] and
        (__ \ "lines").readNullable[Seq[io.flow.experience.v0.models.Line]] and
        (__ \ "promotions").readNullable[io.flow.experience.v0.models.Promotions]
      )(OrderEstimate.apply _)
    }

    def jsObjectOrderEstimate(obj: io.flow.experience.v0.models.OrderEstimate): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "items" -> play.api.libs.json.Json.toJson(obj.items),
        "destination" -> jsObjectOrderAddress(obj.destination),
        "deliveries" -> play.api.libs.json.Json.toJson(obj.deliveries),
        "prices" -> play.api.libs.json.Json.toJson(obj.prices),
        "selections" -> play.api.libs.json.Json.toJson(obj.selections),
        "total" -> io.flow.catalog.v0.models.json.jsObjectLocalizedTotal(obj.total)
      ) ++ (obj.lines match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("lines" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.promotions match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("promotions" -> jsObjectPromotions(x))
      })
    }

    implicit def jsonWritesExperienceOrderEstimate: play.api.libs.json.Writes[OrderEstimate] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderEstimate] {
        def writes(obj: io.flow.experience.v0.models.OrderEstimate) = {
          jsObjectOrderEstimate(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderEstimateForm: play.api.libs.json.Reads[OrderEstimateForm] = {
      (
        (__ \ "items").read[Seq[io.flow.common.v0.models.LineItemForm]] and
        (__ \ "destination").readNullable[io.flow.experience.v0.models.OrderAddress] and
        (__ \ "selections").readNullable[Seq[String]]
      )(OrderEstimateForm.apply _)
    }

    def jsObjectOrderEstimateForm(obj: io.flow.experience.v0.models.OrderEstimateForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> jsObjectOrderAddress(x))
      }) ++
      (obj.selections match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("selections" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceOrderEstimateForm: play.api.libs.json.Writes[OrderEstimateForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderEstimateForm] {
        def writes(obj: io.flow.experience.v0.models.OrderEstimateForm) = {
          jsObjectOrderEstimateForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderForm: play.api.libs.json.Reads[OrderForm] = {
      (
        (__ \ "customer").readNullable[io.flow.common.v0.models.Customer] and
        (__ \ "items").read[Seq[io.flow.common.v0.models.LineItemForm]] and
        (__ \ "delivered_duty").readNullable[io.flow.common.v0.models.DeliveredDuty] and
        (__ \ "number").readNullable[String] and
        (__ \ "destination").readNullable[io.flow.experience.v0.models.OrderAddress] and
        (__ \ "discount").readNullable[io.flow.common.v0.models.Money] and
        (__ \ "attributes").readNullable[Map[String, String]]
      )(OrderForm.apply _)
    }

    def jsObjectOrderForm(obj: io.flow.experience.v0.models.OrderForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.customer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("customer" -> io.flow.common.v0.models.json.jsObjectCustomer(x))
      }) ++
      (obj.deliveredDuty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("delivered_duty" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> jsObjectOrderAddress(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceOrderForm: play.api.libs.json.Writes[OrderForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderForm] {
        def writes(obj: io.flow.experience.v0.models.OrderForm) = {
          jsObjectOrderForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderIdentifier: play.api.libs.json.Reads[OrderIdentifier] = {
      (
        (__ \ "id").read[String] and
        (__ \ "order").read[io.flow.experience.v0.models.OrderReference] and
        (__ \ "number").read[String]
      )(OrderIdentifier.apply _)
    }

    def jsObjectOrderIdentifier(obj: io.flow.experience.v0.models.OrderIdentifier): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "order" -> jsObjectOrderReference(obj.order),
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonWritesExperienceOrderIdentifier: play.api.libs.json.Writes[OrderIdentifier] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderIdentifier] {
        def writes(obj: io.flow.experience.v0.models.OrderIdentifier) = {
          jsObjectOrderIdentifier(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderIdentifierForm: play.api.libs.json.Reads[OrderIdentifierForm] = {
      (
        (__ \ "order").read[String] and
        (__ \ "number").read[String]
      )(OrderIdentifierForm.apply _)
    }

    def jsObjectOrderIdentifierForm(obj: io.flow.experience.v0.models.OrderIdentifierForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order" -> play.api.libs.json.JsString(obj.order),
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonWritesExperienceOrderIdentifierForm: play.api.libs.json.Writes[OrderIdentifierForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderIdentifierForm] {
        def writes(obj: io.flow.experience.v0.models.OrderIdentifierForm) = {
          jsObjectOrderIdentifierForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderIdentifierPutForm: play.api.libs.json.Reads[OrderIdentifierPutForm] = {
      (__ \ "order").read[String].map { x => new OrderIdentifierPutForm(order = x) }
    }

    def jsObjectOrderIdentifierPutForm(obj: io.flow.experience.v0.models.OrderIdentifierPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order" -> play.api.libs.json.JsString(obj.order)
      )
    }

    implicit def jsonWritesExperienceOrderIdentifierPutForm: play.api.libs.json.Writes[OrderIdentifierPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderIdentifierPutForm] {
        def writes(obj: io.flow.experience.v0.models.OrderIdentifierPutForm) = {
          jsObjectOrderIdentifierPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderIdentifierVersion: play.api.libs.json.Reads[OrderIdentifierVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.common.v0.models.ChangeType] and
        (__ \ "order_identifier").read[io.flow.experience.v0.models.OrderIdentifier]
      )(OrderIdentifierVersion.apply _)
    }

    def jsObjectOrderIdentifierVersion(obj: io.flow.experience.v0.models.OrderIdentifierVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "order_identifier" -> jsObjectOrderIdentifier(obj.orderIdentifier)
      )
    }

    implicit def jsonWritesExperienceOrderIdentifierVersion: play.api.libs.json.Writes[OrderIdentifierVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderIdentifierVersion] {
        def writes(obj: io.flow.experience.v0.models.OrderIdentifierVersion) = {
          jsObjectOrderIdentifierVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPayment: play.api.libs.json.Reads[OrderPayment] = {
      (
        (__ \ "id").read[String] and
        (__ \ "type").read[io.flow.experience.v0.models.OrderPaymentType] and
        (__ \ "reference").read[String] and
        (__ \ "description").read[String] and
        (__ \ "total").read[io.flow.common.v0.models.PriceWithBase]
      )(OrderPayment.apply _)
    }

    def jsObjectOrderPayment(obj: io.flow.experience.v0.models.OrderPayment): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "reference" -> play.api.libs.json.JsString(obj.reference),
        "description" -> play.api.libs.json.JsString(obj.description),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total)
      )
    }

    implicit def jsonWritesExperienceOrderPayment: play.api.libs.json.Writes[OrderPayment] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPayment] {
        def writes(obj: io.flow.experience.v0.models.OrderPayment) = {
          jsObjectOrderPayment(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPriceDetail: play.api.libs.json.Reads[OrderPriceDetail] = {
      (
        (__ \ "key").read[io.flow.experience.v0.models.OrderPriceDetailKey] and
        (__ \ "currency").read[String] and
        (__ \ "amount").read[BigDecimal] and
        (__ \ "label").read[String] and
        (__ \ "base").read[io.flow.common.v0.models.Price] and
        (__ \ "components").read[Seq[io.flow.experience.v0.models.OrderPriceDetailComponent]] and
        (__ \ "name").readNullable[String]
      )(OrderPriceDetail.apply _)
    }

    def jsObjectOrderPriceDetail(obj: io.flow.experience.v0.models.OrderPriceDetail): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label),
        "base" -> io.flow.common.v0.models.json.jsObjectPrice(obj.base),
        "components" -> play.api.libs.json.Json.toJson(obj.components)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceOrderPriceDetail: play.api.libs.json.Writes[OrderPriceDetail] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPriceDetail] {
        def writes(obj: io.flow.experience.v0.models.OrderPriceDetail) = {
          jsObjectOrderPriceDetail(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPriceDetailComponent: play.api.libs.json.Reads[OrderPriceDetailComponent] = {
      (
        (__ \ "key").read[io.flow.experience.v0.models.OrderPriceDetailComponentKey] and
        (__ \ "currency").read[String] and
        (__ \ "amount").read[BigDecimal] and
        (__ \ "label").read[String] and
        (__ \ "base").read[io.flow.common.v0.models.Price] and
        (__ \ "name").readNullable[String]
      )(OrderPriceDetailComponent.apply _)
    }

    def jsObjectOrderPriceDetailComponent(obj: io.flow.experience.v0.models.OrderPriceDetailComponent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label),
        "base" -> io.flow.common.v0.models.json.jsObjectPrice(obj.base)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceOrderPriceDetailComponent: play.api.libs.json.Writes[OrderPriceDetailComponent] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPriceDetailComponent] {
        def writes(obj: io.flow.experience.v0.models.OrderPriceDetailComponent) = {
          jsObjectOrderPriceDetailComponent(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPutForm: play.api.libs.json.Reads[OrderPutForm] = {
      (
        (__ \ "items").read[Seq[io.flow.common.v0.models.LineItemForm]] and
        (__ \ "customer").readNullable[io.flow.common.v0.models.Customer] and
        (__ \ "delivered_duty").readNullable[io.flow.common.v0.models.DeliveredDuty] and
        (__ \ "selections").readNullable[Seq[String]] and
        (__ \ "destination").readNullable[io.flow.experience.v0.models.OrderAddress] and
        (__ \ "discount").readNullable[io.flow.common.v0.models.Money] and
        (__ \ "attributes").readNullable[Map[String, String]]
      )(OrderPutForm.apply _)
    }

    def jsObjectOrderPutForm(obj: io.flow.experience.v0.models.OrderPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.customer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("customer" -> io.flow.common.v0.models.json.jsObjectCustomer(x))
      }) ++
      (obj.deliveredDuty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("delivered_duty" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.selections match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("selections" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> jsObjectOrderAddress(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceOrderPutForm: play.api.libs.json.Writes[OrderPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPutForm] {
        def writes(obj: io.flow.experience.v0.models.OrderPutForm) = {
          jsObjectOrderPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderReference: play.api.libs.json.Reads[OrderReference] = {
      (
        (__ \ "id").read[String] and
        (__ \ "number").read[String]
      )(OrderReference.apply _)
    }

    def jsObjectOrderReference(obj: io.flow.experience.v0.models.OrderReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonReadsExperienceOrderVersion: play.api.libs.json.Reads[OrderVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.common.v0.models.ChangeType] and
        (__ \ "order").read[io.flow.experience.v0.models.Order]
      )(OrderVersion.apply _)
    }

    def jsObjectOrderVersion(obj: io.flow.experience.v0.models.OrderVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "order" -> jsObjectOrder(obj.order)
      )
    }

    implicit def jsonWritesExperienceOrderVersion: play.api.libs.json.Writes[OrderVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderVersion] {
        def writes(obj: io.flow.experience.v0.models.OrderVersion) = {
          jsObjectOrderVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOriginalPrices: play.api.libs.json.Reads[OriginalPrices] = {
      (
        (__ \ "value").read[io.flow.common.v0.models.Price] and
        (__ \ "max").read[io.flow.common.v0.models.Price]
      )(OriginalPrices.apply _)
    }

    def jsObjectOriginalPrices(obj: io.flow.experience.v0.models.OriginalPrices): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "value" -> io.flow.common.v0.models.json.jsObjectPrice(obj.value),
        "max" -> io.flow.common.v0.models.json.jsObjectPrice(obj.max)
      )
    }

    implicit def jsonWritesExperienceOriginalPrices: play.api.libs.json.Writes[OriginalPrices] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OriginalPrices] {
        def writes(obj: io.flow.experience.v0.models.OriginalPrices) = {
          jsObjectOriginalPrices(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePaymentMethodRule: play.api.libs.json.Reads[PaymentMethodRule] = {
      (
        (__ \ "tags").read[Seq[io.flow.experience.v0.models.PaymentMethodTag]] and
        (__ \ "payment_method").read[io.flow.reference.v0.models.PaymentMethod] and
        (__ \ "display_position").read[Int]
      )(PaymentMethodRule.apply _)
    }

    def jsObjectPaymentMethodRule(obj: io.flow.experience.v0.models.PaymentMethodRule): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "tags" -> play.api.libs.json.Json.toJson(obj.tags),
        "payment_method" -> io.flow.reference.v0.models.json.jsObjectPaymentMethod(obj.paymentMethod),
        "display_position" -> play.api.libs.json.JsNumber(obj.displayPosition)
      )
    }

    implicit def jsonWritesExperiencePaymentMethodRule: play.api.libs.json.Writes[PaymentMethodRule] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PaymentMethodRule] {
        def writes(obj: io.flow.experience.v0.models.PaymentMethodRule) = {
          jsObjectPaymentMethodRule(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePromotionTrigger: play.api.libs.json.Reads[PromotionTrigger] = {
      (
        (__ \ "type").read[io.flow.experience.v0.models.PromotionTriggerType] and
        (__ \ "min").read[io.flow.common.v0.models.Price] and
        (__ \ "remaining").read[io.flow.common.v0.models.Price] and
        (__ \ "max").readNullable[io.flow.common.v0.models.Price]
      )(PromotionTrigger.apply _)
    }

    def jsObjectPromotionTrigger(obj: io.flow.experience.v0.models.PromotionTrigger): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "min" -> io.flow.common.v0.models.json.jsObjectPrice(obj.min),
        "remaining" -> io.flow.common.v0.models.json.jsObjectPrice(obj.remaining)
      ) ++ (obj.max match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("max" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      })
    }

    implicit def jsonWritesExperiencePromotionTrigger: play.api.libs.json.Writes[PromotionTrigger] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PromotionTrigger] {
        def writes(obj: io.flow.experience.v0.models.PromotionTrigger) = {
          jsObjectPromotionTrigger(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePromotions: play.api.libs.json.Reads[Promotions] = {
      (
        (__ \ "applied").read[Seq[io.flow.experience.v0.models.Promotion]] and
        (__ \ "available").read[Seq[io.flow.experience.v0.models.Promotion]]
      )(Promotions.apply _)
    }

    def jsObjectPromotions(obj: io.flow.experience.v0.models.Promotions): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "applied" -> play.api.libs.json.Json.toJson(obj.applied),
        "available" -> play.api.libs.json.Json.toJson(obj.available)
      )
    }

    implicit def jsonWritesExperiencePromotions: play.api.libs.json.Writes[Promotions] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Promotions] {
        def writes(obj: io.flow.experience.v0.models.Promotions) = {
          jsObjectPromotions(obj)
        }
      }
    }

    implicit def jsonReadsExperienceRegionReference: play.api.libs.json.Reads[RegionReference] = {
      (__ \ "id").read[String].map { x => new RegionReference(id = x) }
    }

    def jsObjectRegionReference(obj: io.flow.experience.v0.models.RegionReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesExperienceRegionReference: play.api.libs.json.Writes[RegionReference] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.RegionReference] {
        def writes(obj: io.flow.experience.v0.models.RegionReference) = {
          jsObjectRegionReference(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationComponent: play.api.libs.json.Reads[AllocationComponent] = new play.api.libs.json.Reads[AllocationComponent] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[AllocationComponent] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[AllocationComponent] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "allocation_detail_component" => js.validate[io.flow.experience.v0.models.AllocationDetailComponent]
          case "allocation_levy_component" => js.validate[io.flow.experience.v0.models.AllocationLevyComponent]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.AllocationComponentUndefinedType(other))
        }
      }
    }

    def jsObjectAllocationComponent(obj: io.flow.experience.v0.models.AllocationComponent): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.AllocationDetailComponent => jsObjectAllocationDetailComponent(x) ++ play.api.libs.json.Json.obj("discriminator" -> "allocation_detail_component")
        case x: io.flow.experience.v0.models.AllocationLevyComponent => jsObjectAllocationLevyComponent(x) ++ play.api.libs.json.Json.obj("discriminator" -> "allocation_levy_component")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceAllocationComponent: play.api.libs.json.Writes[AllocationComponent] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationComponent] {
        def writes(obj: io.flow.experience.v0.models.AllocationComponent) = {
          jsObjectAllocationComponent(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationDetail: play.api.libs.json.Reads[AllocationDetail] = new play.api.libs.json.Reads[AllocationDetail] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[AllocationDetail] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[AllocationDetail] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "allocation_line_detail" => js.validate[io.flow.experience.v0.models.AllocationLineDetail]
          case "allocation_order_detail" => js.validate[io.flow.experience.v0.models.AllocationOrderDetail]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.AllocationDetailUndefinedType(other))
        }
      }
    }

    def jsObjectAllocationDetail(obj: io.flow.experience.v0.models.AllocationDetail): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.AllocationLineDetail => jsObjectAllocationLineDetail(x) ++ play.api.libs.json.Json.obj("discriminator" -> "allocation_line_detail")
        case x: io.flow.experience.v0.models.AllocationOrderDetail => jsObjectAllocationOrderDetail(x) ++ play.api.libs.json.Json.obj("discriminator" -> "allocation_order_detail")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceAllocationDetail: play.api.libs.json.Writes[AllocationDetail] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationDetail] {
        def writes(obj: io.flow.experience.v0.models.AllocationDetail) = {
          jsObjectAllocationDetail(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExpandableExperience: play.api.libs.json.Reads[ExpandableExperience] = new play.api.libs.json.Reads[ExpandableExperience] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ExpandableExperience] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[ExpandableExperience] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "experience" => js.validate[io.flow.experience.v0.models.Experience]
          case "experience_reference" => js.validate[io.flow.experience.v0.models.ExperienceReference]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExpandableExperienceUndefinedType(other))
        }
      }
    }

    def jsObjectExpandableExperience(obj: io.flow.experience.v0.models.ExpandableExperience): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.Experience => jsObjectExperience(x) ++ play.api.libs.json.Json.obj("discriminator" -> "experience")
        case x: io.flow.experience.v0.models.ExperienceReference => jsObjectExperienceReference(x) ++ play.api.libs.json.Json.obj("discriminator" -> "experience_reference")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceExpandableExperience: play.api.libs.json.Writes[ExpandableExperience] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExpandableExperience] {
        def writes(obj: io.flow.experience.v0.models.ExpandableExperience) = {
          jsObjectExpandableExperience(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExpandableOrder: play.api.libs.json.Reads[ExpandableOrder] = new play.api.libs.json.Reads[ExpandableOrder] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ExpandableOrder] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[ExpandableOrder] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "order" => js.validate[io.flow.experience.v0.models.Order]
          case "order_reference" => js.validate[io.flow.experience.v0.models.OrderReference]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExpandableOrderUndefinedType(other))
        }
      }
    }

    def jsObjectExpandableOrder(obj: io.flow.experience.v0.models.ExpandableOrder): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.Order => jsObjectOrder(x) ++ play.api.libs.json.Json.obj("discriminator" -> "order")
        case x: io.flow.experience.v0.models.OrderReference => jsObjectOrderReference(x) ++ play.api.libs.json.Json.obj("discriminator" -> "order_reference")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceExpandableOrder: play.api.libs.json.Writes[ExpandableOrder] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExpandableOrder] {
        def writes(obj: io.flow.experience.v0.models.ExpandableOrder) = {
          jsObjectExpandableOrder(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePaymentMethodTag: play.api.libs.json.Reads[PaymentMethodTag] = new play.api.libs.json.Reads[PaymentMethodTag] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[PaymentMethodTag] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[PaymentMethodTag] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "organization_payment_method_tag" => js.validate[io.flow.experience.v0.models.OrganizationPaymentMethodTag]
          case "experience_payment_method_tag" => js.validate[io.flow.experience.v0.models.ExperiencePaymentMethodTag]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PaymentMethodTagUndefinedType(other))
        }
      }
    }

    def jsObjectPaymentMethodTag(obj: io.flow.experience.v0.models.PaymentMethodTag): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.OrganizationPaymentMethodTag => play.api.libs.json.Json.obj("discriminator" -> "organization_payment_method_tag", "value" -> play.api.libs.json.JsString(x.toString))
        case x: io.flow.experience.v0.models.ExperiencePaymentMethodTag => play.api.libs.json.Json.obj("discriminator" -> "experience_payment_method_tag", "value" -> play.api.libs.json.JsString(x.toString))
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperiencePaymentMethodTag: play.api.libs.json.Writes[PaymentMethodTag] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PaymentMethodTag] {
        def writes(obj: io.flow.experience.v0.models.PaymentMethodTag) = {
          jsObjectPaymentMethodTag(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePromotion: play.api.libs.json.Reads[Promotion] = new play.api.libs.json.Reads[Promotion] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[Promotion] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[Promotion] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "free_shipping" => js.validate[io.flow.experience.v0.models.FreeShipping]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PromotionUndefinedType(other))
        }
      }
    }

    def jsObjectPromotion(obj: io.flow.experience.v0.models.Promotion): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.FreeShipping => jsObjectFreeShipping(x) ++ play.api.libs.json.Json.obj("discriminator" -> "free_shipping")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperiencePromotion: play.api.libs.json.Writes[Promotion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Promotion] {
        def writes(obj: io.flow.experience.v0.models.Promotion) = {
          jsObjectPromotion(obj)
        }
      }
    }
  }
}

package io.flow.experience.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}
    import org.joda.time.{DateTime, LocalDate}
    import org.joda.time.format.ISODateTimeFormat
    import io.flow.experience.v0.models._

    // Type: date-time-iso8601
    implicit val pathBindableTypeDateTimeIso8601 = new PathBindable.Parsing[org.joda.time.DateTime](
      ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
    )

    implicit val queryStringBindableTypeDateTimeIso8601 = new QueryStringBindable.Parsing[org.joda.time.DateTime](
      ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
    )

    // Type: date-iso8601
    implicit val pathBindableTypeDateIso8601 = new PathBindable.Parsing[org.joda.time.LocalDate](
      ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date $key. Example: 2014-04-29"
    )

    implicit val queryStringBindableTypeDateIso8601 = new QueryStringBindable.Parsing[org.joda.time.LocalDate](
      ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date $key. Example: 2014-04-29"
    )

    // Enum: CreditPaymentErrorCode
    private[this] val enumCreditPaymentErrorCodeNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${io.flow.experience.v0.models.CreditPaymentErrorCode.all.mkString(", ")}"

    implicit val pathBindableEnumCreditPaymentErrorCode = new PathBindable.Parsing[io.flow.experience.v0.models.CreditPaymentErrorCode] (
      CreditPaymentErrorCode.fromString(_).get, _.toString, enumCreditPaymentErrorCodeNotFound
    )

    implicit val queryStringBindableEnumCreditPaymentErrorCode = new QueryStringBindable.Parsing[io.flow.experience.v0.models.CreditPaymentErrorCode](
      CreditPaymentErrorCode.fromString(_).get, _.toString, enumCreditPaymentErrorCodeNotFound
    )

    // Enum: ExperiencePaymentMethodTag
    private[this] val enumExperiencePaymentMethodTagNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${io.flow.experience.v0.models.ExperiencePaymentMethodTag.all.mkString(", ")}"

    implicit val pathBindableEnumExperiencePaymentMethodTag = new PathBindable.Parsing[io.flow.experience.v0.models.ExperiencePaymentMethodTag] (
      ExperiencePaymentMethodTag.fromString(_).get, _.toString, enumExperiencePaymentMethodTagNotFound
    )

    implicit val queryStringBindableEnumExperiencePaymentMethodTag = new QueryStringBindable.Parsing[io.flow.experience.v0.models.ExperiencePaymentMethodTag](
      ExperiencePaymentMethodTag.fromString(_).get, _.toString, enumExperiencePaymentMethodTagNotFound
    )

    // Enum: OrderErrorCode
    private[this] val enumOrderErrorCodeNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${io.flow.experience.v0.models.OrderErrorCode.all.mkString(", ")}"

    implicit val pathBindableEnumOrderErrorCode = new PathBindable.Parsing[io.flow.experience.v0.models.OrderErrorCode] (
      OrderErrorCode.fromString(_).get, _.toString, enumOrderErrorCodeNotFound
    )

    implicit val queryStringBindableEnumOrderErrorCode = new QueryStringBindable.Parsing[io.flow.experience.v0.models.OrderErrorCode](
      OrderErrorCode.fromString(_).get, _.toString, enumOrderErrorCodeNotFound
    )

    // Enum: OrderPaymentType
    private[this] val enumOrderPaymentTypeNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${io.flow.experience.v0.models.OrderPaymentType.all.mkString(", ")}"

    implicit val pathBindableEnumOrderPaymentType = new PathBindable.Parsing[io.flow.experience.v0.models.OrderPaymentType] (
      OrderPaymentType.fromString(_).get, _.toString, enumOrderPaymentTypeNotFound
    )

    implicit val queryStringBindableEnumOrderPaymentType = new QueryStringBindable.Parsing[io.flow.experience.v0.models.OrderPaymentType](
      OrderPaymentType.fromString(_).get, _.toString, enumOrderPaymentTypeNotFound
    )

    // Enum: OrderPriceDetailComponentKey
    private[this] val enumOrderPriceDetailComponentKeyNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${io.flow.experience.v0.models.OrderPriceDetailComponentKey.all.mkString(", ")}"

    implicit val pathBindableEnumOrderPriceDetailComponentKey = new PathBindable.Parsing[io.flow.experience.v0.models.OrderPriceDetailComponentKey] (
      OrderPriceDetailComponentKey.fromString(_).get, _.toString, enumOrderPriceDetailComponentKeyNotFound
    )

    implicit val queryStringBindableEnumOrderPriceDetailComponentKey = new QueryStringBindable.Parsing[io.flow.experience.v0.models.OrderPriceDetailComponentKey](
      OrderPriceDetailComponentKey.fromString(_).get, _.toString, enumOrderPriceDetailComponentKeyNotFound
    )

    // Enum: OrderPriceDetailKey
    private[this] val enumOrderPriceDetailKeyNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${io.flow.experience.v0.models.OrderPriceDetailKey.all.mkString(", ")}"

    implicit val pathBindableEnumOrderPriceDetailKey = new PathBindable.Parsing[io.flow.experience.v0.models.OrderPriceDetailKey] (
      OrderPriceDetailKey.fromString(_).get, _.toString, enumOrderPriceDetailKeyNotFound
    )

    implicit val queryStringBindableEnumOrderPriceDetailKey = new QueryStringBindable.Parsing[io.flow.experience.v0.models.OrderPriceDetailKey](
      OrderPriceDetailKey.fromString(_).get, _.toString, enumOrderPriceDetailKeyNotFound
    )

    // Enum: OrderStatus
    private[this] val enumOrderStatusNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${io.flow.experience.v0.models.OrderStatus.all.mkString(", ")}"

    implicit val pathBindableEnumOrderStatus = new PathBindable.Parsing[io.flow.experience.v0.models.OrderStatus] (
      OrderStatus.fromString(_).get, _.toString, enumOrderStatusNotFound
    )

    implicit val queryStringBindableEnumOrderStatus = new QueryStringBindable.Parsing[io.flow.experience.v0.models.OrderStatus](
      OrderStatus.fromString(_).get, _.toString, enumOrderStatusNotFound
    )

    // Enum: OrganizationPaymentMethodTag
    private[this] val enumOrganizationPaymentMethodTagNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${io.flow.experience.v0.models.OrganizationPaymentMethodTag.all.mkString(", ")}"

    implicit val pathBindableEnumOrganizationPaymentMethodTag = new PathBindable.Parsing[io.flow.experience.v0.models.OrganizationPaymentMethodTag] (
      OrganizationPaymentMethodTag.fromString(_).get, _.toString, enumOrganizationPaymentMethodTagNotFound
    )

    implicit val queryStringBindableEnumOrganizationPaymentMethodTag = new QueryStringBindable.Parsing[io.flow.experience.v0.models.OrganizationPaymentMethodTag](
      OrganizationPaymentMethodTag.fromString(_).get, _.toString, enumOrganizationPaymentMethodTagNotFound
    )

    // Enum: PromotionTriggerType
    private[this] val enumPromotionTriggerTypeNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${io.flow.experience.v0.models.PromotionTriggerType.all.mkString(", ")}"

    implicit val pathBindableEnumPromotionTriggerType = new PathBindable.Parsing[io.flow.experience.v0.models.PromotionTriggerType] (
      PromotionTriggerType.fromString(_).get, _.toString, enumPromotionTriggerTypeNotFound
    )

    implicit val queryStringBindableEnumPromotionTriggerType = new QueryStringBindable.Parsing[io.flow.experience.v0.models.PromotionTriggerType](
      PromotionTriggerType.fromString(_).get, _.toString, enumPromotionTriggerTypeNotFound
    )

  }

}


package io.flow.experience.v0 {

  object Constants {

    val BaseUrl = "https://experience.api.flow.io"
    val Namespace = "io.flow.experience.v0"
    val UserAgent = "apibuilder:0.12.61 https://app.apibuilder.io/flow/experience/0.3.76/play_2_5_client"
    val Version = "0.3.76"
    val VersionMajor = 0

  }

  class Client(
    ws: play.api.libs.ws.WSClient,
    val baseUrl: String = "https://experience.api.flow.io",
    auth: scala.Option[io.flow.experience.v0.Authorization] = None,
    defaultHeaders: Seq[(String, String)] = Nil
  ) extends interfaces.Client {
    import io.flow.catalog.v0.models.json._
    import io.flow.common.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.experience.v0.models.json._
    import io.flow.fulfillment.v0.models.json._
    import io.flow.price.v0.models.json._
    import io.flow.reference.v0.models.json._

    private[this] val logger = play.api.Logger("io.flow.experience.v0.Client")

    logger.info(s"Initializing io.flow.experience.v0.Client for url $baseUrl")

    def allocations: Allocations = Allocations

    def creditPayments: CreditPayments = CreditPayments

    def experienceDefaults: ExperienceDefaults = ExperienceDefaults

    def experiences: Experiences = Experiences

    def orderEstimates: OrderEstimates = OrderEstimates

    def orderIdentifiers: OrderIdentifiers = OrderIdentifiers

    def orders: Orders = Orders

    def organizations: Organizations = Organizations

    def paymentMethodRules: PaymentMethodRules = PaymentMethodRules

    object Allocations extends Allocations {
      override def get(
        organization: String,
        number: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Allocation] = {
        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/orders/allocations/${play.utils.UriEncoding.encodePathSegment(number, "UTF-8")}", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.Allocation", r, _.validate[io.flow.experience.v0.models.Allocation])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }
    }

    object CreditPayments extends CreditPayments {
      override def getVersions(
        organization: String,
        id: _root_.scala.Option[Seq[String]] = None,
        key: _root_.scala.Option[Seq[String]] = None,
        limit: Long = 25,
        offset: Long = 0,
        sort: String = "journal_timestamp",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.CreditPaymentVersion]] = {
        val queryParameters = Seq(
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString),
          Some("sort" -> sort)
        ).flatten ++
          id.getOrElse(Nil).map("id" -> _) ++
          key.getOrElse(Nil).map("key" -> _)

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/credit/payments/versions", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.experience.v0.models.CreditPaymentVersion]", r, _.validate[Seq[io.flow.experience.v0.models.CreditPaymentVersion]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def get(
        organization: String,
        id: _root_.scala.Option[Seq[String]] = None,
        key: _root_.scala.Option[Seq[String]] = None,
        orderNumber: _root_.scala.Option[String] = None,
        limit: Long = 25,
        offset: Long = 0,
        sort: String = "-created_at",
        expand: _root_.scala.Option[Seq[String]] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.CreditPayment]] = {
        val queryParameters = Seq(
          orderNumber.map("order_number" -> _),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString),
          Some("sort" -> sort)
        ).flatten ++
          id.getOrElse(Nil).map("id" -> _) ++
          key.getOrElse(Nil).map("key" -> _) ++
          expand.getOrElse(Nil).map("expand" -> _)

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/credit/payments", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.experience.v0.models.CreditPayment]", r, _.validate[Seq[io.flow.experience.v0.models.CreditPayment]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def getByKey(
        organization: String,
        key: String,
        expand: _root_.scala.Option[Seq[String]] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.CreditPayment] = {
        val queryParameters = expand.getOrElse(Nil).map("expand" -> _)

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/credit/payments/${play.utils.UriEncoding.encodePathSegment(key, "UTF-8")}", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.CreditPayment", r, _.validate[io.flow.experience.v0.models.CreditPayment])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def post(
        organization: String,
        creditPaymentForm: io.flow.experience.v0.models.CreditPaymentForm,
        expand: _root_.scala.Option[Seq[String]] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.CreditPayment] = {
        val payload = play.api.libs.json.Json.toJson(creditPaymentForm)

        val queryParameters = expand.getOrElse(Nil).map("expand" -> _)

        _executeRequest("POST", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/credit/payments", body = Some(payload), queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 201 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.CreditPayment", r, _.validate[io.flow.experience.v0.models.CreditPayment])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.CreditPaymentErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 201, 401, 404, 422")
        }
      }

      override def putByKey(
        organization: String,
        key: String,
        creditPaymentPutForm: io.flow.experience.v0.models.CreditPaymentPutForm,
        expand: _root_.scala.Option[Seq[String]] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.CreditPayment] = {
        val payload = play.api.libs.json.Json.toJson(creditPaymentPutForm)

        val queryParameters = expand.getOrElse(Nil).map("expand" -> _)

        _executeRequest("PUT", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/credit/payments/${play.utils.UriEncoding.encodePathSegment(key, "UTF-8")}", body = Some(payload), queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.CreditPayment", r, _.validate[io.flow.experience.v0.models.CreditPayment])
          case r if r.status == 201 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.CreditPayment", r, _.validate[io.flow.experience.v0.models.CreditPayment])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.CreditPaymentErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 201, 401, 404, 422")
        }
      }

      override def deleteByKey(
        organization: String,
        key: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] = {
        _executeRequest("DELETE", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/credit/payments/${play.utils.UriEncoding.encodePathSegment(key, "UTF-8")}", requestHeaders = requestHeaders).map {
          case r if r.status == 204 => ()
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 204, 401, 404")
        }
      }
    }

    object ExperienceDefaults extends ExperienceDefaults {
      override def get(
        organization: String,
        regionId: _root_.scala.Option[String] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.ExperienceDefaults] = {
        val queryParameters = Seq(
          regionId.map("region_id" -> _)
        ).flatten

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experience/defaults", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.ExperienceDefaults", r, _.validate[io.flow.experience.v0.models.ExperienceDefaults])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }
    }

    object Experiences extends Experiences {
      override def getPromotionsAndAvailableByKey(
        organization: String,
        key: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.Promotion]] = {
        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(key, "UTF-8")}/promotions/available", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.experience.v0.models.Promotion]", r, _.validate[Seq[io.flow.experience.v0.models.Promotion]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def getVersions(
        organization: String,
        id: _root_.scala.Option[Seq[String]] = None,
        key: _root_.scala.Option[Seq[String]] = None,
        limit: Long = 25,
        offset: Long = 0,
        sort: String = "journal_timestamp",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.ExperienceVersion]] = {
        val queryParameters = Seq(
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString),
          Some("sort" -> sort)
        ).flatten ++
          id.getOrElse(Nil).map("id" -> _) ++
          key.getOrElse(Nil).map("key" -> _)

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/versions", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.experience.v0.models.ExperienceVersion]", r, _.validate[Seq[io.flow.experience.v0.models.ExperienceVersion]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def get(
        organization: String,
        id: _root_.scala.Option[Seq[String]] = None,
        key: _root_.scala.Option[Seq[String]] = None,
        name: _root_.scala.Option[String] = None,
        region: _root_.scala.Option[String] = None,
        currency: _root_.scala.Option[String] = None,
        subcatalog: _root_.scala.Option[String] = None,
        ip: _root_.scala.Option[String] = None,
        limit: Long = 25,
        offset: Long = 0,
        sort: String = "name",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.Experience]] = {
        val queryParameters = Seq(
          name.map("name" -> _),
          region.map("region" -> _),
          currency.map("currency" -> _),
          subcatalog.map("subcatalog" -> _),
          ip.map("ip" -> _),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString),
          Some("sort" -> sort)
        ).flatten ++
          id.getOrElse(Nil).map("id" -> _) ++
          key.getOrElse(Nil).map("key" -> _)

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.experience.v0.models.Experience]", r, _.validate[Seq[io.flow.experience.v0.models.Experience]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def getItems(
        organization: String,
        number: _root_.scala.Option[Seq[String]] = None,
        status: _root_.scala.Option[Seq[io.flow.catalog.v0.models.SubcatalogItemStatus]] = None,
        experience: _root_.scala.Option[String] = None,
        country: _root_.scala.Option[String] = None,
        ip: _root_.scala.Option[String] = None,
        currency: _root_.scala.Option[String] = None,
        language: _root_.scala.Option[String] = None,
        limit: Long = 25,
        offset: Long = 0,
        sort: String = "-created_at",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.catalog.v0.models.Item]] = {
        val queryParameters = Seq(
          experience.map("experience" -> _),
          country.map("country" -> _),
          ip.map("ip" -> _),
          currency.map("currency" -> _),
          language.map("language" -> _),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString),
          Some("sort" -> sort)
        ).flatten ++
          number.getOrElse(Nil).map("number" -> _) ++
          status.getOrElse(Nil).map("status" -> _.toString)

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/items", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.catalog.v0.models.Item]", r, _.validate[Seq[io.flow.catalog.v0.models.Item]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.GenericErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404, 422")
        }
      }

      override def getItemsByNumber(
        organization: String,
        number: String,
        experience: _root_.scala.Option[String] = None,
        country: _root_.scala.Option[String] = None,
        ip: _root_.scala.Option[String] = None,
        currency: _root_.scala.Option[String] = None,
        language: _root_.scala.Option[String] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.catalog.v0.models.Item] = {
        val queryParameters = Seq(
          experience.map("experience" -> _),
          country.map("country" -> _),
          ip.map("ip" -> _),
          currency.map("currency" -> _),
          language.map("language" -> _)
        ).flatten

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/items/${play.utils.UriEncoding.encodePathSegment(number, "UTF-8")}", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.catalog.v0.models.Item", r, _.validate[io.flow.catalog.v0.models.Item])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.GenericErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404, 422")
        }
      }

      override def getConversionsByBaseAndAmount(
        organization: String,
        base: String,
        amount: String,
        experience: _root_.scala.Option[String] = None,
        country: _root_.scala.Option[String] = None,
        ip: _root_.scala.Option[String] = None,
        currency: _root_.scala.Option[String] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.common.v0.models.PriceWithBase] = {
        val queryParameters = Seq(
          experience.map("experience" -> _),
          country.map("country" -> _),
          ip.map("ip" -> _),
          currency.map("currency" -> _)
        ).flatten

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/conversions/${play.utils.UriEncoding.encodePathSegment(base, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(amount, "UTF-8")}", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.common.v0.models.PriceWithBase", r, _.validate[io.flow.common.v0.models.PriceWithBase])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.GenericErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404, 422")
        }
      }

      override def getByKey(
        organization: String,
        key: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Experience] = {
        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(key, "UTF-8")}", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.Experience", r, _.validate[io.flow.experience.v0.models.Experience])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def getItemsAndPriceByKeyAndNumber(
        organization: String,
        key: String,
        number: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.price.v0.models.PriceCheck] = {
        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(key, "UTF-8")}/items/${play.utils.UriEncoding.encodePathSegment(number, "UTF-8")}/price", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.price.v0.models.PriceCheck", r, _.validate[io.flow.price.v0.models.PriceCheck])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def post(
        organization: String,
        experienceForm: io.flow.experience.v0.models.ExperienceForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Experience] = {
        val payload = play.api.libs.json.Json.toJson(experienceForm)

        _executeRequest("POST", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 201 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.Experience", r, _.validate[io.flow.experience.v0.models.Experience])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.GenericErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 201, 401, 404, 422")
        }
      }

      override def putByKey(
        organization: String,
        key: String,
        experienceForm: io.flow.experience.v0.models.ExperienceForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Experience] = {
        val payload = play.api.libs.json.Json.toJson(experienceForm)

        _executeRequest("PUT", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(key, "UTF-8")}", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.Experience", r, _.validate[io.flow.experience.v0.models.Experience])
          case r if r.status == 201 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.Experience", r, _.validate[io.flow.experience.v0.models.Experience])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.GenericErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 201, 401, 404, 422")
        }
      }

      override def deleteByKey(
        organization: String,
        key: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] = {
        _executeRequest("DELETE", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(key, "UTF-8")}", requestHeaders = requestHeaders).map {
          case r if r.status == 204 => ()
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 204, 401, 404")
        }
      }

      override def getPricingByKey(
        organization: String,
        key: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.price.v0.models.Pricing] = {
        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(key, "UTF-8")}/pricing", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.price.v0.models.Pricing", r, _.validate[io.flow.price.v0.models.Pricing])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def putPricingByKey(
        organization: String,
        key: String,
        pricing: io.flow.price.v0.models.Pricing,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.price.v0.models.Pricing] = {
        val payload = play.api.libs.json.Json.toJson(pricing)

        _executeRequest("PUT", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(key, "UTF-8")}/pricing", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.price.v0.models.Pricing", r, _.validate[io.flow.price.v0.models.Pricing])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.GenericErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404, 422")
        }
      }

      override def getMarginsByExperienceKey(
        organization: String,
        experienceKey: String,
        id: _root_.scala.Option[Seq[String]] = None,
        limit: Long = 25,
        offset: Long = 0,
        sort: String = "name",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.ItemMargin]] = {
        val queryParameters = Seq(
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString),
          Some("sort" -> sort)
        ).flatten ++
          id.getOrElse(Nil).map("id" -> _)

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(experienceKey, "UTF-8")}/margins", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.experience.v0.models.ItemMargin]", r, _.validate[Seq[io.flow.experience.v0.models.ItemMargin]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def getMarginsAndVersionsByExperienceKey(
        organization: String,
        experienceKey: String,
        id: _root_.scala.Option[Seq[String]] = None,
        limit: Long = 25,
        offset: Long = 0,
        sort: String = "journal_timestamp",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.ItemMarginVersion]] = {
        val queryParameters = Seq(
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString),
          Some("sort" -> sort)
        ).flatten ++
          id.getOrElse(Nil).map("id" -> _)

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(experienceKey, "UTF-8")}/margins/versions", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.experience.v0.models.ItemMarginVersion]", r, _.validate[Seq[io.flow.experience.v0.models.ItemMarginVersion]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def getMarginsByExperienceKeyAndKey(
        organization: String,
        experienceKey: String,
        key: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.ItemMargin] = {
        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(experienceKey, "UTF-8")}/margins/${play.utils.UriEncoding.encodePathSegment(key, "UTF-8")}", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.ItemMargin", r, _.validate[io.flow.experience.v0.models.ItemMargin])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.GenericErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404, 422")
        }
      }

      override def postMarginsByExperienceKey(
        organization: String,
        experienceKey: String,
        itemMarginPostForm: io.flow.experience.v0.models.ItemMarginPostForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.ItemMargin] = {
        val payload = play.api.libs.json.Json.toJson(itemMarginPostForm)

        _executeRequest("POST", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(experienceKey, "UTF-8")}/margins", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 201 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.ItemMargin", r, _.validate[io.flow.experience.v0.models.ItemMargin])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.GenericErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 201, 401, 404, 422")
        }
      }

      override def putMarginsByExperienceKeyAndKey(
        organization: String,
        experienceKey: String,
        key: String,
        itemMarginPutForm: io.flow.experience.v0.models.ItemMarginPutForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.ItemMargin] = {
        val payload = play.api.libs.json.Json.toJson(itemMarginPutForm)

        _executeRequest("PUT", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(experienceKey, "UTF-8")}/margins/${play.utils.UriEncoding.encodePathSegment(key, "UTF-8")}", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.ItemMargin", r, _.validate[io.flow.experience.v0.models.ItemMargin])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.GenericErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404, 422")
        }
      }

      override def deleteMarginsByExperienceKeyAndKey(
        organization: String,
        experienceKey: String,
        key: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] = {
        _executeRequest("DELETE", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(experienceKey, "UTF-8")}/margins/${play.utils.UriEncoding.encodePathSegment(key, "UTF-8")}", requestHeaders = requestHeaders).map {
          case r if r.status == 204 => ()
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 204, 401, 404")
        }
      }

      override def getPaymentMethodRulesByExperienceKey(
        organization: String,
        experienceKey: String,
        paymentMethodType: _root_.scala.Option[Seq[io.flow.reference.v0.models.PaymentMethodType]] = None,
        tags: _root_.scala.Option[Seq[String]] = None,
        limit: Long = 25,
        offset: Long = 0,
        sort: String = "display_position",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.PaymentMethodRule]] = {
        val queryParameters = Seq(
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString),
          Some("sort" -> sort)
        ).flatten ++
          paymentMethodType.getOrElse(Nil).map("payment_method_type" -> _.toString) ++
          tags.getOrElse(Nil).map("tags" -> _)

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(experienceKey, "UTF-8")}/payment-method-rules", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.experience.v0.models.PaymentMethodRule]", r, _.validate[Seq[io.flow.experience.v0.models.PaymentMethodRule]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def putPaymentMethodRulesByExperienceKey(
        organization: String,
        experienceKey: String,
        experiencePaymentMethodRuleForms: Seq[io.flow.experience.v0.models.ExperiencePaymentMethodRuleForm],
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.PaymentMethodRule]] = {
        val payload = play.api.libs.json.Json.toJson(experiencePaymentMethodRuleForms)

        _executeRequest("PUT", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(experienceKey, "UTF-8")}/payment-method-rules", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.experience.v0.models.PaymentMethodRule]", r, _.validate[Seq[io.flow.experience.v0.models.PaymentMethodRule]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.GenericErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404, 422")
        }
      }

      override def getPaymentMethodTypesByExperienceKey(
        organization: String,
        experienceKey: String,
        limit: Long = 25,
        offset: Long = 0,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.reference.v0.models.PaymentMethodType]] = {
        val queryParameters = Seq(
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString)
        ).flatten

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/experiences/${play.utils.UriEncoding.encodePathSegment(experienceKey, "UTF-8")}/payment-method-types", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.reference.v0.models.PaymentMethodType]", r, _.validate[Seq[io.flow.reference.v0.models.PaymentMethodType]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }
    }

    object OrderEstimates extends OrderEstimates {
      override def getById(
        organization: String,
        id: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Experience] = {
        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/order-estimates/${play.utils.UriEncoding.encodePathSegment(id, "UTF-8")}", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.Experience", r, _.validate[io.flow.experience.v0.models.Experience])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def post(
        organization: String,
        orderEstimateForm: io.flow.experience.v0.models.OrderEstimateForm,
        experience: _root_.scala.Option[String] = None,
        country: _root_.scala.Option[String] = None,
        ip: _root_.scala.Option[String] = None,
        currency: _root_.scala.Option[String] = None,
        language: _root_.scala.Option[String] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.OrderEstimate] = {
        val payload = play.api.libs.json.Json.toJson(orderEstimateForm)

        val queryParameters = Seq(
          experience.map("experience" -> _),
          country.map("country" -> _),
          ip.map("ip" -> _),
          currency.map("currency" -> _),
          language.map("language" -> _)
        ).flatten

        _executeRequest("POST", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/order-estimates", body = Some(payload), queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 201 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.OrderEstimate", r, _.validate[io.flow.experience.v0.models.OrderEstimate])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.OrderErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 201, 401, 404, 422")
        }
      }

      override def putById(
        organization: String,
        id: String,
        orderEstimateForm: io.flow.experience.v0.models.OrderEstimateForm,
        experience: _root_.scala.Option[String] = None,
        country: _root_.scala.Option[String] = None,
        ip: _root_.scala.Option[String] = None,
        currency: _root_.scala.Option[String] = None,
        language: _root_.scala.Option[String] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.OrderEstimate] = {
        val payload = play.api.libs.json.Json.toJson(orderEstimateForm)

        val queryParameters = Seq(
          experience.map("experience" -> _),
          country.map("country" -> _),
          ip.map("ip" -> _),
          currency.map("currency" -> _),
          language.map("language" -> _)
        ).flatten

        _executeRequest("PUT", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/order-estimates/${play.utils.UriEncoding.encodePathSegment(id, "UTF-8")}", body = Some(payload), queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.OrderEstimate", r, _.validate[io.flow.experience.v0.models.OrderEstimate])
          case r if r.status == 201 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.OrderEstimate", r, _.validate[io.flow.experience.v0.models.OrderEstimate])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.OrderErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 201, 401, 404, 422")
        }
      }
    }

    object OrderIdentifiers extends OrderIdentifiers {
      override def getVersions(
        organization: String,
        id: _root_.scala.Option[Seq[String]] = None,
        number: _root_.scala.Option[Seq[String]] = None,
        orderNumber: _root_.scala.Option[Seq[String]] = None,
        limit: Long = 25,
        offset: Long = 0,
        sort: String = "journal_timestamp",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.OrderIdentifierVersion]] = {
        val queryParameters = Seq(
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString),
          Some("sort" -> sort)
        ).flatten ++
          id.getOrElse(Nil).map("id" -> _) ++
          number.getOrElse(Nil).map("number" -> _) ++
          orderNumber.getOrElse(Nil).map("order_number" -> _)

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/order-identifiers/versions", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.experience.v0.models.OrderIdentifierVersion]", r, _.validate[Seq[io.flow.experience.v0.models.OrderIdentifierVersion]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def get(
        organization: String,
        id: _root_.scala.Option[Seq[String]] = None,
        number: _root_.scala.Option[Seq[String]] = None,
        orderNumber: _root_.scala.Option[Seq[String]] = None,
        limit: Long = 25,
        offset: Long = 0,
        sort: String = "-created_at",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.OrderIdentifier]] = {
        val queryParameters = Seq(
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString),
          Some("sort" -> sort)
        ).flatten ++
          id.getOrElse(Nil).map("id" -> _) ++
          number.getOrElse(Nil).map("number" -> _) ++
          orderNumber.getOrElse(Nil).map("order_number" -> _)

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/order-identifiers", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.experience.v0.models.OrderIdentifier]", r, _.validate[Seq[io.flow.experience.v0.models.OrderIdentifier]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def getByNumber(
        organization: String,
        number: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.OrderIdentifier] = {
        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/order-identifiers/${play.utils.UriEncoding.encodePathSegment(number, "UTF-8")}", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.OrderIdentifier", r, _.validate[io.flow.experience.v0.models.OrderIdentifier])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def post(
        organization: String,
        orderIdentifierForm: io.flow.experience.v0.models.OrderIdentifierForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.OrderIdentifier] = {
        val payload = play.api.libs.json.Json.toJson(orderIdentifierForm)

        _executeRequest("POST", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/order-identifiers", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 201 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.OrderIdentifier", r, _.validate[io.flow.experience.v0.models.OrderIdentifier])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.OrderErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 201, 401, 404, 422")
        }
      }

      override def putByNumber(
        organization: String,
        number: String,
        orderIdentifierPutForm: io.flow.experience.v0.models.OrderIdentifierPutForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.OrderIdentifier] = {
        val payload = play.api.libs.json.Json.toJson(orderIdentifierPutForm)

        _executeRequest("PUT", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/order-identifiers/${play.utils.UriEncoding.encodePathSegment(number, "UTF-8")}", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.OrderIdentifier", r, _.validate[io.flow.experience.v0.models.OrderIdentifier])
          case r if r.status == 201 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.OrderIdentifier", r, _.validate[io.flow.experience.v0.models.OrderIdentifier])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.OrderErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 201, 401, 404, 422")
        }
      }

      override def deleteByNumber(
        organization: String,
        number: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] = {
        _executeRequest("DELETE", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/order-identifiers/${play.utils.UriEncoding.encodePathSegment(number, "UTF-8")}", requestHeaders = requestHeaders).map {
          case r if r.status == 204 => ()
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 204, 401, 404")
        }
      }
    }

    object Orders extends Orders {
      override def getVersions(
        organization: String,
        id: _root_.scala.Option[Seq[String]] = None,
        number: _root_.scala.Option[Seq[String]] = None,
        limit: Long = 25,
        offset: Long = 0,
        sort: String = "journal_timestamp",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.OrderVersion]] = {
        val queryParameters = Seq(
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString),
          Some("sort" -> sort)
        ).flatten ++
          id.getOrElse(Nil).map("id" -> _) ++
          number.getOrElse(Nil).map("number" -> _)

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/orders/versions", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.experience.v0.models.OrderVersion]", r, _.validate[Seq[io.flow.experience.v0.models.OrderVersion]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def get(
        organization: String,
        id: _root_.scala.Option[Seq[String]] = None,
        number: _root_.scala.Option[Seq[String]] = None,
        identifier: _root_.scala.Option[String] = None,
        limit: Long = 25,
        offset: Long = 0,
        sort: String = "-created_at",
        expand: _root_.scala.Option[Seq[String]] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.Order]] = {
        val queryParameters = Seq(
          identifier.map("identifier" -> _),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString),
          Some("sort" -> sort)
        ).flatten ++
          id.getOrElse(Nil).map("id" -> _) ++
          number.getOrElse(Nil).map("number" -> _) ++
          expand.getOrElse(Nil).map("expand" -> _)

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/orders", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.experience.v0.models.Order]", r, _.validate[Seq[io.flow.experience.v0.models.Order]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def getIdentifierByIdentifierNumber(
        organization: String,
        identifierNumber: String,
        expand: _root_.scala.Option[Seq[String]] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Order] = {
        val queryParameters = expand.getOrElse(Nil).map("expand" -> _)

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/orders/identifier/${play.utils.UriEncoding.encodePathSegment(identifierNumber, "UTF-8")}", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.Order", r, _.validate[io.flow.experience.v0.models.Order])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def getByNumber(
        organization: String,
        number: String,
        expand: _root_.scala.Option[Seq[String]] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Order] = {
        val queryParameters = expand.getOrElse(Nil).map("expand" -> _)

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/orders/${play.utils.UriEncoding.encodePathSegment(number, "UTF-8")}", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.Order", r, _.validate[io.flow.experience.v0.models.Order])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def post(
        organization: String,
        orderForm: io.flow.experience.v0.models.OrderForm,
        experience: _root_.scala.Option[String] = None,
        country: _root_.scala.Option[String] = None,
        ip: _root_.scala.Option[String] = None,
        currency: _root_.scala.Option[String] = None,
        language: _root_.scala.Option[String] = None,
        expand: _root_.scala.Option[Seq[String]] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Order] = {
        val payload = play.api.libs.json.Json.toJson(orderForm)

        val queryParameters = Seq(
          experience.map("experience" -> _),
          country.map("country" -> _),
          ip.map("ip" -> _),
          currency.map("currency" -> _),
          language.map("language" -> _)
        ).flatten ++
          expand.getOrElse(Nil).map("expand" -> _)

        _executeRequest("POST", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/orders", body = Some(payload), queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 201 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.Order", r, _.validate[io.flow.experience.v0.models.Order])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.OrderErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 201, 401, 404, 422")
        }
      }

      override def putByNumber(
        organization: String,
        number: String,
        orderPutForm: io.flow.experience.v0.models.OrderPutForm,
        experience: _root_.scala.Option[String] = None,
        country: _root_.scala.Option[String] = None,
        ip: _root_.scala.Option[String] = None,
        currency: _root_.scala.Option[String] = None,
        language: _root_.scala.Option[String] = None,
        expand: _root_.scala.Option[Seq[String]] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Order] = {
        val payload = play.api.libs.json.Json.toJson(orderPutForm)

        val queryParameters = Seq(
          experience.map("experience" -> _),
          country.map("country" -> _),
          ip.map("ip" -> _),
          currency.map("currency" -> _),
          language.map("language" -> _)
        ).flatten ++
          expand.getOrElse(Nil).map("expand" -> _)

        _executeRequest("PUT", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/orders/${play.utils.UriEncoding.encodePathSegment(number, "UTF-8")}", body = Some(payload), queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.Order", r, _.validate[io.flow.experience.v0.models.Order])
          case r if r.status == 201 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.Order", r, _.validate[io.flow.experience.v0.models.Order])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.OrderErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 201, 401, 404, 422")
        }
      }

      override def deleteByNumber(
        organization: String,
        number: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] = {
        _executeRequest("DELETE", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/orders/${play.utils.UriEncoding.encodePathSegment(number, "UTF-8")}", requestHeaders = requestHeaders).map {
          case r if r.status == 204 => ()
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.GenericErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 204, 401, 404, 422")
        }
      }

      override def putSubmissionsByNumber(
        organization: String,
        number: String,
        expand: _root_.scala.Option[Seq[String]] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Order] = {
        val payload = play.api.libs.json.Json.obj(
          "expand" -> play.api.libs.json.Json.toJson(expand)
        )

        _executeRequest("PUT", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/orders/${play.utils.UriEncoding.encodePathSegment(number, "UTF-8")}/submissions", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.Order", r, _.validate[io.flow.experience.v0.models.Order])
          case r if r.status == 201 => _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.Order", r, _.validate[io.flow.experience.v0.models.Order])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.experience.v0.errors.GenericErrorResponse(r)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 201, 401, 404, 422")
        }
      }
    }

    object Organizations extends Organizations {
      override def getCountries(
        organization: String,
        ip: _root_.scala.Option[String] = None,
        country: _root_.scala.Option[String] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.reference.v0.models.Country]] = {
        val queryParameters = Seq(
          ip.map("ip" -> _),
          country.map("country" -> _)
        ).flatten

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/countries", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.reference.v0.models.Country]", r, _.validate[Seq[io.flow.reference.v0.models.Country]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def getCountriesAndDestinations(
        organization: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.reference.v0.models.Country]] = {
        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/countries/destinations", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.reference.v0.models.Country]", r, _.validate[Seq[io.flow.reference.v0.models.Country]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }
    }

    object PaymentMethodRules extends PaymentMethodRules {
      override def get(
        organization: String,
        country: _root_.scala.Option[String] = None,
        currency: _root_.scala.Option[String] = None,
        limit: Long = 25,
        offset: Long = 0,
        sort: String = "display_position",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.PaymentMethodRule]] = {
        val queryParameters = Seq(
          country.map("country" -> _),
          currency.map("currency" -> _),
          Some("limit" -> limit.toString),
          Some("offset" -> offset.toString),
          Some("sort" -> sort)
        ).flatten

        _executeRequest("GET", s"/${play.utils.UriEncoding.encodePathSegment(organization, "UTF-8")}/payment-method-rules", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.experience.v0.Client.parseJson("Seq[io.flow.experience.v0.models.PaymentMethodRule]", r, _.validate[Seq[io.flow.experience.v0.models.PaymentMethodRule]])
          case r if r.status == 401 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.experience.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }
    }

    def _requestHolder(path: String): play.api.libs.ws.WSRequest = {

      val holder = ws.url(baseUrl + path).withHeaders(
        "User-Agent" -> Constants.UserAgent,
        "X-Apidoc-Version" -> Constants.Version,
        "X-Apidoc-Version-Major" -> Constants.VersionMajor.toString
      ).withHeaders(defaultHeaders : _*)
      auth.fold(holder) {
        case Authorization.Basic(username, password) => {
          holder.withAuth(username, password.getOrElse(""), play.api.libs.ws.WSAuthScheme.BASIC)
        }
        case a => sys.error("Invalid authorization scheme[" + a.getClass + "]")
      }
    }

    def _logRequest(method: String, req: play.api.libs.ws.WSRequest)(implicit ec: scala.concurrent.ExecutionContext): play.api.libs.ws.WSRequest = {
      val queryComponents = for {
        (name, values) <- req.queryString
        value <- values
      } yield s"$name=$value"
      val url = s"${req.url}${queryComponents.mkString("?", "&", "")}"
      auth.fold(logger.info(s"curl -X $method $url")) { _ =>
        logger.info(s"curl -X $method -u '[REDACTED]:' $url")
      }
      req
    }

    def _executeRequest(
      method: String,
      path: String,
      queryParameters: Seq[(String, String)] = Nil,
      requestHeaders: Seq[(String, String)] = Nil,
      body: Option[play.api.libs.json.JsValue] = None
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[play.api.libs.ws.WSResponse] = {
      method.toUpperCase match {
        case "GET" => {
          _logRequest("GET", _requestHolder(path).withHeaders(requestHeaders:_*).withQueryString(queryParameters:_*)).get()
        }
        case "POST" => {
          _logRequest("POST", _requestHolder(path).withHeaders(_withJsonContentType(requestHeaders):_*).withQueryString(queryParameters:_*)).post(body.getOrElse(play.api.libs.json.Json.obj()))
        }
        case "PUT" => {
          _logRequest("PUT", _requestHolder(path).withHeaders(_withJsonContentType(requestHeaders):_*).withQueryString(queryParameters:_*)).put(body.getOrElse(play.api.libs.json.Json.obj()))
        }
        case "PATCH" => {
          _logRequest("PATCH", _requestHolder(path).withHeaders(requestHeaders:_*).withQueryString(queryParameters:_*)).patch(body.getOrElse(play.api.libs.json.Json.obj()))
        }
        case "DELETE" => {
          _logRequest("DELETE", _requestHolder(path).withHeaders(requestHeaders:_*).withQueryString(queryParameters:_*)).delete()
        }
         case "HEAD" => {
          _logRequest("HEAD", _requestHolder(path).withHeaders(requestHeaders:_*).withQueryString(queryParameters:_*)).head()
        }
         case "OPTIONS" => {
          _logRequest("OPTIONS", _requestHolder(path).withHeaders(requestHeaders:_*).withQueryString(queryParameters:_*)).options()
        }
        case _ => {
          _logRequest(method, _requestHolder(path).withHeaders(requestHeaders:_*).withQueryString(queryParameters:_*))
          sys.error("Unsupported method[%s]".format(method))
        }
      }
    }

    /**
     * Adds a Content-Type: application/json header unless the specified requestHeaders
     * already contain a Content-Type header
     */
    def _withJsonContentType(headers: Seq[(String, String)]): Seq[(String, String)] = {
      headers.find { _._1.toUpperCase == "CONTENT-TYPE" } match {
        case None => headers ++ Seq(("Content-Type" -> "application/json; charset=UTF-8"))
        case Some(_) => headers
      }
    }

  }

  object Client {

    def parseJson[T](
      className: String,
      r: play.api.libs.ws.WSResponse,
      f: (play.api.libs.json.JsValue => play.api.libs.json.JsResult[T])
    ): T = {
      f(play.api.libs.json.Json.parse(r.body)) match {
        case play.api.libs.json.JsSuccess(x, _) => x
        case play.api.libs.json.JsError(errors) => {
          throw io.flow.experience.v0.errors.FailedRequest(r.status, s"Invalid json for class[" + className + "]: " + errors.mkString(" "))
        }
      }
    }

  }

  sealed trait Authorization extends _root_.scala.Product with _root_.scala.Serializable
  object Authorization {
    case class Basic(username: String, password: Option[String] = None) extends Authorization
  }

  package interfaces {

    trait Client {
      def baseUrl: String
      def allocations: io.flow.experience.v0.Allocations
      def creditPayments: io.flow.experience.v0.CreditPayments
      def experienceDefaults: io.flow.experience.v0.ExperienceDefaults
      def experiences: io.flow.experience.v0.Experiences
      def orderEstimates: io.flow.experience.v0.OrderEstimates
      def orderIdentifiers: io.flow.experience.v0.OrderIdentifiers
      def orders: io.flow.experience.v0.Orders
      def organizations: io.flow.experience.v0.Organizations
      def paymentMethodRules: io.flow.experience.v0.PaymentMethodRules
    }

  }

  trait Allocations {
    /**
     * Order-level price details allocated using a strategy among individual order item
     * units.
     */
    def get(
      organization: String,
      number: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Allocation]
  }

  trait CreditPayments {
    def getVersions(
      organization: String,
      id: _root_.scala.Option[Seq[String]] = None,
      key: _root_.scala.Option[Seq[String]] = None,
      limit: Long = 25,
      offset: Long = 0,
      sort: String = "journal_timestamp",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.CreditPaymentVersion]]

    def get(
      organization: String,
      id: _root_.scala.Option[Seq[String]] = None,
      key: _root_.scala.Option[Seq[String]] = None,
      orderNumber: _root_.scala.Option[String] = None,
      limit: Long = 25,
      offset: Long = 0,
      sort: String = "-created_at",
      expand: _root_.scala.Option[Seq[String]] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.CreditPayment]]

    def getByKey(
      organization: String,
      key: String,
      expand: _root_.scala.Option[Seq[String]] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.CreditPayment]

    def post(
      organization: String,
      creditPaymentForm: io.flow.experience.v0.models.CreditPaymentForm,
      expand: _root_.scala.Option[Seq[String]] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.CreditPayment]

    def putByKey(
      organization: String,
      key: String,
      creditPaymentPutForm: io.flow.experience.v0.models.CreditPaymentPutForm,
      expand: _root_.scala.Option[Seq[String]] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.CreditPayment]

    def deleteByKey(
      organization: String,
      key: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]
  }

  trait ExperienceDefaults {
    /**
     * Returns recommended default settings when creating a new experience
     */
    def get(
      organization: String,
      regionId: _root_.scala.Option[String] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.ExperienceDefaults]
  }

  trait Experiences {
    /**
     * Get available promotions for the experience
     */
    def getPromotionsAndAvailableByKey(
      organization: String,
      key: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.Promotion]]

    /**
     * Provides visibility into recent changes of each object, including deletion
     */
    def getVersions(
      organization: String,
      id: _root_.scala.Option[Seq[String]] = None,
      key: _root_.scala.Option[Seq[String]] = None,
      limit: Long = 25,
      offset: Long = 0,
      sort: String = "journal_timestamp",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.ExperienceVersion]]

    /**
     * Search experiences. Always paginated.
     * 
     * @param ip If specified, we will geolocate the user by this IP address, and if successful,
     *        select the experience matching the country of the IP address.
     */
    def get(
      organization: String,
      id: _root_.scala.Option[Seq[String]] = None,
      key: _root_.scala.Option[Seq[String]] = None,
      name: _root_.scala.Option[String] = None,
      region: _root_.scala.Option[String] = None,
      currency: _root_.scala.Option[String] = None,
      subcatalog: _root_.scala.Option[String] = None,
      ip: _root_.scala.Option[String] = None,
      limit: Long = 25,
      offset: Long = 0,
      sort: String = "name",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.Experience]]

    /**
     * Returns localized information about 1 or more items. The items will be localized
     * based on the experience selected by the query parameters in the order of
     * experience, then country, then ip address.
     * 
     * @param status Filter to items based on their status within this subcatalog
     * @param experience If specified, we will render the items in the context of the experience with
     *        this key.
     * @param country If specified, we will select the experience matching this country. ISO 3166 3
     *        currency code as defined in https://api.flow.io/reference/countries
     * @param ip If specified, we will geolocate the user by this IP address, and if successful,
     *        select the experience matching the country of the IP address.
     * @param currency Iso 4217 3 currency code as defined in https://api.flow.io/reference/currencies
     *        If specified, translate the pricing to this currency. Translation occurs using
     *        the current spot rate for this currency from the base currency in the
     *        experience.
     * @param language ISO 639 2 language code as defined in https://api.flow.io/reference/languages If
     *        specified, translate content to this language (where available)
     */
    def getItems(
      organization: String,
      number: _root_.scala.Option[Seq[String]] = None,
      status: _root_.scala.Option[Seq[io.flow.catalog.v0.models.SubcatalogItemStatus]] = None,
      experience: _root_.scala.Option[String] = None,
      country: _root_.scala.Option[String] = None,
      ip: _root_.scala.Option[String] = None,
      currency: _root_.scala.Option[String] = None,
      language: _root_.scala.Option[String] = None,
      limit: Long = 25,
      offset: Long = 0,
      sort: String = "-created_at",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.catalog.v0.models.Item]]

    /**
     * Returns information about this item localized based on the query parameters
     * 
     * @param experience If specified, we will render the items in the context of the experience with
     *        this key.
     * @param language ISO 639 2 language code as defined in https://api.flow.io/reference/languages
     */
    def getItemsByNumber(
      organization: String,
      number: String,
      experience: _root_.scala.Option[String] = None,
      country: _root_.scala.Option[String] = None,
      ip: _root_.scala.Option[String] = None,
      currency: _root_.scala.Option[String] = None,
      language: _root_.scala.Option[String] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.catalog.v0.models.Item]

    /**
     * Formats the requested amount using the formatting settings for the experience.
     * 
     * @param base The currency of the provided amount, which will be converted to the experience
     *        currency, unless a value is specified for the `currency` parameter.
     * @param amount The amount in the base currency to be converted.
     * @param experience If specified, we will render the items in the context of the experience with
     *        this key.
     * @param currency If specified, the provided base amount will be converted to and formatted in
     *        this currency.
     */
    def getConversionsByBaseAndAmount(
      organization: String,
      base: String,
      amount: String,
      experience: _root_.scala.Option[String] = None,
      country: _root_.scala.Option[String] = None,
      ip: _root_.scala.Option[String] = None,
      currency: _root_.scala.Option[String] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.common.v0.models.PriceWithBase]

    /**
     * Returns information about a specific experience.
     */
    def getByKey(
      organization: String,
      key: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Experience]

    /**
     * Returns detailed information on the pricing of this item within this experience
     */
    def getItemsAndPriceByKeyAndNumber(
      organization: String,
      key: String,
      number: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.price.v0.models.PriceCheck]

    /**
     * Add experience
     */
    def post(
      organization: String,
      experienceForm: io.flow.experience.v0.models.ExperienceForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Experience]

    /**
     * Update experience with the specified key, creating if it does not exist.
     */
    def putByKey(
      organization: String,
      key: String,
      experienceForm: io.flow.experience.v0.models.ExperienceForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Experience]

    /**
     * Delete the experience with this key
     */
    def deleteByKey(
      organization: String,
      key: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]

    /**
     * Get the pricing settings for this experience
     */
    def getPricingByKey(
      organization: String,
      key: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.price.v0.models.Pricing]

    /**
     * Update the pricing settings for this experience
     */
    def putPricingByKey(
      organization: String,
      key: String,
      pricing: io.flow.price.v0.models.Pricing,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.price.v0.models.Pricing]

    def getMarginsByExperienceKey(
      organization: String,
      experienceKey: String,
      id: _root_.scala.Option[Seq[String]] = None,
      limit: Long = 25,
      offset: Long = 0,
      sort: String = "name",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.ItemMargin]]

    def getMarginsAndVersionsByExperienceKey(
      organization: String,
      experienceKey: String,
      id: _root_.scala.Option[Seq[String]] = None,
      limit: Long = 25,
      offset: Long = 0,
      sort: String = "journal_timestamp",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.ItemMarginVersion]]

    def getMarginsByExperienceKeyAndKey(
      organization: String,
      experienceKey: String,
      key: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.ItemMargin]

    def postMarginsByExperienceKey(
      organization: String,
      experienceKey: String,
      itemMarginPostForm: io.flow.experience.v0.models.ItemMarginPostForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.ItemMargin]

    def putMarginsByExperienceKeyAndKey(
      organization: String,
      experienceKey: String,
      key: String,
      itemMarginPutForm: io.flow.experience.v0.models.ItemMarginPutForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.ItemMargin]

    def deleteMarginsByExperienceKeyAndKey(
      organization: String,
      experienceKey: String,
      key: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]

    def getPaymentMethodRulesByExperienceKey(
      organization: String,
      experienceKey: String,
      paymentMethodType: _root_.scala.Option[Seq[io.flow.reference.v0.models.PaymentMethodType]] = None,
      tags: _root_.scala.Option[Seq[String]] = None,
      limit: Long = 25,
      offset: Long = 0,
      sort: String = "display_position",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.PaymentMethodRule]]

    /**
     * Change the ordering or payment tags for an experience. Every post must include
     * one entry for each payment method offered by Flow.
     */
    def putPaymentMethodRulesByExperienceKey(
      organization: String,
      experienceKey: String,
      experiencePaymentMethodRuleForms: Seq[io.flow.experience.v0.models.ExperiencePaymentMethodRuleForm],
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.PaymentMethodRule]]

    def getPaymentMethodTypesByExperienceKey(
      organization: String,
      experienceKey: String,
      limit: Long = 25,
      offset: Long = 0,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.reference.v0.models.PaymentMethodType]]
  }

  trait OrderEstimates {
    def getById(
      organization: String,
      id: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Experience]

    /**
     * Create an order estimate, using the localized information from the experience
     * selected by the query parameters. This is similar to the POST orders endpoint,
     * except this just returns an estimate and cannot be submitted.
     * 
     * @param experience If specified, we will render the items in the context of the experience with
     *        this key.
     * @param country If specified, we will select the experience matching this country. ISO 3166 3
     *        currency code as defined in https://api.flow.io/reference/countries
     * @param ip If specified, we will geolocate the user by this IP address, and if successful,
     *        select the experience matching the country of the IP address.
     * @param currency Iso 4217 3 currency code as defined in https://api.flow.io/reference/currencies
     *        If specified, translate the pricing to this currency. Translation occurs using
     *        the current spot rate for this currency from the base currency in the
     *        experience.
     * @param language ISO 639 2 language code as defined in https://api.flow.io/reference/languages If
     *        specified, translate content to this language (where available)
     */
    def post(
      organization: String,
      orderEstimateForm: io.flow.experience.v0.models.OrderEstimateForm,
      experience: _root_.scala.Option[String] = None,
      country: _root_.scala.Option[String] = None,
      ip: _root_.scala.Option[String] = None,
      currency: _root_.scala.Option[String] = None,
      language: _root_.scala.Option[String] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.OrderEstimate]

    /**
     * @param experience If specified, we will render the items in the context of the experience with
     *        this key.
     * @param country If specified, we will select the experience matching this country. ISO 3166 3
     *        currency code as defined in https://api.flow.io/reference/countries
     * @param ip If specified, we will geolocate the user by this IP address, and if successful,
     *        select the experience matching the country of the IP address.
     * @param currency Iso 4217 3 currency code as defined in https://api.flow.io/reference/currencies
     *        If specified, translate the pricing to this currency. Translation occurs using
     *        the current spot rate for this currency from the base currency in the
     *        experience.
     * @param language ISO 639 2 language code as defined in https://api.flow.io/reference/languages If
     *        specified, translate content to this language (where available)
     */
    def putById(
      organization: String,
      id: String,
      orderEstimateForm: io.flow.experience.v0.models.OrderEstimateForm,
      experience: _root_.scala.Option[String] = None,
      country: _root_.scala.Option[String] = None,
      ip: _root_.scala.Option[String] = None,
      currency: _root_.scala.Option[String] = None,
      language: _root_.scala.Option[String] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.OrderEstimate]
  }

  trait OrderIdentifiers {
    def getVersions(
      organization: String,
      id: _root_.scala.Option[Seq[String]] = None,
      number: _root_.scala.Option[Seq[String]] = None,
      orderNumber: _root_.scala.Option[Seq[String]] = None,
      limit: Long = 25,
      offset: Long = 0,
      sort: String = "journal_timestamp",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.OrderIdentifierVersion]]

    def get(
      organization: String,
      id: _root_.scala.Option[Seq[String]] = None,
      number: _root_.scala.Option[Seq[String]] = None,
      orderNumber: _root_.scala.Option[Seq[String]] = None,
      limit: Long = 25,
      offset: Long = 0,
      sort: String = "-created_at",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.OrderIdentifier]]

    def getByNumber(
      organization: String,
      number: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.OrderIdentifier]

    def post(
      organization: String,
      orderIdentifierForm: io.flow.experience.v0.models.OrderIdentifierForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.OrderIdentifier]

    def putByNumber(
      organization: String,
      number: String,
      orderIdentifierPutForm: io.flow.experience.v0.models.OrderIdentifierPutForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.OrderIdentifier]

    def deleteByNumber(
      organization: String,
      number: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]
  }

  trait Orders {
    /**
     * Provides visibility into recent changes of each order, including deletion
     */
    def getVersions(
      organization: String,
      id: _root_.scala.Option[Seq[String]] = None,
      number: _root_.scala.Option[Seq[String]] = None,
      limit: Long = 25,
      offset: Long = 0,
      sort: String = "journal_timestamp",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.OrderVersion]]

    /**
     * Search orders. Always paginated.
     */
    def get(
      organization: String,
      id: _root_.scala.Option[Seq[String]] = None,
      number: _root_.scala.Option[Seq[String]] = None,
      identifier: _root_.scala.Option[String] = None,
      limit: Long = 25,
      offset: Long = 0,
      sort: String = "-created_at",
      expand: _root_.scala.Option[Seq[String]] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.Order]]

    /**
     * Returns information about a specific order using an identifier number
     */
    def getIdentifierByIdentifierNumber(
      organization: String,
      identifierNumber: String,
      expand: _root_.scala.Option[Seq[String]] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Order]

    /**
     * Returns information about a specific order.
     */
    def getByNumber(
      organization: String,
      number: String,
      expand: _root_.scala.Option[Seq[String]] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Order]

    /**
     * Create an order, using the localized information from the experience selected by
     * the query parameters. Note the order must be submitted before its expiration
     * 
     * @param experience If specified, we will render the items in the context of the experience with
     *        this key.
     * @param country If specified, we will select the experience matching this country. ISO 3166 3
     *        currency code as defined in https://api.flow.io/reference/countries
     * @param ip If specified, we will geolocate the user by this IP address, and if successful,
     *        select the experience matching the country of the IP address.
     * @param currency Iso 4217 3 currency code as defined in https://api.flow.io/reference/currencies
     *        If specified, translate the pricing to this currency. Translation occurs using
     *        the current spot rate for this currency from the base currency in the
     *        experience.
     * @param language ISO 639 2 language code as defined in https://api.flow.io/reference/languages If
     *        specified, translate content to this language (where available)
     */
    def post(
      organization: String,
      orderForm: io.flow.experience.v0.models.OrderForm,
      experience: _root_.scala.Option[String] = None,
      country: _root_.scala.Option[String] = None,
      ip: _root_.scala.Option[String] = None,
      currency: _root_.scala.Option[String] = None,
      language: _root_.scala.Option[String] = None,
      expand: _root_.scala.Option[Seq[String]] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Order]

    /**
     * Upserts an order. using the localized information from the experience selected
     * by the query parameters. Note the order must be submitted before its expiration
     * 
     * @param experience If specified, we will render the items in the context of the experience with
     *        this key.
     * @param country If specified, we will select the experience matching this country. ISO 3166 3
     *        currency code as defined in https://api.flow.io/reference/countries
     * @param ip If specified, we will geolocate the user by this IP address, and if successful,
     *        select the experience matching the country of the IP address.
     * @param currency Iso 4217 3 currency code as defined in https://api.flow.io/reference/currencies
     *        If specified, translate the pricing to this currency. Translation occurs using
     *        the current spot rate for this currency from the base currency in the
     *        experience.
     * @param language ISO 639 2 language code as defined in https://api.flow.io/reference/languages If
     *        specified, translate content to this language (where available)
     */
    def putByNumber(
      organization: String,
      number: String,
      orderPutForm: io.flow.experience.v0.models.OrderPutForm,
      experience: _root_.scala.Option[String] = None,
      country: _root_.scala.Option[String] = None,
      ip: _root_.scala.Option[String] = None,
      currency: _root_.scala.Option[String] = None,
      language: _root_.scala.Option[String] = None,
      expand: _root_.scala.Option[Seq[String]] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Order]

    /**
     * Delete an order. Note that production orders that have already been submitted
     * cannot be deleted (you will see a 422 response in these cases).
     */
    def deleteByNumber(
      organization: String,
      number: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]

    /**
     * Submits an order. You will get a validation error if the order has already
     * expired (and a new quote could not be automatically recreated for a lower or
     * same price). This method is idempotent - submitting an order a second time has
     * no effect.
     */
    def putSubmissionsByNumber(
      organization: String,
      number: String,
      expand: _root_.scala.Option[Seq[String]] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.experience.v0.models.Order]
  }

  trait Organizations {
    /**
     * The countries resources provides a unique list of all of the countries for which
     * an experience exists. We generate this list of countries by iterating through
     * all of the experience regions, and collecting all of the countries.
     * 
     * @param ip If specified, we lookup the country associated with this IP address, and if
     *        found and there is an experience that is targeted to this country, we guarantee
     *        that this country is in the returned list of countries
     * @param country If specified, we will guarantee that this country is included in the response.
     *        We recommend including the current country when querying for the list of
     *        countries to disable, thereby ensuring the current user's selection will display
     *        (even if they are localized using the world experience). Value is a ISO 3166 3
     *        currency code as defined in https://api.flow.io/reference/countries
     */
    def getCountries(
      organization: String,
      ip: _root_.scala.Option[String] = None,
      country: _root_.scala.Option[String] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.reference.v0.models.Country]]

    /**
     * List of all destination countries available for this organization, including
     * countries within a world experience.
     */
    def getCountriesAndDestinations(
      organization: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.reference.v0.models.Country]]
  }

  trait PaymentMethodRules {
    /**
     * @param country Filters available payment methods to those available for the experience
     *        associated with the provided country.
     * @param currency Filters available payment methods to those that support the provided currency.
     */
    def get(
      organization: String,
      country: _root_.scala.Option[String] = None,
      currency: _root_.scala.Option[String] = None,
      limit: Long = 25,
      offset: Long = 0,
      sort: String = "display_position",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.experience.v0.models.PaymentMethodRule]]
  }

  package errors {

    import io.flow.catalog.v0.models.json._
    import io.flow.common.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.experience.v0.models.json._
    import io.flow.fulfillment.v0.models.json._
    import io.flow.price.v0.models.json._
    import io.flow.reference.v0.models.json._

    case class CreditPaymentErrorResponse(
      response: play.api.libs.ws.WSResponse,
      message: Option[String] = None
    ) extends Exception(message.getOrElse(response.status + ": " + response.body)){
      lazy val creditPaymentError = _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.CreditPaymentError", response, _.validate[io.flow.experience.v0.models.CreditPaymentError])
    }

    case class GenericErrorResponse(
      response: play.api.libs.ws.WSResponse,
      message: Option[String] = None
    ) extends Exception(message.getOrElse(response.status + ": " + response.body)){
      lazy val genericError = _root_.io.flow.experience.v0.Client.parseJson("io.flow.error.v0.models.GenericError", response, _.validate[io.flow.error.v0.models.GenericError])
    }

    case class OrderErrorResponse(
      response: play.api.libs.ws.WSResponse,
      message: Option[String] = None
    ) extends Exception(message.getOrElse(response.status + ": " + response.body)){
      lazy val orderError = _root_.io.flow.experience.v0.Client.parseJson("io.flow.experience.v0.models.OrderError", response, _.validate[io.flow.experience.v0.models.OrderError])
    }

    case class UnitResponse(status: Int) extends Exception(s"HTTP $status")

    case class FailedRequest(responseCode: Int, message: String, requestUri: Option[_root_.java.net.URI] = None) extends _root_.java.lang.Exception(s"HTTP $responseCode: $message")

  }

}