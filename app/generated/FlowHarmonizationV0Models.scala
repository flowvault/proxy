/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.7.56
 * apibuilder 0.14.75 app.apibuilder.io/flow/harmonization/0.7.56/play_2_x_json
 */
package io.flow.harmonization.v0.models {

  /**
   * Describes types of forms that can be used to assign an HS code based on product
   * data.
   */
  sealed trait HintForm extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type HintForm
   */
  sealed trait HintFormDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object HintFormDiscriminator {

    /**
     * A short phrase describing a product in generic terms, intended to uniquely
     * identify a code from a harmonization system. Hints of this type must provide an
     * exact match and will never return more than one result.
     */
    case object PhraseHintForm extends HintFormDiscriminator { override def toString = "phrase_hint_form" }

    final case class UNDEFINED(override val toString: String) extends HintFormDiscriminator

    val all: scala.List[HintFormDiscriminator] = scala.List(PhraseHintForm)

    private[this] val byName: Map[String, HintFormDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): HintFormDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[HintFormDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Organization level settings.
   * 
   * @param dutyStrategy Documents what will happen if we are unable to get an actual duty rate for this
   *        item, i.e. there will be estimation of some sort
   * @param taxStrategy Documents what will happen if we are unable to get an actual duty rate for this
   *        item, i.e. there will be estimation of some sort
   */
  final case class HarmonizationSettings(
    dutyStrategy: io.flow.price.v0.models.LevyStrategy = io.flow.price.v0.models.LevyStrategy.Maximum,
    taxStrategy: io.flow.price.v0.models.LevyStrategy = io.flow.price.v0.models.LevyStrategy.Maximum
  )

  final case class HarmonizationSettingsForm(
    dutyStrategy: _root_.scala.Option[io.flow.price.v0.models.LevyStrategy] = None,
    taxStrategy: _root_.scala.Option[io.flow.price.v0.models.LevyStrategy] = None
  )

  /**
   * Categories optimized for harmonization
   */
  final case class HarmonizedCategory(
    id: String,
    name: String,
    parent: _root_.scala.Option[io.flow.harmonization.v0.models.HarmonizedCategoryReference] = None
  )

  final case class HarmonizedCategoryReference(
    id: String
  )

  /**
   * A harmonized item stores explicit information about this item for the purposes
   * of harmonization / classification. The harmonization process begins by creating
   * a harmonized item; this kicks off the internal processes. Once assigned, codes
   * will be available via the hs6 and hs10 resources
   * 
   * @param description Generic description used to harmonize/classify the item and assign hs6 and hs10
   *        codes.
   */
  final case class HarmonizedItem(
    id: String,
    number: String,
    name: String,
    categories: Seq[String] = Nil,
    attributes: Map[String, String] = Map.empty,
    description: _root_.scala.Option[String] = None
  )

  /**
   * Used to specifically set an item's duty rate for a given trade lane.
   * 
   * @param origin The ISO 3166 3 character code for the country of origin. Case insensitive. See
   *        https://api.flow.io/reference/countries
   * @param destination The ISO 3166 3 character code for the destination country. Case insensitive. See
   *        https://api.flow.io/reference/countries
   * @param rate The actual duty rate as a percentage. A value of 15, for example, indicates a
   *        duty rate of 15%
   */
  final case class HarmonizedItemDuty(
    id: String,
    item: io.flow.harmonization.v0.models.HarmonizedItemReference,
    origin: String,
    destination: String,
    rate: BigDecimal
  )

  /**
   * @param origin The ISO 3166 3 character code for the country of origin. Case insensitive. See
   *        https://api.flow.io/reference/countries
   * @param destination The ISO 3166 3 character code for the destination country. Case insensitive. See
   *        https://api.flow.io/reference/countries
   * @param rate The actual duty rate as a percentage. A value of 15, for example, indicates a
   *        duty rate of 15%
   */
  final case class HarmonizedItemDutyForm(
    number: String,
    origin: String,
    destination: String,
    rate: BigDecimal
  )

  final case class HarmonizedItemDutyVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    harmonizedItemDuty: io.flow.harmonization.v0.models.HarmonizedItemDuty
  )

  final case class HarmonizedItemForm(
    name: String,
    number: String,
    categories: _root_.scala.Option[Seq[String]] = None,
    description: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  final case class HarmonizedItemPutForm(
    name: String,
    categories: _root_.scala.Option[Seq[String]] = None,
    description: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  final case class HarmonizedItemReference(
    id: String,
    number: String,
    description: _root_.scala.Option[String] = None
  )

  final case class HarmonizedItemVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    harmonizedItem: io.flow.harmonization.v0.models.HarmonizedItem
  )

  /**
   * Summary of landed cost data (taxes and duties) for 1 or more items going to a
   * single destination country. Records are unique based on (item.number, country of
   * origin).
   * 
   * @param address The destination address
   */
  final case class HarmonizedLandedCost(
    address: io.flow.common.v0.models.Address,
    items: Seq[io.flow.harmonization.v0.models.HarmonizedLandedCostItem],
    taxRegistration: _root_.scala.Option[io.flow.harmonization.v0.models.TaxRegistration] = None
  )

  /**
   * Allows calculation of duty and tax for multiple items in one API call for items
   * going to a specific destination country
   * 
   * @param address The destination address. At a minimum, country code is required, but more
   *        precise information will lead to more precise rates.
   * @param sourceAddress The center address from where the items were shipped
   * @param orderNumber The order number
   * @param taxRegistrationId The ID of a tax registration to use to evaluate the tax rates as the
   *        registration may affect applicable rates. e.g. EU VAT registration number.
   * @param billingAddress The billing address. Used in some cases to determine tax jurisdiction.
   */
  final case class HarmonizedLandedCostForm(
    address: io.flow.common.v0.models.Address,
    itemNumbers: Seq[String],
    sourceAddress: _root_.scala.Option[io.flow.common.v0.models.Address] = None,
    orderNumber: _root_.scala.Option[String] = None,
    lineItems: _root_.scala.Option[Seq[io.flow.common.v0.models.LineItem]] = None,
    taxRegistrationId: _root_.scala.Option[String] = None,
    billingAddress: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None
  )

  /**
   * Duty and tax information for a given item. Note that the internal implementation
   * supports multiple countries of origin.
   */
  final case class HarmonizedLandedCostItem(
    item: io.flow.harmonization.v0.models.HarmonizedItemReference,
    duty: io.flow.price.v0.models.Duty,
    tax: io.flow.price.v0.models.Tax,
    taxApplicability: _root_.scala.Option[io.flow.harmonization.v0.models.TaxApplicability] = None
  )

  /**
   * Result of looking up a code using a hint.
   * 
   * @param tariffCode The actual HS-10 code for a destination country.
   * @param likelihood The likelihood of this code being the correct one for the provided hint. Higher
   *        numbers are more likely to be correct. Some types of hint will only return
   *        results with a likelihood of 100.
   */
  final case class HintResult(
    tariffCode: io.flow.harmonization.v0.models.TariffCode,
    likelihood: BigDecimal
  )

  /**
   * The (Harmonized System) HS-10 code assigned to an item with a given
   * origin/destination pair.
   * 
   * @param item The item to which this code is assigned
   * @param origin The ISO 3166 3 character code for the country of origin
   * @param destination The ISO 3166 3 character code for the destination country
   * @param code The assigned HS-10 code
   */
  final case class Hs10(
    id: String,
    item: io.flow.harmonization.v0.models.HarmonizedItemReference,
    origin: String,
    destination: String,
    code: String
  )

  final case class Hs10Version(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    hs10: io.flow.harmonization.v0.models.Hs10
  )

  /**
   * The (Harmonized System) HS-6 code assigned to an item.
   * 
   * @param item The item to which this code is assigned
   * @param code The assigned HS-6 code
   */
  final case class Hs6(
    id: String,
    item: io.flow.harmonization.v0.models.HarmonizedItemReference,
    code: String
  )

  final case class Hs6Version(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    hs6: io.flow.harmonization.v0.models.Hs6
  )

  /**
   * Harmonized System codes, up to 6 digits (HS-6). These codes should be the same
   * for all countries.
   * 
   * @param code The actual HS code
   * @param parent The parent harmonization code, if there is one.
   * @param description Description of this code
   */
  final case class HsCode(
    code: String,
    parent: _root_.scala.Option[String] = None,
    description: _root_.scala.Option[String] = None
  )

  /**
   * The tariff codes, duty rates and tax rates associated with an origin/destination
   * pair. Does not take into account sales province
   * 
   * @param origin The ISO 3166 3 character code for the country of origin
   * @param destination The ISO 3166 3 character code for the destination country
   * @param tariffCode The assigned tariff code for a product
   * @param effectiveDuty A percentage duty rate. Note that in the case of complex duties this will be
   *        calculated from the details of the item in question and may not scale with
   *        changes to price.
   */
  final case class LaneLandedCost(
    origin: String,
    destination: String,
    tariffCode: String,
    effectiveDuty: io.flow.price.v0.models.Duty,
    tax: io.flow.price.v0.models.Tax
  )

  /**
   * @param phrase A short phrase describing a product in generic terms, intended to uniquely
   *        identify a code from a harmonization system.
   * @param tariffCode The actual HS-10 code for a destination country.
   */
  final case class PhraseHint(
    phrase: String,
    tariffCode: io.flow.harmonization.v0.models.TariffCode
  )

  /**
   * @param phrase A short phrase describing a product in generic terms, intended to uniquely
   *        identify a code from a harmonization system.
   * @param destination The ISO 3166 3 character code for the destination country
   */
  final case class PhraseHintForm(
    phrase: String,
    destination: String
  ) extends HintForm

  /**
   * Harmonized System codes for specific products imported into specific countries.
   * These are between 4 and 12 digits and are used to select the correct duty rate.
   * 
   * @param code The digits of the tariff code, without any formatting spaces or dashes.
   * @param destination The ISO 3166 3 character code for the destination country
   * @param description Description of this code
   */
  final case class TariffCode(
    code: String,
    destination: String,
    description: _root_.scala.Option[String] = None
  )

  /**
   * Result of looking up a specific tax registration number. Indicates validity of a
   * number for a specific country and (if valid) the associated person/company.
   * 
   * @param number The tax registration number
   * @param resultReason Additional details - e.g. why the result was invalid
   * @param name The name associated with the tax registration number.
   * @param address The address associated with the tax registration number.
   */
  final case class TaxRegistration(
    id: String,
    key: String,
    number: String,
    timestamp: _root_.org.joda.time.DateTime,
    result: io.flow.harmonization.v0.models.TaxVerificationResult,
    resultReason: _root_.scala.Option[String] = None,
    name: _root_.scala.Option[String] = None,
    address: _root_.scala.Option[String] = None,
    companyName: _root_.scala.Option[String] = None
  )

  /**
   * @param number The tax registration number
   */
  final case class TaxRegistrationForm(
    number: String,
    companyName: _root_.scala.Option[String] = None
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union HintForm, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class HintFormUndefinedType(
    description: String
  ) extends HintForm

  sealed trait TaxApplicability extends _root_.scala.Product with _root_.scala.Serializable

  object TaxApplicability {

    /**
     * In no scenario should a customer pay tax within the Flow system.
     */
    case object None extends TaxApplicability { override def toString = "none" }
    /**
     * In all scenarios a customer should pay tax within the Flow system.
     */
    case object All extends TaxApplicability { override def toString = "all" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends TaxApplicability

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[TaxApplicability] = scala.List(None, All)

    private[this]
    val byName: Map[String, TaxApplicability] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TaxApplicability = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TaxApplicability] = byName.get(value.toLowerCase)

  }

  sealed trait TaxVerificationResult extends _root_.scala.Product with _root_.scala.Serializable

  object TaxVerificationResult {

    case object Valid extends TaxVerificationResult { override def toString = "valid" }
    case object Invalid extends TaxVerificationResult { override def toString = "invalid" }
    case object UnableToValidate extends TaxVerificationResult { override def toString = "unable_to_validate" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends TaxVerificationResult

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[TaxVerificationResult] = scala.List(Valid, Invalid, UnableToValidate)

    private[this]
    val byName: Map[String, TaxVerificationResult] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TaxVerificationResult = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TaxVerificationResult] = byName.get(value.toLowerCase)

  }

}

package io.flow.harmonization.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.common.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.harmonization.v0.models.json._
    import io.flow.permission.v0.models.json._
    import io.flow.price.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map { str =>
      _root_.java.util.UUID.fromString(str)
    }

    private[v0] implicit val jsonWritesUUID = new Writes[_root_.java.util.UUID] {
      def writes(x: _root_.java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[_root_.org.joda.time.DateTime] {
      def writes(x: _root_.org.joda.time.DateTime) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x))
      }
    }

    private[v0] implicit val jsonReadsJodaLocalDate = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDate = new Writes[_root_.org.joda.time.LocalDate] {
      def writes(x: _root_.org.joda.time.LocalDate) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.date.print(x))
      }
    }

    implicit val jsonReadsHarmonizationTaxApplicability = new play.api.libs.json.Reads[io.flow.harmonization.v0.models.TaxApplicability] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.harmonization.v0.models.TaxApplicability] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.harmonization.v0.models.TaxApplicability(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.harmonization.v0.models.TaxApplicability(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesHarmonizationTaxApplicability(obj: io.flow.harmonization.v0.models.TaxApplicability) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTaxApplicability(obj: io.flow.harmonization.v0.models.TaxApplicability) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesHarmonizationTaxApplicability: play.api.libs.json.Writes[TaxApplicability] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.TaxApplicability] {
        def writes(obj: io.flow.harmonization.v0.models.TaxApplicability) = {
          jsonWritesHarmonizationTaxApplicability(obj)
        }
      }
    }

    implicit val jsonReadsHarmonizationTaxVerificationResult = new play.api.libs.json.Reads[io.flow.harmonization.v0.models.TaxVerificationResult] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.harmonization.v0.models.TaxVerificationResult] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.harmonization.v0.models.TaxVerificationResult(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.harmonization.v0.models.TaxVerificationResult(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesHarmonizationTaxVerificationResult(obj: io.flow.harmonization.v0.models.TaxVerificationResult) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTaxVerificationResult(obj: io.flow.harmonization.v0.models.TaxVerificationResult) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesHarmonizationTaxVerificationResult: play.api.libs.json.Writes[TaxVerificationResult] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.TaxVerificationResult] {
        def writes(obj: io.flow.harmonization.v0.models.TaxVerificationResult) = {
          jsonWritesHarmonizationTaxVerificationResult(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHarmonizationSettings: play.api.libs.json.Reads[HarmonizationSettings] = {
      for {
        dutyStrategy <- (__ \ "duty_strategy").read[io.flow.price.v0.models.LevyStrategy]
        taxStrategy <- (__ \ "tax_strategy").read[io.flow.price.v0.models.LevyStrategy]
      } yield HarmonizationSettings(dutyStrategy, taxStrategy)
    }

    def jsObjectHarmonizationSettings(obj: io.flow.harmonization.v0.models.HarmonizationSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "duty_strategy" -> play.api.libs.json.JsString(obj.dutyStrategy.toString),
        "tax_strategy" -> play.api.libs.json.JsString(obj.taxStrategy.toString)
      )
    }

    implicit def jsonWritesHarmonizationHarmonizationSettings: play.api.libs.json.Writes[HarmonizationSettings] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HarmonizationSettings] {
        def writes(obj: io.flow.harmonization.v0.models.HarmonizationSettings) = {
          jsObjectHarmonizationSettings(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHarmonizationSettingsForm: play.api.libs.json.Reads[HarmonizationSettingsForm] = {
      for {
        dutyStrategy <- (__ \ "duty_strategy").readNullable[io.flow.price.v0.models.LevyStrategy]
        taxStrategy <- (__ \ "tax_strategy").readNullable[io.flow.price.v0.models.LevyStrategy]
      } yield HarmonizationSettingsForm(dutyStrategy, taxStrategy)
    }

    def jsObjectHarmonizationSettingsForm(obj: io.flow.harmonization.v0.models.HarmonizationSettingsForm): play.api.libs.json.JsObject = {
      (obj.dutyStrategy match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("duty_strategy" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.taxStrategy match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax_strategy" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizationSettingsForm: play.api.libs.json.Writes[HarmonizationSettingsForm] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HarmonizationSettingsForm] {
        def writes(obj: io.flow.harmonization.v0.models.HarmonizationSettingsForm) = {
          jsObjectHarmonizationSettingsForm(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedCategory: play.api.libs.json.Reads[HarmonizedCategory] = {
      for {
        id <- (__ \ "id").read[String]
        name <- (__ \ "name").read[String]
        parent <- (__ \ "parent").readNullable[io.flow.harmonization.v0.models.HarmonizedCategoryReference]
      } yield HarmonizedCategory(id, name, parent)
    }

    def jsObjectHarmonizedCategory(obj: io.flow.harmonization.v0.models.HarmonizedCategory): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.parent match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("parent" -> jsObjectHarmonizedCategoryReference(x))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizedCategory: play.api.libs.json.Writes[HarmonizedCategory] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HarmonizedCategory] {
        def writes(obj: io.flow.harmonization.v0.models.HarmonizedCategory) = {
          jsObjectHarmonizedCategory(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedCategoryReference: play.api.libs.json.Reads[HarmonizedCategoryReference] = {
      (__ \ "id").read[String].map { x => new HarmonizedCategoryReference(id = x) }
    }

    def jsObjectHarmonizedCategoryReference(obj: io.flow.harmonization.v0.models.HarmonizedCategoryReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesHarmonizationHarmonizedCategoryReference: play.api.libs.json.Writes[HarmonizedCategoryReference] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HarmonizedCategoryReference] {
        def writes(obj: io.flow.harmonization.v0.models.HarmonizedCategoryReference) = {
          jsObjectHarmonizedCategoryReference(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedItem: play.api.libs.json.Reads[HarmonizedItem] = {
      for {
        id <- (__ \ "id").read[String]
        number <- (__ \ "number").read[String]
        name <- (__ \ "name").read[String]
        categories <- (__ \ "categories").read[Seq[String]]
        attributes <- (__ \ "attributes").read[Map[String, String]]
        description <- (__ \ "description").readNullable[String]
      } yield HarmonizedItem(id, number, name, categories, attributes, description)
    }

    def jsObjectHarmonizedItem(obj: io.flow.harmonization.v0.models.HarmonizedItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number),
        "name" -> play.api.libs.json.JsString(obj.name),
        "categories" -> play.api.libs.json.Json.toJson(obj.categories),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizedItem: play.api.libs.json.Writes[HarmonizedItem] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HarmonizedItem] {
        def writes(obj: io.flow.harmonization.v0.models.HarmonizedItem) = {
          jsObjectHarmonizedItem(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedItemDuty: play.api.libs.json.Reads[HarmonizedItemDuty] = {
      for {
        id <- (__ \ "id").read[String]
        item <- (__ \ "item").read[io.flow.harmonization.v0.models.HarmonizedItemReference]
        origin <- (__ \ "origin").read[String]
        destination <- (__ \ "destination").read[String]
        rate <- (__ \ "rate").read[BigDecimal]
      } yield HarmonizedItemDuty(id, item, origin, destination, rate)
    }

    def jsObjectHarmonizedItemDuty(obj: io.flow.harmonization.v0.models.HarmonizedItemDuty): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "item" -> jsObjectHarmonizedItemReference(obj.item),
        "origin" -> play.api.libs.json.JsString(obj.origin),
        "destination" -> play.api.libs.json.JsString(obj.destination),
        "rate" -> play.api.libs.json.JsNumber(obj.rate)
      )
    }

    implicit def jsonWritesHarmonizationHarmonizedItemDuty: play.api.libs.json.Writes[HarmonizedItemDuty] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HarmonizedItemDuty] {
        def writes(obj: io.flow.harmonization.v0.models.HarmonizedItemDuty) = {
          jsObjectHarmonizedItemDuty(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedItemDutyForm: play.api.libs.json.Reads[HarmonizedItemDutyForm] = {
      for {
        number <- (__ \ "number").read[String]
        origin <- (__ \ "origin").read[String]
        destination <- (__ \ "destination").read[String]
        rate <- (__ \ "rate").read[BigDecimal]
      } yield HarmonizedItemDutyForm(number, origin, destination, rate)
    }

    def jsObjectHarmonizedItemDutyForm(obj: io.flow.harmonization.v0.models.HarmonizedItemDutyForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "origin" -> play.api.libs.json.JsString(obj.origin),
        "destination" -> play.api.libs.json.JsString(obj.destination),
        "rate" -> play.api.libs.json.JsNumber(obj.rate)
      )
    }

    implicit def jsonWritesHarmonizationHarmonizedItemDutyForm: play.api.libs.json.Writes[HarmonizedItemDutyForm] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HarmonizedItemDutyForm] {
        def writes(obj: io.flow.harmonization.v0.models.HarmonizedItemDutyForm) = {
          jsObjectHarmonizedItemDutyForm(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedItemDutyVersion: play.api.libs.json.Reads[HarmonizedItemDutyVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        harmonizedItemDuty <- (__ \ "harmonized_item_duty").read[io.flow.harmonization.v0.models.HarmonizedItemDuty]
      } yield HarmonizedItemDutyVersion(id, timestamp, `type`, harmonizedItemDuty)
    }

    def jsObjectHarmonizedItemDutyVersion(obj: io.flow.harmonization.v0.models.HarmonizedItemDutyVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "harmonized_item_duty" -> jsObjectHarmonizedItemDuty(obj.harmonizedItemDuty)
      )
    }

    implicit def jsonWritesHarmonizationHarmonizedItemDutyVersion: play.api.libs.json.Writes[HarmonizedItemDutyVersion] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HarmonizedItemDutyVersion] {
        def writes(obj: io.flow.harmonization.v0.models.HarmonizedItemDutyVersion) = {
          jsObjectHarmonizedItemDutyVersion(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedItemForm: play.api.libs.json.Reads[HarmonizedItemForm] = {
      for {
        name <- (__ \ "name").read[String]
        number <- (__ \ "number").read[String]
        categories <- (__ \ "categories").readNullable[Seq[String]]
        description <- (__ \ "description").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield HarmonizedItemForm(name, number, categories, description, attributes)
    }

    def jsObjectHarmonizedItemForm(obj: io.flow.harmonization.v0.models.HarmonizedItemForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "number" -> play.api.libs.json.JsString(obj.number)
      ) ++ (obj.categories match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("categories" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizedItemForm: play.api.libs.json.Writes[HarmonizedItemForm] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HarmonizedItemForm] {
        def writes(obj: io.flow.harmonization.v0.models.HarmonizedItemForm) = {
          jsObjectHarmonizedItemForm(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedItemPutForm: play.api.libs.json.Reads[HarmonizedItemPutForm] = {
      for {
        name <- (__ \ "name").read[String]
        categories <- (__ \ "categories").readNullable[Seq[String]]
        description <- (__ \ "description").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield HarmonizedItemPutForm(name, categories, description, attributes)
    }

    def jsObjectHarmonizedItemPutForm(obj: io.flow.harmonization.v0.models.HarmonizedItemPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.categories match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("categories" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizedItemPutForm: play.api.libs.json.Writes[HarmonizedItemPutForm] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HarmonizedItemPutForm] {
        def writes(obj: io.flow.harmonization.v0.models.HarmonizedItemPutForm) = {
          jsObjectHarmonizedItemPutForm(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedItemReference: play.api.libs.json.Reads[HarmonizedItemReference] = {
      for {
        id <- (__ \ "id").read[String]
        number <- (__ \ "number").read[String]
        description <- (__ \ "description").readNullable[String]
      } yield HarmonizedItemReference(id, number, description)
    }

    def jsObjectHarmonizedItemReference(obj: io.flow.harmonization.v0.models.HarmonizedItemReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizedItemReference: play.api.libs.json.Writes[HarmonizedItemReference] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HarmonizedItemReference] {
        def writes(obj: io.flow.harmonization.v0.models.HarmonizedItemReference) = {
          jsObjectHarmonizedItemReference(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedItemVersion: play.api.libs.json.Reads[HarmonizedItemVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        harmonizedItem <- (__ \ "harmonized_item").read[io.flow.harmonization.v0.models.HarmonizedItem]
      } yield HarmonizedItemVersion(id, timestamp, `type`, harmonizedItem)
    }

    def jsObjectHarmonizedItemVersion(obj: io.flow.harmonization.v0.models.HarmonizedItemVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "harmonized_item" -> jsObjectHarmonizedItem(obj.harmonizedItem)
      )
    }

    implicit def jsonWritesHarmonizationHarmonizedItemVersion: play.api.libs.json.Writes[HarmonizedItemVersion] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HarmonizedItemVersion] {
        def writes(obj: io.flow.harmonization.v0.models.HarmonizedItemVersion) = {
          jsObjectHarmonizedItemVersion(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedLandedCost: play.api.libs.json.Reads[HarmonizedLandedCost] = {
      for {
        address <- (__ \ "address").read[io.flow.common.v0.models.Address]
        items <- (__ \ "items").read[Seq[io.flow.harmonization.v0.models.HarmonizedLandedCostItem]]
        taxRegistration <- (__ \ "tax_registration").readNullable[io.flow.harmonization.v0.models.TaxRegistration]
      } yield HarmonizedLandedCost(address, items, taxRegistration)
    }

    def jsObjectHarmonizedLandedCost(obj: io.flow.harmonization.v0.models.HarmonizedLandedCost): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "address" -> io.flow.common.v0.models.json.jsObjectAddress(obj.address),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.taxRegistration match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax_registration" -> jsObjectTaxRegistration(x))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizedLandedCost: play.api.libs.json.Writes[HarmonizedLandedCost] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HarmonizedLandedCost] {
        def writes(obj: io.flow.harmonization.v0.models.HarmonizedLandedCost) = {
          jsObjectHarmonizedLandedCost(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedLandedCostForm: play.api.libs.json.Reads[HarmonizedLandedCostForm] = {
      for {
        address <- (__ \ "address").read[io.flow.common.v0.models.Address]
        itemNumbers <- (__ \ "item_numbers").read[Seq[String]]
        sourceAddress <- (__ \ "source_address").readNullable[io.flow.common.v0.models.Address]
        orderNumber <- (__ \ "order_number").readNullable[String]
        lineItems <- (__ \ "line_items").readNullable[Seq[io.flow.common.v0.models.LineItem]]
        taxRegistrationId <- (__ \ "tax_registration_id").readNullable[String]
        billingAddress <- (__ \ "billing_address").readNullable[io.flow.common.v0.models.BillingAddress]
      } yield HarmonizedLandedCostForm(address, itemNumbers, sourceAddress, orderNumber, lineItems, taxRegistrationId, billingAddress)
    }

    def jsObjectHarmonizedLandedCostForm(obj: io.flow.harmonization.v0.models.HarmonizedLandedCostForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "address" -> io.flow.common.v0.models.json.jsObjectAddress(obj.address),
        "item_numbers" -> play.api.libs.json.Json.toJson(obj.itemNumbers)
      ) ++ (obj.sourceAddress match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("source_address" -> io.flow.common.v0.models.json.jsObjectAddress(x))
      }) ++
      (obj.orderNumber match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order_number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.lineItems match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("line_items" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.taxRegistrationId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax_registration_id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.billingAddress match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("billing_address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizedLandedCostForm: play.api.libs.json.Writes[HarmonizedLandedCostForm] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HarmonizedLandedCostForm] {
        def writes(obj: io.flow.harmonization.v0.models.HarmonizedLandedCostForm) = {
          jsObjectHarmonizedLandedCostForm(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedLandedCostItem: play.api.libs.json.Reads[HarmonizedLandedCostItem] = {
      for {
        item <- (__ \ "item").read[io.flow.harmonization.v0.models.HarmonizedItemReference]
        duty <- (__ \ "duty").read[io.flow.price.v0.models.Duty]
        tax <- (__ \ "tax").read[io.flow.price.v0.models.Tax]
        taxApplicability <- (__ \ "tax_applicability").readNullable[io.flow.harmonization.v0.models.TaxApplicability]
      } yield HarmonizedLandedCostItem(item, duty, tax, taxApplicability)
    }

    def jsObjectHarmonizedLandedCostItem(obj: io.flow.harmonization.v0.models.HarmonizedLandedCostItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "item" -> jsObjectHarmonizedItemReference(obj.item),
        "duty" -> io.flow.price.v0.models.json.jsObjectDuty(obj.duty),
        "tax" -> io.flow.price.v0.models.json.jsObjectTax(obj.tax)
      ) ++ (obj.taxApplicability match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax_applicability" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizedLandedCostItem: play.api.libs.json.Writes[HarmonizedLandedCostItem] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HarmonizedLandedCostItem] {
        def writes(obj: io.flow.harmonization.v0.models.HarmonizedLandedCostItem) = {
          jsObjectHarmonizedLandedCostItem(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHintResult: play.api.libs.json.Reads[HintResult] = {
      for {
        tariffCode <- (__ \ "tariff_code").read[io.flow.harmonization.v0.models.TariffCode]
        likelihood <- (__ \ "likelihood").read[BigDecimal]
      } yield HintResult(tariffCode, likelihood)
    }

    def jsObjectHintResult(obj: io.flow.harmonization.v0.models.HintResult): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "tariff_code" -> jsObjectTariffCode(obj.tariffCode),
        "likelihood" -> play.api.libs.json.JsNumber(obj.likelihood)
      )
    }

    implicit def jsonWritesHarmonizationHintResult: play.api.libs.json.Writes[HintResult] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HintResult] {
        def writes(obj: io.flow.harmonization.v0.models.HintResult) = {
          jsObjectHintResult(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHs10: play.api.libs.json.Reads[Hs10] = {
      for {
        id <- (__ \ "id").read[String]
        item <- (__ \ "item").read[io.flow.harmonization.v0.models.HarmonizedItemReference]
        origin <- (__ \ "origin").read[String]
        destination <- (__ \ "destination").read[String]
        code <- (__ \ "code").read[String]
      } yield Hs10(id, item, origin, destination, code)
    }

    def jsObjectHs10(obj: io.flow.harmonization.v0.models.Hs10): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "item" -> jsObjectHarmonizedItemReference(obj.item),
        "origin" -> play.api.libs.json.JsString(obj.origin),
        "destination" -> play.api.libs.json.JsString(obj.destination),
        "code" -> play.api.libs.json.JsString(obj.code)
      )
    }

    implicit def jsonWritesHarmonizationHs10: play.api.libs.json.Writes[Hs10] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.Hs10] {
        def writes(obj: io.flow.harmonization.v0.models.Hs10) = {
          jsObjectHs10(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHs10Version: play.api.libs.json.Reads[Hs10Version] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        hs10 <- (__ \ "hs10").read[io.flow.harmonization.v0.models.Hs10]
      } yield Hs10Version(id, timestamp, `type`, hs10)
    }

    def jsObjectHs10Version(obj: io.flow.harmonization.v0.models.Hs10Version): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "hs10" -> jsObjectHs10(obj.hs10)
      )
    }

    implicit def jsonWritesHarmonizationHs10Version: play.api.libs.json.Writes[Hs10Version] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.Hs10Version] {
        def writes(obj: io.flow.harmonization.v0.models.Hs10Version) = {
          jsObjectHs10Version(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHs6: play.api.libs.json.Reads[Hs6] = {
      for {
        id <- (__ \ "id").read[String]
        item <- (__ \ "item").read[io.flow.harmonization.v0.models.HarmonizedItemReference]
        code <- (__ \ "code").read[String]
      } yield Hs6(id, item, code)
    }

    def jsObjectHs6(obj: io.flow.harmonization.v0.models.Hs6): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "item" -> jsObjectHarmonizedItemReference(obj.item),
        "code" -> play.api.libs.json.JsString(obj.code)
      )
    }

    implicit def jsonWritesHarmonizationHs6: play.api.libs.json.Writes[Hs6] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.Hs6] {
        def writes(obj: io.flow.harmonization.v0.models.Hs6) = {
          jsObjectHs6(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHs6Version: play.api.libs.json.Reads[Hs6Version] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        hs6 <- (__ \ "hs6").read[io.flow.harmonization.v0.models.Hs6]
      } yield Hs6Version(id, timestamp, `type`, hs6)
    }

    def jsObjectHs6Version(obj: io.flow.harmonization.v0.models.Hs6Version): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "hs6" -> jsObjectHs6(obj.hs6)
      )
    }

    implicit def jsonWritesHarmonizationHs6Version: play.api.libs.json.Writes[Hs6Version] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.Hs6Version] {
        def writes(obj: io.flow.harmonization.v0.models.Hs6Version) = {
          jsObjectHs6Version(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHsCode: play.api.libs.json.Reads[HsCode] = {
      for {
        code <- (__ \ "code").read[String]
        parent <- (__ \ "parent").readNullable[String]
        description <- (__ \ "description").readNullable[String]
      } yield HsCode(code, parent, description)
    }

    def jsObjectHsCode(obj: io.flow.harmonization.v0.models.HsCode): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code)
      ) ++ (obj.parent match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("parent" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesHarmonizationHsCode: play.api.libs.json.Writes[HsCode] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HsCode] {
        def writes(obj: io.flow.harmonization.v0.models.HsCode) = {
          jsObjectHsCode(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationLaneLandedCost: play.api.libs.json.Reads[LaneLandedCost] = {
      for {
        origin <- (__ \ "origin").read[String]
        destination <- (__ \ "destination").read[String]
        tariffCode <- (__ \ "tariff_code").read[String]
        effectiveDuty <- (__ \ "effective_duty").read[io.flow.price.v0.models.Duty]
        tax <- (__ \ "tax").read[io.flow.price.v0.models.Tax]
      } yield LaneLandedCost(origin, destination, tariffCode, effectiveDuty, tax)
    }

    def jsObjectLaneLandedCost(obj: io.flow.harmonization.v0.models.LaneLandedCost): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "origin" -> play.api.libs.json.JsString(obj.origin),
        "destination" -> play.api.libs.json.JsString(obj.destination),
        "tariff_code" -> play.api.libs.json.JsString(obj.tariffCode),
        "effective_duty" -> io.flow.price.v0.models.json.jsObjectDuty(obj.effectiveDuty),
        "tax" -> io.flow.price.v0.models.json.jsObjectTax(obj.tax)
      )
    }

    implicit def jsonWritesHarmonizationLaneLandedCost: play.api.libs.json.Writes[LaneLandedCost] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.LaneLandedCost] {
        def writes(obj: io.flow.harmonization.v0.models.LaneLandedCost) = {
          jsObjectLaneLandedCost(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationPhraseHint: play.api.libs.json.Reads[PhraseHint] = {
      for {
        phrase <- (__ \ "phrase").read[String]
        tariffCode <- (__ \ "tariff_code").read[io.flow.harmonization.v0.models.TariffCode]
      } yield PhraseHint(phrase, tariffCode)
    }

    def jsObjectPhraseHint(obj: io.flow.harmonization.v0.models.PhraseHint): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "phrase" -> play.api.libs.json.JsString(obj.phrase),
        "tariff_code" -> jsObjectTariffCode(obj.tariffCode)
      )
    }

    implicit def jsonWritesHarmonizationPhraseHint: play.api.libs.json.Writes[PhraseHint] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.PhraseHint] {
        def writes(obj: io.flow.harmonization.v0.models.PhraseHint) = {
          jsObjectPhraseHint(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationPhraseHintForm: play.api.libs.json.Reads[PhraseHintForm] = {
      for {
        phrase <- (__ \ "phrase").read[String]
        destination <- (__ \ "destination").read[String]
      } yield PhraseHintForm(phrase, destination)
    }

    def jsObjectPhraseHintForm(obj: io.flow.harmonization.v0.models.PhraseHintForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "phrase" -> play.api.libs.json.JsString(obj.phrase),
        "destination" -> play.api.libs.json.JsString(obj.destination)
      )
    }

    implicit def jsonReadsHarmonizationTariffCode: play.api.libs.json.Reads[TariffCode] = {
      for {
        code <- (__ \ "code").read[String]
        destination <- (__ \ "destination").read[String]
        description <- (__ \ "description").readNullable[String]
      } yield TariffCode(code, destination, description)
    }

    def jsObjectTariffCode(obj: io.flow.harmonization.v0.models.TariffCode): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code),
        "destination" -> play.api.libs.json.JsString(obj.destination)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesHarmonizationTariffCode: play.api.libs.json.Writes[TariffCode] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.TariffCode] {
        def writes(obj: io.flow.harmonization.v0.models.TariffCode) = {
          jsObjectTariffCode(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationTaxRegistration: play.api.libs.json.Reads[TaxRegistration] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        number <- (__ \ "number").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        result <- (__ \ "result").read[io.flow.harmonization.v0.models.TaxVerificationResult]
        resultReason <- (__ \ "result_reason").readNullable[String]
        name <- (__ \ "name").readNullable[String]
        address <- (__ \ "address").readNullable[String]
        companyName <- (__ \ "company_name").readNullable[String]
      } yield TaxRegistration(id, key, number, timestamp, result, resultReason, name, address, companyName)
    }

    def jsObjectTaxRegistration(obj: io.flow.harmonization.v0.models.TaxRegistration): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "number" -> play.api.libs.json.JsString(obj.number),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "result" -> play.api.libs.json.JsString(obj.result.toString)
      ) ++ (obj.resultReason match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("result_reason" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.companyName match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("company_name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesHarmonizationTaxRegistration: play.api.libs.json.Writes[TaxRegistration] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.TaxRegistration] {
        def writes(obj: io.flow.harmonization.v0.models.TaxRegistration) = {
          jsObjectTaxRegistration(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationTaxRegistrationForm: play.api.libs.json.Reads[TaxRegistrationForm] = {
      for {
        number <- (__ \ "number").read[String]
        companyName <- (__ \ "company_name").readNullable[String]
      } yield TaxRegistrationForm(number, companyName)
    }

    def jsObjectTaxRegistrationForm(obj: io.flow.harmonization.v0.models.TaxRegistrationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number)
      ) ++ (obj.companyName match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("company_name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesHarmonizationTaxRegistrationForm: play.api.libs.json.Writes[TaxRegistrationForm] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.TaxRegistrationForm] {
        def writes(obj: io.flow.harmonization.v0.models.TaxRegistrationForm) = {
          jsObjectTaxRegistrationForm(obj)
        }
      }
    }

    implicit def jsonReadsHarmonizationHintForm: play.api.libs.json.Reads[HintForm] = new play.api.libs.json.Reads[HintForm] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[HintForm] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[HintForm] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "phrase_hint_form" => js.validate[io.flow.harmonization.v0.models.PhraseHintForm]
          case other => play.api.libs.json.JsSuccess(io.flow.harmonization.v0.models.HintFormUndefinedType(other))
        }
      }
    }

    def jsObjectHintForm(obj: io.flow.harmonization.v0.models.HintForm): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.harmonization.v0.models.PhraseHintForm => jsObjectPhraseHintForm(x) ++ play.api.libs.json.Json.obj("discriminator" -> "phrase_hint_form")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesHarmonizationHintForm: play.api.libs.json.Writes[HintForm] = {
      new play.api.libs.json.Writes[io.flow.harmonization.v0.models.HintForm] {
        def writes(obj: io.flow.harmonization.v0.models.HintForm) = {
          jsObjectHintForm(obj)
        }
      }
    }
  }
}

package io.flow.harmonization.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}

    // import models directly for backwards compatibility with prior versions of the generator
    import Core._
    import Models._

    object Core {
      implicit def pathBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.DateTime] = ApibuilderPathBindable(ApibuilderTypes.dateTimeIso8601)
      implicit def queryStringBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.DateTime] = ApibuilderQueryStringBindable(ApibuilderTypes.dateTimeIso8601)

      implicit def pathBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.LocalDate] = ApibuilderPathBindable(ApibuilderTypes.dateIso8601)
      implicit def queryStringBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.LocalDate] = ApibuilderQueryStringBindable(ApibuilderTypes.dateIso8601)
    }

    object Models {
      import io.flow.harmonization.v0.models._

      val taxApplicabilityConverter: ApibuilderTypeConverter[io.flow.harmonization.v0.models.TaxApplicability] = new ApibuilderTypeConverter[io.flow.harmonization.v0.models.TaxApplicability] {
        override def convert(value: String): io.flow.harmonization.v0.models.TaxApplicability = io.flow.harmonization.v0.models.TaxApplicability(value)
        override def convert(value: io.flow.harmonization.v0.models.TaxApplicability): String = value.toString
        override def example: io.flow.harmonization.v0.models.TaxApplicability = io.flow.harmonization.v0.models.TaxApplicability.None
        override def validValues: Seq[io.flow.harmonization.v0.models.TaxApplicability] = io.flow.harmonization.v0.models.TaxApplicability.all
      }
      implicit def pathBindableTaxApplicability(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.harmonization.v0.models.TaxApplicability] = ApibuilderPathBindable(taxApplicabilityConverter)
      implicit def queryStringBindableTaxApplicability(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.harmonization.v0.models.TaxApplicability] = ApibuilderQueryStringBindable(taxApplicabilityConverter)

      val taxVerificationResultConverter: ApibuilderTypeConverter[io.flow.harmonization.v0.models.TaxVerificationResult] = new ApibuilderTypeConverter[io.flow.harmonization.v0.models.TaxVerificationResult] {
        override def convert(value: String): io.flow.harmonization.v0.models.TaxVerificationResult = io.flow.harmonization.v0.models.TaxVerificationResult(value)
        override def convert(value: io.flow.harmonization.v0.models.TaxVerificationResult): String = value.toString
        override def example: io.flow.harmonization.v0.models.TaxVerificationResult = io.flow.harmonization.v0.models.TaxVerificationResult.Valid
        override def validValues: Seq[io.flow.harmonization.v0.models.TaxVerificationResult] = io.flow.harmonization.v0.models.TaxVerificationResult.all
      }
      implicit def pathBindableTaxVerificationResult(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.harmonization.v0.models.TaxVerificationResult] = ApibuilderPathBindable(taxVerificationResultConverter)
      implicit def queryStringBindableTaxVerificationResult(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.harmonization.v0.models.TaxVerificationResult] = ApibuilderQueryStringBindable(taxVerificationResultConverter)
    }

    trait ApibuilderTypeConverter[T] {

      def convert(value: String): T

      def convert(value: T): String

      def example: T

      def validValues: Seq[T] = Nil

      def errorMessage(key: String, value: String, ex: java.lang.Exception): String = {
        val base = s"Invalid value '$value' for parameter '$key'. "
        validValues.toList match {
          case Nil => base + "Ex: " + convert(example)
          case values => base + ". Valid values are: " + values.mkString("'", "', '", "'")
        }
      }
    }

    object ApibuilderTypes {
      val dateTimeIso8601: ApibuilderTypeConverter[_root_.org.joda.time.DateTime] = new ApibuilderTypeConverter[_root_.org.joda.time.DateTime] {
        override def convert(value: String): _root_.org.joda.time.DateTime = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(value)
        override def convert(value: _root_.org.joda.time.DateTime): String = _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(value)
        override def example: _root_.org.joda.time.DateTime = _root_.org.joda.time.DateTime.now
      }

      val dateIso8601: ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] = new ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] {
        override def convert(value: String): _root_.org.joda.time.LocalDate = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(value)
        override def convert(value: _root_.org.joda.time.LocalDate): String = _root_.org.joda.time.format.ISODateTimeFormat.date.print(value)
        override def example: _root_.org.joda.time.LocalDate = _root_.org.joda.time.LocalDate.now
      }
    }

    final case class ApibuilderQueryStringBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends QueryStringBindable[T] {

      override def bind(key: String, params: Map[String, Seq[String]]): _root_.scala.Option[_root_.scala.Either[String, T]] = {
        params.getOrElse(key, Nil).headOption.map { v =>
          try {
            Right(
              converters.convert(v)
            )
          } catch {
            case ex: java.lang.Exception => Left(
              converters.errorMessage(key, v, ex)
            )
          }
        }
      }

      override def unbind(key: String, value: T): String = {
        s"$key=${converters.convert(value)}"
      }
    }

    final case class ApibuilderPathBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends PathBindable[T] {

      override def bind(key: String, value: String): _root_.scala.Either[String, T] = {
        try {
          Right(
            converters.convert(value)
          )
        } catch {
          case ex: java.lang.Exception => Left(
            converters.errorMessage(key, value, ex)
          )
        }
      }

      override def unbind(key: String, value: T): String = {
        converters.convert(value)
      }
    }

  }

}
